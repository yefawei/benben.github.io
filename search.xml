<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/13/hello-world/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><blockquote>
<p>Welcome to my blog.</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Java核心技术卷一基础知识-笔记</title>
    <url>/2020/09/13/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ol>
<li>已经清楚或能够估计出元素容量，可以在添加元素前调用【ensureCapacity(100)】函数，或在构造函数中传入【new ArrayList&lt;&gt;(100)】</li>
<li>添加完元素后明确不再添加任何元素时，可调用【trimToSize()】，以释放多余空间</li>
</ol>
<h5 id="带资源try语句"><a href="#带资源try语句" class="headerlink" title="带资源try语句"></a>带资源try语句</h5><p>普通try-catch方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//open a resource</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// catch error</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//close the resource</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缺点：</span></span><br><span class="line"><span class="comment">//     当try块发生非catch能处理的异常，如果此时finally块也发生异常，那么会丢失原始异常，转而抛出finally产生的异常</span></span><br><span class="line"><span class="comment">//     这样会有一个问题，如果需要将try块的异常向外抛出，需要对try块异常通过变量存起来，并在finally中判断是否需要向外抛出</span></span><br></pre></td></tr></table></figure>

<p>带资源try方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Recource res = ...) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     资源需要属于AutoCloseable的子接口的子类才能使用这种方式，其中Closeable接口为AutoCloseable的子接口</span></span><br><span class="line"><span class="comment">//     try块正常退出或者存在一个异常时，都会自动调用res.close()方法，同时还可以指定多个资源</span></span><br><span class="line"><span class="keyword">try</span>(InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     上面提到，原始try-catch方式当try抛出异常，finally块也抛出异常，会产生一个难题</span></span><br><span class="line"><span class="comment">//     带资源的try方式能很好的处理这种情况，原来的异常会重新抛出，close产生的异常会被try异常通过addSuppressed添加进去，该过程称为“抑制”</span></span><br><span class="line"><span class="comment">//     如果对close产生的异常感兴趣，可以调用getSuppressed获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>(Recource res = ...) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// catch error</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// do finally block</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     带资源的try语句同样也可以添加catch子句和finally子句</span></span><br><span class="line"><span class="comment">//     执行顺序为 try块 -&gt; close -&gt; catch块(如果有异常的话) -&gt; finally块</span></span><br></pre></td></tr></table></figure>



<h5 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以获取所有线程的堆栈轨迹</span></span><br><span class="line">Thread.getAllStackTraces();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印堆栈轨迹：内部实际是new Exception(&quot;Stack trace&quot;).printStackTrace();</span></span><br><span class="line">Thread.dumpStack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常捕获处理顺序：线程 -&gt; 线程对象 -&gt; 未捕获异常Handler</span></span><br><span class="line"><span class="comment">// 设置未捕获异常处理器，用于捕获线程未捕获的异常</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个“抑制”异常，如在带资源try中会出现</span></span><br><span class="line">addSuppressed(Throwable t)</span><br><span class="line"><span class="comment">// 将该异常对象设置为“原因”</span></span><br><span class="line">initCause(Throwable t)</span><br><span class="line"><span class="comment">// 例：</span></span><br><span class="line"><span class="keyword">try</span>&#123;&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    Exception r = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    r.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Java日志"><a href="#Java日志" class="headerlink" title="Java日志"></a>Java日志</h5><p>全局日志记录器：<br><code>Logger.getGlobal().info(&quot;msg&quot;);</code></p>
<p>自定义日志记录器：<br><code>private static final Logger myLogger = Logger.getLogger(&quot;com.mycompany.myapp&quot;);</code></p>
<h5 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h5><blockquote>
<p>消除函数调用,采用类变量直接访问，可以减少函数栈的调用，提高效率</p>
<p>从【c.getName()】 变更为【c.name】的形式</p>
</blockquote>
<p>即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“ 内联”）。即时编译器知道那些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。</p>
<p>是否将某个方法设置为内联方法是Java 虚拟机的任务。即时编译器会监视调用那些<strong>简洁</strong>、<strong>经常被调用</strong>、<strong>没有被重载</strong>以及<strong>可优化</strong>的方法。</p>
<p>在早期的Java 中， 有些程序员为了避免动态绑定带来的系统开销而使用final 关键字。如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理， 这个过程为称为内联( inlining )。例如，内联调用e.getName( ) 将被替换为访问e.name 域。这是一项很有意义的改进， 这是由于CPU 在处理调用方法的指令时， 使用的分支转移会扰乱预取指令的策略， 所以，这被视为不受欢迎的。然而， 如果getName 在另外一个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作， 因此也就不能对它进行内联处理了。</p>
<p>幸运的是， 虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系， 并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正地被覆盖， 那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖， 那么将会发生什么情况呢？ 优化器将取消对覆盖方法的内联。这个过程很慢， 但却很少发生。</p>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TestEnum</span> </span>&#123;</span><br><span class="line">    Red(<span class="string">&quot;red&quot;</span>), Blue(<span class="string">&quot;blue&quot;</span>), Green(<span class="string">&quot;green&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    TestEnum(String color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnum</span> <span class="keyword">extends</span> <span class="title">Enum</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestEnum[] values()&#123;</span><br><span class="line">        <span class="keyword">return</span> (TestEnum[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestEnum <span class="title">valueOf</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (TestEnum)Enum.valueOf(com/benben/TestEnum, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestEnum</span><span class="params">(String s, <span class="keyword">int</span> i, String s1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        mColor = s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Red;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Blue;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Green;</span><br><span class="line">    <span class="keyword">private</span> String mColor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum $VALUES[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Red = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Red&quot;</span>, <span class="number">0</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        Blue = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Blue&quot;</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        Green = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Green&quot;</span>, <span class="number">2</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> TestEnum[] &#123;</span><br><span class="line">            Red, Blue, Green</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意一：从上面可以看出，枚举会消耗更多的内存，类似于饿汉式的单例</strong></p>
<p><strong>注意二：Proguard以及Android的R8也会对简单的枚举（即不实现接口也没有额外成员的枚举）做优化</strong></p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><blockquote>
<p>对于final的基本变量类型，在编译字节码的时候会被认为不会再改变，会将值直接放入调用处，所以反射对它无效</p>
<p>如果是static final的基本变量类型，修改值会产生异常，必须要修改可以再反射修改它的<code>modifiers</code>值以达到能修改的目的，注意：目前jvm并没有对该字段有限制</p>
</blockquote>
<h5 id="反射效率低"><a href="#反射效率低" class="headerlink" title="反射效率低"></a>反射效率低</h5><p>java反射效率低的主要原因是：</p>
<ol>
<li>Method#invoke 方法会对参数做封装和解封操作</li>
<li>需要检查方法可见性。原因：反射时每次调用都必须检查方法的可见性（在Method.invoke里）</li>
<li>需要校验参数。反射时也必须检查每个实际参数与形式参数的类型匹配性（在NativeMethodAccessorImpl.invoke0 里或者生成的 Java 版 MethodAccessor.invoke 里）</li>
<li>反射方法难以内联。参考：<a href="https://www.iteye.com/blog/rednaxelafx-548536">https://www.iteye.com/blog/rednaxelafx-548536</a></li>
<li>JIT 无法优化。原因：因为涉及到动态解析的类型，所以无法优化</li>
</ol>
<p>提高反射性能的方式：</p>
<ol>
<li>将反射获取到的类，构造函数，函数，对象实例缓存起来，不用每次都全新查找</li>
<li>可通过调用method.setAccessible(true)的方式来关闭Method.invoke可见性检查</li>
<li>需要更极致的提高效率可以通过字节码生成的方式来实现反射机制。参考：<a href="https://github.com/EsotericSoftware/reflectasm">https://github.com/EsotericSoftware/reflectasm</a></li>
</ol>
<h5 id="Lambda高阶参考"><a href="#Lambda高阶参考" class="headerlink" title="Lambda高阶参考"></a>Lambda高阶参考</h5><p><a href="https://baijiahao.baidu.com/s?id=1606476168883238803&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1606476168883238803&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>代理</title>
    <url>/2020/11/09/Java/%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>主要目的是扩展原有类的功能</p>
</blockquote>
<h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerImpl</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handle: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerProxy</span> <span class="keyword">implements</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="comment">// 传入需要代理的实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerProxy</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩展其用法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        mHandler.handle(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">new</span> HandlerProxy(<span class="keyword">new</span> HandlerImpl()).handle(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>就这样，知道缺点是被代理的类扩展了代理类也需一并扩展。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerImpl</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handle: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明实现InvocationHandler的处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入需要代理的实例对象</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        <span class="comment">// 利用反射机制将请求分派给委托类处理</span></span><br><span class="line">        Object invoke = method.invoke(mHandler, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Handler o = (Handler) Proxy.newProxyInstance(</span><br><span class="line">	    <span class="comment">// 类加载器</span></span><br><span class="line">        HandlerImpl.class.getClassLoader(),</span><br><span class="line">    	<span class="comment">// 需要代理的接口，也可：HandlerImpl.class.getInterfaces()</span></span><br><span class="line">    	<span class="keyword">new</span> Class[]&#123;Handler.class&#125;,</span><br><span class="line">    	<span class="comment">// 处理器</span></span><br><span class="line">        <span class="keyword">new</span> MyHandler(<span class="keyword">new</span> HandlerImpl()));</span><br><span class="line">o.handle(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，动态代理跟静态代理一样，在代理类内部保存了一个委托类的实例，实际上都是调用原来的委托实例来进行需要的操作。</p>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ol>
<li>动态代理跟静态代理最大的不同便是生成代理类的时期不同，静态代理是在编译期，而动态代理则是在运行时根据委托类信息动态生成</li>
<li>动态代理实现的是<code>InvocationHandler</code>接口，而静态代理则是直接实现公共接口</li>
<li>动态代理可以获得更多的运行时信息，使用起来也会更加灵活</li>
</ol>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>由于最终调用实际逻辑采用方法反射调用的方式，效率并不是很高</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>最终通过<code>ProxyGenerator.generateProxyClass()</code>函数动态生成代理字节码二进制数据，然后通过native方法<code>defineClass0</code>将字节码加载进方法区，并获取参数为<code>InvocationHandler</code>的构造器，然后通过该构造器生成实例并传入我们自定义的处理器</p>
<p><strong>注：android中直接通过<code>generateProxy</code>生成了代理类，并没有走<code>ProxyGenerator</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant Proxy</span><br><span class="line">participant Proxy#ProxyClassFactory</span><br><span class="line">participant WeakCache</span><br><span class="line">participant WeakCache#Factory</span><br><span class="line"></span><br><span class="line">Note left of WeakCache:Proxy类里有静态实例WeakCache成员变量\n生成该实例时传入ProxyClassFactory实例</span><br><span class="line">Proxy -&gt; WeakCache:Proxy.getProxyClass0()</span><br><span class="line">Note right of WeakCache:优先查找缓存</span><br><span class="line">WeakCache -&gt; WeakCache:proxyClassCache.get()</span><br><span class="line">WeakCache -&gt; Proxy:有缓存</span><br><span class="line">Note right of WeakCache:构建Factory工厂类</span><br><span class="line">WeakCache -&gt; WeakCache:new Factory()</span><br><span class="line">WeakCache -&gt; WeakCache#Factory:supplier.get()</span><br><span class="line">WeakCache#Factory -&gt; Proxy#ProxyClassFactory:valueFactory.apply()</span><br><span class="line">Note right of Proxy#ProxyClassFactory:1.类加载器是否解析出相同的class对象</span><br><span class="line">Note right of Proxy#ProxyClassFactory:2.class是否是一个接口</span><br><span class="line">Note right of Proxy#ProxyClassFactory:3.数组类是否重复等判断</span><br><span class="line">Note right of Proxy#ProxyClassFactory:调用defineClass0（native方法）动态生成字节码</span><br><span class="line">Proxy#ProxyClassFactory -&gt; Proxy:ProxyGenerator.generateProxyClass() \n defineClass0()</span><br><span class="line">Note right of Proxy:取参数为InvocationHandler构造器</span><br><span class="line">Note right of Proxy:通过构造器生成实例时传入处理器</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h3><blockquote>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充</p>
<p>通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择</p>
<p>git地址：<a href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a></p>
<p>cglib-nodep-xxx.jar:使用nodep包不需要关联asm的jar包,jar包内部包含asm的类.<br>cglib-xxx.jar:使用此jar包需要关联asm的jar包,否则运行时报错.</p>
</blockquote>
<h5 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_1</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_2</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_3</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handler handler = (Handler) Enhancer.create(Handler.class, <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        <span class="comment">// methodProxy 代理类方法代理引用，invokeSuper调用实际逻辑</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">handler.method_1(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h6><blockquote>
<p>作用：可以针对不同的方法调用不同的逻辑，</p>
<p>注意：虽然可以在<code>MethodInterceptor</code>的intercept方法进行区分，但使用过滤器可以有效的减少哈希查找，提高效率</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 什么操作都不做，直接调用实际方法</span></span><br><span class="line">NoOp instance = NoOp.INSTANCE;</span><br><span class="line"><span class="comment">// 锁定方法返回值，不会触发实际方法</span></span><br><span class="line">FixedValue fixedValue = <span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;锁定调用结果&quot;</span>);</span><br><span class="line">        Object result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 拦截操作</span></span><br><span class="line">MethodInterceptor methodInterceptor = <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Handler handler = (Handler) Enhancer.create(Handler.class, <span class="keyword">null</span>, <span class="keyword">new</span> CallbackFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_1&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_2&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Callback[]&#123;instance, fixedValue, methodInterceptor&#125;);</span><br><span class="line">handler.method_1(<span class="string">&quot;method_1&quot;</span>);</span><br><span class="line">handler.method_2(<span class="string">&quot;method_2&quot;</span>);</span><br><span class="line">handler.method_3(<span class="string">&quot;method_3&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延迟加载类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBeam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LazyLoader 只有在代理类调用任意方法时才会初始化数据，只会触发一次loadObject</span></span><br><span class="line">LazyBeam lazyBeam = (LazyBeam) Enhancer.create(LazyBeam.class, <span class="keyword">null</span>, <span class="keyword">new</span> LazyLoader() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载数据&quot;</span>);</span><br><span class="line">        LazyBeam lazyBeam = <span class="keyword">new</span> LazyBeam();</span><br><span class="line">        lazyBeam.setName(<span class="string">&quot;lazyBeam&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> lazyBeam;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(lazyBeam.getName());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatcher 只有在代理类调用任意方法时才会初始化数据,且每次都会触发loadObject</span></span><br><span class="line">LazyBeam lazyBeam = (LazyBeam) Enhancer.create(LazyBeam.class, <span class="keyword">null</span>, <span class="keyword">new</span> Dispatcher() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载数据&quot;</span>);</span><br><span class="line">        LazyBeam lazyBeam = <span class="keyword">new</span> LazyBeam();</span><br><span class="line">        lazyBeam.setName(<span class="string">&quot;lazyBeam&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> lazyBeam;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(lazyBeam.getName());</span><br></pre></td></tr></table></figure>

<h6 id="接口生成："><a href="#接口生成：" class="headerlink" title="接口生成："></a>接口生成：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterfaceMaker maker = <span class="keyword">new</span> InterfaceMaker();</span><br><span class="line">maker.add(Handler.class);</span><br><span class="line">Class&lt;?&gt; aClass = maker.create();</span><br><span class="line"><span class="keyword">for</span> (Method method : aClass.getMethods()) &#123;</span><br><span class="line">    System.out.println(method.getName());</span><br><span class="line">&#125;</span><br><span class="line">Object obj = Enhancer.create(Object.class, <span class="keyword">new</span> Class[]&#123;aClass&#125;, <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_1&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行方法1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;方法1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_2&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行方法2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;方法2&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Method method_1 = aClass.getMethod(<span class="string">&quot;method_1&quot;</span>, String.class);</span><br><span class="line">method_1.invoke(obj,<span class="string">&quot;方法1&quot;</span>);</span><br><span class="line">Method method_2 = aClass.getMethod(<span class="string">&quot;method_2&quot;</span>, String.class);</span><br><span class="line">method_2.invoke(obj,<span class="string">&quot;方法2&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h5><h6 id="表层原理："><a href="#表层原理：" class="headerlink" title="表层原理："></a>表层原理：</h6><p>动态生成代理类的子类，子类重写要代理的类的所有不是final/private的方法。在子类采用方法拦截的技术拦截所有父类方法的调用。</p>
<h6 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h6><p>使用字节码处理框架ASM，来转换字节码并生成新的类。<strong>注：不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</strong></p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>相较与JDK动态代理</p>
<ol>
<li>可以实现接口和类的代理，局限性更小【<strong>注：代理接口调用<code>invokeSuper</code>相当于直接调用未实现的接口方法，会直接报错</strong>】</li>
<li>由于与实际编写继承代码无异，采用的是动态用生成子类方式，方法执行效率要高</li>
<li>有丰富的操作策略以适应不同的业务</li>
</ol>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>由于采用继承的关系，对私有方法和final方法无法代理</p>
<h6 id="包说明："><a href="#包说明：" class="headerlink" title="包说明："></a>包说明：</h6><p><code>net.sf.cglib.core</code>:底层字节码处理类，他们大部分与ASM有关系。<br><code>net.sf.cglib.transform</code>:编译期或运行期类和类文件的转换<br><code>net.sf.cglib.proxy</code>:实现创建代理和方法拦截器的类<br><code>net.sf.cglib.reflect</code>:实现快速反射和C#风格代理的类<br><code>net.sf.cglib.util</code>:集合排序等工具类<br><code>net.sf.cglib.beans</code>:JavaBean相关的工具类</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2020/11/08/Java/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="java知识点-注解"><a href="#java知识点-注解" class="headerlink" title="java知识点-注解"></a>java知识点-注解</h1><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><pre><code>元注解
public @interface 注解名称&#123;
    属性列表;
&#125;
</code></pre>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote>
<p>注解本质上就是一个接口，该接口默认继承Annotation接口<br>public interface TestAnnotation extends java.lang.annotation.Annotation {}<br>可通过<br>编译：javac 类全路径<br>反编译：javap class文件<br>得到确认</p>
</blockquote>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>要求：
    1.属性返回值类型有一下要求
        * 基本数据类型
        * String
        * 枚举
        * 注解
        * 以上类型的数组
        例：
            import java.util.concurrent.TimeUnit;
            public @interface TestAnnotation &#123;
                int value();
                String value2();
                TimeUnit value3();
                Override value4();
                int[] value5();
                String[] value6();
                TimeUnit[] value7();
                Override[] value8();
            &#125;

    2.定义属性，在使用时需要给属性赋值(属性名 = 返回值)
        例：
            public @interface TestAnnotation&#123;
                int value();
            &#125;
            使用
            @TestAnnotation(value = 1)
            public class TestClass&#123;
            &#125;

        1.如果只有一个属性需要赋值，并且属性名称为value，则value可以省略，直接定义值即可
            @TestAnnotation(1)
            public class TestClass&#123;
            &#125;

        2.如果定义属性时，用default关键字给属性默认初始化值，在使用时可不赋值
        例：
            public @interface TestAnnotation&#123;
                int value() default 0;
            &#125;
            使用
            @TestAnnotation()
            public class TestClass&#123;
            &#125;
        3.数组赋值时，使用&#123;&#125;包裹，如果数组只有一个值，则可以省略
        例：
            public @interface TestAnnotation&#123;
                int[] value();
                String[] value2();
            &#125;
            使用
            @TestAnnotation(value = 1, value2=&#123;&quot;0&quot;, &quot;1&quot;&#125;)
            public class TestClass&#123;
            &#125;
        4.无属性可以直接使用
        例：
            public @interface TestAnnotation&#123;
            &#125;
            使用
            @TestAnnotation()
            public class TestClass&#123;
            &#125;
</code></pre>
<h3 id="元注解，有四种类型"><a href="#元注解，有四种类型" class="headerlink" title="元注解，有四种类型"></a>元注解，有四种类型</h3><pre><code>* @Target：描述注解能够作用的位置
    * ElementType取值：
        * TYPE：可以作用于类、接口、enum上
        * METHOD：可以作用于方法上
        * FIELD：可以作用于成员变量上
        * CONSTRUCTOR：构造器
        * LOCAL_VARIABLE：局部变量声明
        * PACKAGE：包声明
        * PARAMETER：参数声明

* @Repeatable：表示注解在同一位置可以出现多次   

* @Retention：描述注解被保留的阶段
    * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
    * @Retention(RetentionPolicy.CLASS)：当前被描述的注解，会保留到class字节码文件中，JVM无法读取到
    * @Retention(RetentionPolicy.SOURCE)：当前被描述的注解，仅存在源码中

* @Documented：描述注解是否被抽取到api文档中

* @Inherited：描述在父类描述注解子类能否被继承，仅针对类，接口上声明并不会生效
</code></pre>
<h3 id="提取注解"><a href="#提取注解" class="headerlink" title="提取注解"></a>提取注解</h3><pre><code>需要实现java.lang.reflect.AnnotatedElement接口才可提取

已知实现类
Class
Constructor
Field
Method
Package

获取方法
getAnnotation:返回指定类型的注解，不存在返回null
getAnnotations:返回存在的所有注解
isAnnotationPresent:判断是否包含指定类型的注解
getDeclaredAnnotations:返回直接存在于此元素上的所有注解
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>BitSet</title>
    <url>/2020/09/14/Java/%E9%9B%86%E5%90%88/BitSet-md/</url>
    <content><![CDATA[<h1 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h1><blockquote>
<p>Java平台上存放位序列的集合。<br>如果需要高效的存储位序列（例如：标志）就可以使用位集。<br>由于位集将位包装在字节里，所以使用位集比使用Boolean对象的ArrayList更加高效。</p>
</blockquote>
<h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>	 		<span class="comment">// 返回最高位为1的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bit)</span>	<span class="comment">// 获得一个位，返回true则为开</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bit)</span>		<span class="comment">// 设置一个位为开</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> bit)</span>		<span class="comment">// 设置一个位为关</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>			<span class="comment">// 将所有设置为关</span></span></span><br></pre></td></tr></table></figure>

<h5 id="计算素数个数"><a href="#计算素数个数" class="headerlink" title="计算素数个数"></a>计算素数个数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算2~2000000之间的所有素数</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">200_0000</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">BitSet bit = <span class="keyword">new</span> BitSet(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    bit.set(i);</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">while</span> (i * i &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bit.get(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        k = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= n) &#123;</span><br><span class="line">            bit.clear(k);</span><br><span class="line">            k += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bit.get(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;count: &quot;</span> + count); <span class="comment">// count: 148933</span></span><br><span class="line">System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><blockquote>
<p> 参考：<a href="https://blog.csdn.net/wildwolf_001/article/details/107186226">https://blog.csdn.net/wildwolf_001/article/details/107186226</a></p>
</blockquote>
<h5 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h5><ol>
<li><p>数据结构？</p>
<p>答：数组加链表法</p>
</li>
<li><p>怎么插入数据？</p>
<p>答：链表头插法，即：链表中最新的数据插在链表头</p>
</li>
<li><p>哈希冲突怎么预防？</p>
<p>答：二次哈希 or 扰动函数</p>
</li>
<li><p>怎么解决哈希冲突？</p>
<p>答：链表法，其它方案：再哈希、开放寻址、公共溢出区</p>
</li>
<li><p>默认容量多少？</p>
<p>答：16</p>
</li>
<li><p>扩容后存储位置的计算方式？</p>
<p>答：重新计算哈希和索引</p>
</li>
<li><p>内部数组是什么时候创建的？</p>
<p>答：第一次put的时候创建</p>
</li>
</ol>
<h5 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h5><ol>
<li><p>1.7 和 1.8 数据结构有什么不同？</p>
<p>答：引入红黑树</p>
</li>
<li><p>1.7 和 1.8 往链表上插数据的方式有什么不同？<br>答：从头插法改为尾部插入</p>
</li>
<li><p>扩容后存储位置的计算方式？</p>
<p>答：对老数组进行与运算，判断值是否等于0，等于0在低位，否则在高位</p>
</li>
<li><p>HashMap 什么时候会把链表转化为红黑树？</p>
<p>答：在链表大于等于8时会转换为红黑树，如果数组大小小于64会优先扩容</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全的集合</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h1><h5 id="常用集合描述"><a href="#常用集合描述" class="headerlink" title="常用集合描述"></a>常用集合描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ConcurrentHashMap</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentSkipListMap</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentSkipListSet</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentLinkedQueue</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CopyOnWriteArrayList</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CopyOnWriteArraySet</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>通用集合</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/%E9%80%9A%E7%94%A8%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="通用集合"><a href="#通用集合" class="headerlink" title="通用集合"></a>通用集合</h1><h5 id="常用集合描述"><a href="#常用集合描述" class="headerlink" title="常用集合描述"></a>常用集合描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ArrayList</td>
<td align="left">一种可以动态增长和缩减的索引序列</td>
</tr>
<tr>
<td align="left">LinkedList</td>
<td align="left">一种可以在任何位置进行高效地插人和删除操作的有序序列</td>
</tr>
<tr>
<td align="left">ArrayDeque</td>
<td align="left">一种用循环数组实现的双端队列</td>
</tr>
<tr>
<td align="left">HashSet</td>
<td align="left">一种没有重复元素的无序集合</td>
</tr>
<tr>
<td align="left">TreeSet</td>
<td align="left">一种有序集</td>
</tr>
<tr>
<td align="left">EnumSet</td>
<td align="left">一种包含枚举类型值的集</td>
</tr>
<tr>
<td align="left">LinkedHashSet</td>
<td align="left">一种可以记住元素插人次序的集</td>
</tr>
<tr>
<td align="left">PriorityQueue</td>
<td align="left">一种允许高效删除最小元素的集合</td>
</tr>
<tr>
<td align="left">HashMap</td>
<td align="left">一种存储键值关联的数据结构</td>
</tr>
<tr>
<td align="left">TreeMap</td>
<td align="left">一种键值有序排列的映射表</td>
</tr>
<tr>
<td align="left">EnumMap</td>
<td align="left">一种键值属于枚举类型的映射表</td>
</tr>
<tr>
<td align="left">LinkedHashMap</td>
<td align="left">一种存储键/ 值关联的数据结构—种键值有序排列的映射表</td>
</tr>
<tr>
<td align="left">WeakHashMap</td>
<td align="left">一种其值无用武之地后可以被垃圾回收器回收的映射表</td>
</tr>
<tr>
<td align="left">IdentityHashMap</td>
<td align="left">一种用==而不是用equals 比较键值的映射表</td>
</tr>
</tbody></table>
<h5 id="旧集合"><a href="#旧集合" class="headerlink" title="旧集合"></a>旧集合</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Vector</td>
<td align="left">与ArrayList相似，但所有方法都是同步的</td>
</tr>
<tr>
<td align="left">HashTable</td>
<td align="left">与HashMap相似，但所有方法都是同步的</td>
</tr>
<tr>
<td align="left">Properties</td>
<td align="left">属性映射</td>
</tr>
</tbody></table>
<h5 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collections.empty…</td>
<td align="left">生成一个不可添加数据的空集合实例</td>
</tr>
<tr>
<td align="left">Collections.singleton…</td>
<td align="left">生成一个不可修改的含单一数据的集合实例</td>
</tr>
<tr>
<td align="left">Collections.unmodifiable…</td>
<td align="left">生成一个包装集合的不可添加数据的包装集合实例</td>
</tr>
<tr>
<td align="left">Collections.synchronized…</td>
<td align="left">生成一个包装集合的同步操作包装集合实例</td>
</tr>
<tr>
<td align="left">Collections.checked…</td>
<td align="left">生成一个包装集合的受查操作的集合实例</td>
</tr>
</tbody></table>
<h5 id="LinkedHashMap实现LRU算法（最近最少使用算法）"><a href="#LinkedHashMap实现LRU算法（最近最少使用算法）" class="headerlink" title="LinkedHashMap实现LRU算法（最近最少使用算法）"></a>LinkedHashMap实现LRU算法（最近最少使用算法）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> capacity = <span class="number">4</span>;</span><br><span class="line">LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(capacity, <span class="number">0.75f</span>,<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;String, String&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; <span class="comment">// 当返回true则删除最少使用的的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="小知识："><a href="#小知识：" class="headerlink" title="小知识："></a>小知识：</h5><ol>
<li>“for each”循环可以与任何实现了<strong>Iterable接口</strong>的对象一起工作</li>
<li>集合<strong>迭代器Iterator</strong>的remove与next/previous具有依赖性，调用remove之前没有调用next是不合法的，必须先调用next越过将要删除的元素</li>
<li>Java 1.4针对集合引入了一个<strong>标记接口RandomAccess</strong>，用于标记该集合是否支持高效的随机访问，如：ArrayList(实现)和LinkedList(未实现)</li>
<li>Collection集合类内部维护了一个计数器modCount，负责跟踪列表的<strong>结构性修改</strong>，如添加元素、删除元素等。在新建迭代器的同时会缓存此时的计数器，在改写操作时判断缓存的计数器值与集合类的计数器值是否一致，不一致则抛出<strong>ConcurrentModificastionException</strong>异常。注意：集合的set方法不被<strong>视为结构性修改</strong>，这会造成多个迭代器遍历出的结果不一定一致</li>
<li>以<strong>链表</strong>为模型的集合，多次使用get获取某个位置的元素效率极低，可以使用<strong>列表迭代器ListIterator</strong>的nextIndex、next、previousIndex、previous等方法优化该操作，<strong>备注：</strong>ListIterator的add和set方法也是插入操作的一个优化点</li>
<li>原本**for(Map.Entry&lt;&gt; entry : map.entrySet())**的map遍历操作最高效，在Java 1.8后直接通过map.forEach方法直接操作node更加高效</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列</title>
    <url>/2020/11/08/Java/%E9%9B%86%E5%90%88/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h5 id="队列描述描述"><a href="#队列描述描述" class="headerlink" title="队列描述描述"></a>队列描述描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LinkedBlockingQueue</td>
<td align="left">一种容量没有上边界的阻塞队列，亦可指定最大容量</td>
</tr>
<tr>
<td align="left">LinkedBlockingDeque</td>
<td align="left">一种双端队列版本</td>
</tr>
<tr>
<td align="left">ArrayBlockingQueue</td>
<td align="left">一种在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性</td>
</tr>
<tr>
<td align="left">PriorityBlockingQueue</td>
<td align="left">一种带优先级的队列</td>
</tr>
<tr>
<td align="left">DelayQueue</td>
<td align="left">一种延迟阻塞队列【可实现如下单后三十分钟内没有付款就自动取消订单的操作】</td>
</tr>
<tr>
<td align="left">TransferQueue</td>
<td align="left">一种等待消费者准备就绪才可接收的阻塞队列，如果调用<code>transfer</code>那么会阻塞，直到另一个线程将其取出</td>
</tr>
</tbody></table>
<h5 id="阻塞队列通用方法"><a href="#阻塞队列通用方法" class="headerlink" title="阻塞队列通用方法"></a>阻塞队列通用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>动作</th>
<th>特殊情况</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>添加一个元素</td>
<td>如果队列满， 则抛出IllegalStateException 异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队列头元素</td>
<td>如果队列空，抛出NoSuchElementException 异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回true</td>
<td>如果队列满， 返回false</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列头元素</td>
<td>如果队列空， 则返回null</td>
</tr>
<tr>
<td>poll</td>
<td>移除并返回队列的头元素</td>
<td>如果队列空， 则返回null</td>
</tr>
<tr>
<td>put</td>
<td>添加一个元素</td>
<td>如果队列满， 则阻塞</td>
</tr>
<tr>
<td>remove</td>
<td>移出并返回头元素</td>
<td>如果队列空， 则抛出NoSuchElementException 异常</td>
</tr>
<tr>
<td>take</td>
<td>移出并返回头元素</td>
<td>如果队列空， 则阻塞</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>代理</title>
    <url>/2020/09/13/Docker/Docker%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><ol>
<li><p>官方文档</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker.com&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>Docker安装：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装前检查</span><br><span class="line">    1.内核版本</span><br><span class="line">        uname -a</span><br><span class="line">    2.检查Device Mapper</span><br><span class="line">        ls -l &#x2F;sys&#x2F;class&#x2F;misc&#x2F;device-mapper</span><br><span class="line">Ubuntu中安装Docker的方式</span><br><span class="line">    1.安装Ubuntu维护的版本(版本相对官方有可能会低点)</span><br><span class="line">            安装：		sudo apt-get install docker.io</span><br><span class="line">        更新配置：	source &#x2F;etc&#x2F;bash_completion.d&#x2F;docker.io</span><br><span class="line">    2.安装Docker维护的版本(推荐)</span><br><span class="line">        wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</span><br><span class="line">        输入当前用户的密码后，就会下载脚本并且安装Docker及依赖包。</span><br><span class="line">        安装完成后有个提示:</span><br><span class="line">        If you would like to use Docker as a non-root user, you should now consider</span><br><span class="line">        adding your user to the &quot;docker&quot; group with something like:</span><br><span class="line">        sudo usermod -aG docker runoob</span><br><span class="line">        Remember that you will have to log out and back in for this to take effect!</span><br><span class="line"></span><br><span class="line">        意思是:当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker [user] 命令，然后重新登陆，否则会有如下报错</span><br><span class="line"></span><br><span class="line">可以通过直接输入docker命令查看Docker客户端的所有命令选项</span><br><span class="line">可以通过命令 docker command --help 更深入的了解指定的 Docker 命令使用方法。</span><br><span class="line">例如我们要查看 docker stats 指令的具体使用方法：</span><br><span class="line">docker stats --help</span><br><span class="line">    3.测试</span><br><span class="line">        sudo docker run hello-world</span><br><span class="line">    4.非root用户运行docker</span><br><span class="line">        创建一个用户组：			sudo groupadd docker</span><br><span class="line">        将当前用户添加到用户组：	sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class="line">        注销并重新启动docker服务：	sudo service docker restart</span><br></pre></td></tr></table></figure></li>
<li><p>镜像的基本操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 查看版本</span><br><span class="line">    docker version</span><br><span class="line"></span><br><span class="line">2. 查看docker信息</span><br><span class="line">    docker info</span><br><span class="line"></span><br><span class="line">3. 列出镜像</span><br><span class="line">    docker images [OPTSIONS] [REPOSITORY]</span><br><span class="line">    -a --all&#x3D;false      显示所有镜像，包括中间层镜像</span><br><span class="line">    -f --filter&#x3D;[]      显示时的过滤条件</span><br><span class="line">    --no-trunc&#x3D;false    不截断镜像的唯一id</span><br><span class="line">    -q --quiet&#x3D;false    只显示镜像的唯一id</span><br><span class="line"></span><br><span class="line">4. 查看镜像</span><br><span class="line">    docker inspect [OPTSIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class="line"></span><br><span class="line">5. 删除镜像</span><br><span class="line">    docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">    -f --force&#x3D;false    强制删除镜像</span><br><span class="line">    --no-prune&#x3D;false    保留未打标签的父镜像</span><br><span class="line"></span><br><span class="line">6. 查找镜像</span><br><span class="line">    方式一:Docker Hub</span><br><span class="line">        https:&#x2F;&#x2F;registry.hub.docker.com</span><br><span class="line"></span><br><span class="line">    方式二:</span><br><span class="line">    docker search [OPTIONS]</span><br><span class="line">    --automated&#x3D;false   只显示自动化构建的镜像</span><br><span class="line">    --no-trunc&#x3D;false    不截断显示</span><br><span class="line">    -s --stars&#x3D;0        过滤分数需要高于设置的镜像</span><br><span class="line"></span><br><span class="line">7. 拉取镜像</span><br><span class="line">    docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line">    -a --all-tags&#x3D;false 匹配名字的镜像全部下载到本地</span><br><span class="line"></span><br><span class="line">    修改镜像获取地址</span><br><span class="line">        使用--registry-mirror选项</span><br><span class="line">        1.修改：&#x2F;etc&#x2F;default&#x2F;docker</span><br><span class="line">        2.添加：DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;http:&#x2F;&#x2F;MIRROR-ADDR&quot;</span><br><span class="line">    https:&#x2F;&#x2F;www.daocloud.io</span><br><span class="line"></span><br><span class="line">8. 推送镜像</span><br><span class="line">    docker push NAME[:TAG]</span><br><span class="line"></span><br><span class="line">9. 查看镜像构建过程</span><br><span class="line">    docker history IMAGE</span><br><span class="line"></span><br><span class="line">10. 构建镜像</span><br><span class="line">    使用commit构建镜像</span><br><span class="line">        docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">        -a --author&#x3D;&quot;&quot;      指定作者</span><br><span class="line">        -m --message&#x3D;&quot;&quot;     指定信息</span><br><span class="line">        -p --pause&#x3D;true     不暂停容器并提交</span><br><span class="line"></span><br><span class="line">    使用Dockerfile构建镜像</span><br><span class="line">        1. 创建Dockerfile文件</span><br><span class="line">              #First Dockerfile</span><br><span class="line">              FROM ubuntu:14.04             # 源仓库</span><br><span class="line">              MAINTAINER 维护人 &quot;维护人邮箱&quot;</span><br><span class="line">              RUN command1                  # 执行的命令</span><br><span class="line">              RUN command2                  # 执行的命令</span><br><span class="line">              RUN command3                  # 执行的命令</span><br><span class="line">              ...</span><br><span class="line">              EXPOSE 80                     # 暴露的端口</span><br><span class="line">              CMD command4</span><br><span class="line">        2. 使用docker build 命令</span><br><span class="line">            docker build [OPTIONS] PATH|URL|-</span><br><span class="line">            --force-rm&#x3D;false</span><br><span class="line">            --no-cache&#x3D;false    不启用构建缓存</span><br><span class="line">            --pull&#x3D;false</span><br><span class="line">            -q --quiet&#x3D;false    静默操作，不打印日志</span><br><span class="line">            --rm&#x3D;true</span><br><span class="line">            -t --tag&#x3D;&quot;&quot;         指定仓库名字</span><br><span class="line">        3. Dockerfile指令</span><br><span class="line">            1. 注释</span><br><span class="line">                以#开头，单行注释</span><br><span class="line"></span><br><span class="line">            2. 指令</span><br><span class="line">                以大写的指令名开始，后面接着指令参数</span><br><span class="line"></span><br><span class="line">            3. FROM指令：指定基础镜像</span><br><span class="line">                格式：</span><br><span class="line">                    FROM &lt;image&gt;</span><br><span class="line">                    FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">                要求：</span><br><span class="line">                    已经存在的镜像</span><br><span class="line">                    必须是第一条非注释指令</span><br><span class="line"></span><br><span class="line">            4. MAINTAINER指令：指定镜像作者信息，包含镜像所有者和联系信息，相当于commit命令的-a属性</span><br><span class="line">                格式：</span><br><span class="line">                    MAINTAINER &lt;name&gt;</span><br><span class="line"></span><br><span class="line">            5. RUN指令：指定当前镜像中运行的命令,每条RUN指令都会基于上一条RUN指令的新镜像上添加</span><br><span class="line">                格式：</span><br><span class="line">                    RUN &lt;command&gt; (shell模式)</span><br><span class="line">                        例：&#x2F;bin&#x2F;sh -c command 相对于执行了该命令</span><br><span class="line">                            RUN echo hello</span><br><span class="line">                    RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                        例：RUN [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</span><br><span class="line"></span><br><span class="line">            6. EXPOSE指令：指定运行该镜像的容器使用的端口</span><br><span class="line">                格式：</span><br><span class="line">                    EXPOSE &lt;port&gt; [&lt;port&gt;...]   可以指定一个或多个端口，也可使用多个EXPOSE命令</span><br><span class="line">                注意：</span><br><span class="line">                    虽然在构建镜像指定了端口，在容器运行时也需要通过run -p参数指定所使用的端口</span><br><span class="line"></span><br><span class="line">            7. CMD指令：提供容器运行时默认命令，于RUN指令相似，但是RUN指令是在镜像构建过程中执行的，CMD指令是在容器运行时运行的</span><br><span class="line">                格式：</span><br><span class="line">                    CMD &lt;command&gt; (shell模式)</span><br><span class="line">                    CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                    CMD [&quot;param1&quot;,&quot;param2&quot;] (作为ENTRYPOINT指令的默认参数)</span><br><span class="line">                注意：</span><br><span class="line">                    如果docker run指定了运行时的命令，那么CMD命令会被覆盖，也就是说CMD命令指定的时默认命令</span><br><span class="line"></span><br><span class="line">            8. ENTRYPOINT指令：与CMD指令相似，区别在于命令不会被覆盖，run指定的命令并不会执行</span><br><span class="line">                格式：</span><br><span class="line">                    ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                    ENTRYPOINT &lt;command&gt; (shell模式)</span><br><span class="line">                注意：</span><br><span class="line">                    如果需要覆盖，可以使用docker run --entrypoint覆盖</span><br><span class="line">                高级用法：</span><br><span class="line">                    用ENTRYPOINT来指定命令，用CMD来指定命令默认参数</span><br><span class="line">                    ENTRYPOINT [&quot;&#x2F;vsr&#x2F;bin&#x2F;nginx&quot;]</span><br><span class="line">                    CMD [&quot;-h&quot;]</span><br><span class="line"></span><br><span class="line">            9. ADD指令和COPY指令：将本地文件或目录复制到镜像中</span><br><span class="line">                格式：</span><br><span class="line">                    ADD &lt;src&gt;...&lt;dest&gt;</span><br><span class="line">                    ADD [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;](适用于文件路径中有空格的情况)</span><br><span class="line">                    COPY &lt;src&gt;...&lt;dest&gt;</span><br><span class="line">                    COPY [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;](适用于文件路径中有空格的情况)</span><br><span class="line">                    src：可以是本地地址(必须是构建目录中的相对地址)和远程URL(不推荐)</span><br><span class="line">                    dest:镜像中的绝对路径</span><br><span class="line">                区别：</span><br><span class="line">                    ADD vs COPY</span><br><span class="line">                        ADD 包含类似tar的解压功能</span><br><span class="line">                        如果单纯复制文件，Docker推荐使用COPY</span><br><span class="line"></span><br><span class="line">            10. VOLUME指令：向镜像容器添加卷，生成成数据卷容器</span><br><span class="line">                格式：</span><br><span class="line">                    VOLUME [&quot;&#x2F;data&quot;]</span><br><span class="line">                注意：</span><br><span class="line">                    该操作不能指定主机目录，由容器运行时动态生成主机挂载的目录</span><br><span class="line"></span><br><span class="line">            11. WORKDIR指令：在容器内部指定工作目录</span><br><span class="line">                格式：</span><br><span class="line">                    WORKDIR &#x2F;path&#x2F;to&#x2F;workdir    CMD和ENTRYPOINT都会在这个目录下执行</span><br><span class="line"></span><br><span class="line">            12. ENV指令：设置容器环境变量</span><br><span class="line">                格式：</span><br><span class="line">                    ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">                    ENV &lt;key&gt;&#x3D;&lt;value&gt;...</span><br><span class="line"></span><br><span class="line">            13. USER指令：指定镜像会以什么样的用户去运行</span><br><span class="line">                格式：</span><br><span class="line">                    USER daemon     可以使用uid：gid：group</span><br><span class="line">                    USER user       USER uid</span><br><span class="line">                    USER user:group USER uid:gid</span><br><span class="line">                    USER user:gid   USER uid:group</span><br><span class="line"></span><br><span class="line">            14. ONBUILD [INSTRUCTION]：为镜像添加触发器，当一个镜像被其他镜像作为基础镜像时执行，会在构建过程中插入指令</span><br><span class="line">                格式：</span><br><span class="line">                    ONBUILD [INSTRUCTION]</span><br><span class="line">                    例：</span><br><span class="line">                        ONBUILD COPY &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>镜像的导入导出</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 镜像导出</span><br><span class="line">    docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">    -o --output string 输出到文件</span><br><span class="line">    例:</span><br><span class="line">        docker save -o nginx.tar nginx:latest</span><br><span class="line">        或</span><br><span class="line">        docker save &gt; nginx.tar nginx:latest</span><br><span class="line">        其中-o和&gt;表示输出到文件，nginx.tar为目标文件，nginx:latest是源镜像名(name:tag)</span><br><span class="line"></span><br><span class="line">2. 镜像导入</span><br><span class="line">    docker load [OPTIONS]</span><br><span class="line">    -i --input 从文件输入</span><br><span class="line">    例：</span><br><span class="line">        docker load -i nginx.tar</span><br><span class="line">        或</span><br><span class="line">        docker load &lt; nginx.tar</span><br><span class="line">        其中-i和&lt;表示从文件输入。会成功导入镜像及相关元数据，包括tag信息</span><br><span class="line"></span><br><span class="line">3. 容器导出</span><br><span class="line">    docker export [options] container</span><br><span class="line">    -o --output string 输出到文件</span><br><span class="line">    例：</span><br><span class="line">        docker export -o nginx-test.tar nginx-test</span><br><span class="line">        其中-o表示输出到文件，nginx-test.tar为目标文件，nginx-test是源容器名(name)</span><br><span class="line"></span><br><span class="line">4. 容器导入</span><br><span class="line">    docker import [options] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line">    例：</span><br><span class="line">        docker import nginx-test.tar nginx:imp</span><br><span class="line">        或</span><br><span class="line">        cat nginx-test.tar | docker import - nginx:imp</span><br><span class="line"></span><br><span class="line">5. 说明与需要注意的地方</span><br><span class="line">    1. export命令导出的tar文件略小于save命令导出的</span><br><span class="line">    2. export命令是从容器（container）中导出tar文件，而save命令则是从镜像（images）中导出</span><br><span class="line">    3. 基于第二点，export导出的文件再import回去时，无法保留镜像所有历史（即每一层layer信息，不熟悉的可以去看Dockerfil），不能进行回滚操作；而save是依据镜像来的，所以导入时可以完整保留下每一层layer信息。如下图所示，nginx:latest是save导出load导入的，nginx:imp是export导出import导入的</span><br><span class="line"></span><br><span class="line">6. 建议</span><br><span class="line">    若是只想备份images，使用save、load即可</span><br><span class="line">    若是在启动容器后，容器内容有变化，需要备份，则使用export、import</span><br></pre></td></tr></table></figure></li>
<li><p>容器的基本操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 启动容器</span><br><span class="line">    docker run IMAGE [COMMAND] [ARG...]</span><br><span class="line">    run 在新容器中执行命令</span><br><span class="line"></span><br><span class="line">2. 启动交互式容器</span><br><span class="line">    docker run [--name 自定义名字] -i -t IMAGE &#x2F;bin&#x2F;bash</span><br><span class="line">    -i --interactive&#x3D;true | false 默认是false   告诉docker父进程始终打开标准输入</span><br><span class="line">    -t --tty&#x3D;true | false 默认是false           告诉docker父容器提供一个tty终端</span><br><span class="line"></span><br><span class="line">    将交互式容器派遣为守护石形式运行的容器</span><br><span class="line">    Ctrl+P Ctrl+Q</span><br><span class="line"></span><br><span class="line">3. 附加到运行中的容器</span><br><span class="line">    docker attach [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">4. 直接启动守护式容器</span><br><span class="line">    docker run -d IMAGE [COMMAND] [ARG...]</span><br><span class="line">    -d --detach     派遣为守护式容器启动</span><br><span class="line"></span><br><span class="line">5. 查看容器日志</span><br><span class="line">    docker logs [-f] [-t] [--tail SIZE] [CONTAINER ID或NAME]</span><br><span class="line">    -f --follows&#x3D;true | false 默认式false       一直跟踪日志变化并打印出来</span><br><span class="line">    -t --timestamps&#x3D;true | false 默认式false    在日志列加上时间戳</span><br><span class="line">    --tail&#x3D;数量                                返回结尾处多少数量的日志，0则默认最新</span><br><span class="line"></span><br><span class="line">6. 查看容器内进程</span><br><span class="line">    docker top [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">7. 在运行中的容器内启动新进程</span><br><span class="line">    docker exec [-d] [-i] [-t] [CONTAINER ID或NAME] [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">8. 查看创建了那些容器</span><br><span class="line">    docker ps [-a] [-l]</span><br><span class="line">    -a 显示所有容器，包括已经停止的</span><br><span class="line">    -l 显示 最新的容器</span><br><span class="line">    -q 只显示容器id</span><br><span class="line"></span><br><span class="line">    查看容器信息</span><br><span class="line">    docker inspect [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">    高级用法：</span><br><span class="line">        停止所有容器：docker stop $(docker ps -a -q)</span><br><span class="line">        移除所有容器：docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line">9. 重新启动已经停止的容器</span><br><span class="line">    docker start -i [CONTAINER ID或  NAME]</span><br><span class="line"></span><br><span class="line">10. 停止正在运行的容器</span><br><span class="line">    docker stop [CONTAINER ID或NAMES]</span><br><span class="line">    docker kill [CONTAINER ID或NAMES]   强制停止容器</span><br><span class="line"></span><br><span class="line">11. 删除不需要的容器,删除容器时，容器必须是停止状态,否则会报异常</span><br><span class="line">    docker rm [-v] [CONTAINER ID或NAME]</span><br><span class="line">    -v 删除挂载的数据卷</span><br><span class="line">12. 查看端口映射</span><br><span class="line">    docker port [CONTAINER ID或NAMES]</span><br><span class="line"></span><br><span class="line">13. 设置容器端口映射</span><br><span class="line">    run [-P] [-p]</span><br><span class="line">    -P --publish-all&#x3D;true | false 默认式false</span><br><span class="line">        docker run -P -i -t ubuntu &#x2F;bin&#x2F;bash    将容器内部使用的端口映射到主机上</span><br><span class="line">    -p --publish&#x3D;[]</span><br><span class="line">        containerPort</span><br><span class="line">            docker run -p 80 -i -t ubuntu &#x2F;bin&#x2F;bash                 将容器80端口随机映射到主机上</span><br><span class="line">        hostPort:containerPort</span><br><span class="line">            docker run -p 8080:80 -i -t ubuntu &#x2F;bin&#x2F;bash            将容器80端口映射到主机8080端口上</span><br><span class="line">        ip::containerPort</span><br><span class="line">            docker run -p 0.0.0.0:80 -i -t ubuntu &#x2F;bin&#x2F;bash         将容器80端口映射到主机0.0.0.0上</span><br><span class="line">        ip:hostPort:containerPort</span><br><span class="line">            docker run -p 0.0.0.0:8080:80 -i -t ubuntu &#x2F;bin&#x2F;bash    将容器80端口映射到主机0.0.0.0:8080上</span><br><span class="line"></span><br><span class="line">14. 设置容器的数据卷</span><br><span class="line">    run [-v]</span><br><span class="line">    -v --volume 设置容器数据卷[主机目录:容器目录(绝对路径)]，如果主机目录不存在会自动新建</span><br><span class="line">    设置卷只读权限</span><br><span class="line">        docker run -v 主机目录:容器目录:ro IMAGE [COMMAND] [ARG...]</span><br><span class="line">    设置读写权限</span><br><span class="line">        docker run -v 主机目录:容器目录:rw IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的C/S模式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Remote API调用</span><br><span class="line">    https:&#x2F;&#x2F;docs.docker.com&#x2F;develop&#x2F;sdk&#x2F;examples&#x2F;</span><br><span class="line"></span><br><span class="line">2. 连接模式</span><br><span class="line">    模式一: unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">        例：</span><br><span class="line">            本地sock地址 &#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">            curl --unix-socket &#x2F;var&#x2F;run&#x2F;docker.sock http:&#x2F;v1.24&#x2F;images&#x2F;json</span><br><span class="line">    模式二: tcp:&#x2F;&#x2F;host:port 端口port通常为2375</span><br><span class="line">    模式三: fd:&#x2F;&#x2F;socketfd</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的远程访问</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 要求Docker server和Dokcer client版本一致</span><br><span class="line"></span><br><span class="line">2. 修改Docker守护进程启动选项</span><br><span class="line">    -H  tcp:&#x2F;&#x2F;host:port</span><br><span class="line">        unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket</span><br><span class="line">        fd:&#x2F;&#x2F;* or fd:&#x2F;&#x2F;socketfd</span><br><span class="line">    -H指定Docker的通讯方式</span><br><span class="line">    守护进程默认配置</span><br><span class="line">    -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line"></span><br><span class="line">3. 远程连接</span><br><span class="line">    假设服务器A地址为：10.211.55.5</span><br><span class="line">    服务器A Docker启动配置：-H tcp:&#x2F;&#x2F;0.0.0.0:2375</span><br><span class="line"></span><br><span class="line">    服务器B请求远程api：curl 10.211.55.5:2375 http:&#x2F;v1.24&#x2F;images&#x2F;json</span><br><span class="line"></span><br><span class="line">4. 使用本地Docker client操作远程Docker server</span><br><span class="line">    服务器B</span><br><span class="line">    方式一：</span><br><span class="line">        本地Docker启动选项：-H tcp:&#x2F;&#x2F;10.211.55.5:2375   ip地址为远程服务器地址</span><br><span class="line">    方式二：</span><br><span class="line">        使用Docker环境变量配置调用远程Docker server： export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;10.211.55.5:2375&quot;</span><br><span class="line">    配置完成后就可以像使用本机Docker一样使用远程服务</span><br><span class="line"></span><br><span class="line">5. docker配置远程服务后本地服务不能正常调用</span><br><span class="line">    即服务器A设置为远程服务后，相关的docker命令无法调用，如：docker info 会返回异常</span><br><span class="line">    如果想要开发远程服务同时运行本地服务，可同时调用多次-H配置</span><br><span class="line">    服务器A Docker启动配置：-H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>数据卷容器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建数据卷容器</span><br><span class="line">    方式一：docker run -v path IMAGE [COMMAND] [ARG...]</span><br><span class="line">    方式二：构建容器包含VOLUME指令，即容器本身自带数据卷</span><br><span class="line">    例：</span><br><span class="line">       docker run -it -v &#x2F;dbdata --name dbdata ubuntu</span><br><span class="line"></span><br><span class="line">2. 其它容器通过使用--volumes-from来挂载dbdata容器中的数据卷</span><br><span class="line">    docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">    docker run -it --volumes-from dbdata --name db2 ubuntu</span><br><span class="line">    说明：</span><br><span class="line">        此时，容器db1和db2都挂载同一个数据卷到相同的&#x2F;dbdata目录。三个容器任何一方在该目录下的写入，其他容器都可以看到。</span><br><span class="line">        可以多次使用--volumes-from参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷，即多重挂载。</span><br><span class="line">        使用--volumes-from参数所挂载数据卷的容器自身并不需要保持在运行状态。</span><br><span class="line">    注意：        </span><br><span class="line">        如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器。</span><br><span class="line"></span><br><span class="line">3. 数据卷的备份和还原</span><br><span class="line">    备份：</span><br><span class="line">        docker run --volumes-from [container name需要备份的数据卷容器名称] -v $(pwd):&#x2F;backup --name backup ubuntu tar cvf &#x2F;backup&#x2F;backup.tar [container data valume数据卷容器需要备份的数据卷目录]</span><br><span class="line">    说明：</span><br><span class="line">        首先利用ubuntu镜像创建了一个容器backup。使用--volumes-from参数来让backup容器挂载需要备份的数据卷，使用-v  $(pwd):&#x2F;backup参数来挂载本地的当前目录到backup容器的&#x2F;backup目录。backup容器启动后，使用了tar命令压缩需要备份的数据，并存放在&#x2F;backup&#x2F;backup.tar上(实际就是主机的$(pwd)目录);</span><br><span class="line"></span><br><span class="line">    还原：</span><br><span class="line">        docker run --volumes-from [container name] -v $(pwd):&#x2F;backup --name restore ubuntu tar xvf &#x2F;backup&#x2F;backup.tar [container data volume]</span><br><span class="line">    说明：</span><br><span class="line">        跟备份原理相同</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的启动配置选项</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 启动选项</span><br><span class="line">    参考文档：https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;cli&#x2F;</span><br><span class="line">    docker -d [OPTOINS]</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="10">
<li><p>容器的网络连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>容器跨主机的网络连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>代理</title>
    <url>/2020/11/10/Java/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/</url>
    <content><![CDATA[<h1 id="线程通用"><a href="#线程通用" class="headerlink" title="线程通用"></a>线程通用</h1><h5 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h5><blockquote>
<p>早期版本中线程提供stop方法来终止线程，但该方法已经被弃用</p>
<p>取而代之的是外部通知该线程应该结束了，但是具体什么时候结束交由线程自己控制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束线程</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 外部通知线程中断</span></span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>

<p>注意一：如果在<code>Thread.sleep()</code>等会抛出<code>InterruptedException</code>受查异常等内置函数后面调用<code>Thread.currentThread().isInterrupted()</code>返回false</p>
<p>注意二：<code>Thread.interrupted()</code>线程静态函数会将中断状态清空，与<code>Thread.currentThread().isInterrupted(true)</code>效果一致</p>
<h5 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock mLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 可重入锁对象</span></span><br><span class="line">Condition mCondition = mLock.newCondition(); <span class="comment">// 锁对象创建条件对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLokc.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">//未达到条件) &#123;</span></span><br><span class="line">            mCondition.await(); <span class="comment">// 临时释放锁并进入阻塞状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do somethind</span></span><br><span class="line">        mCondition.signalAll(); <span class="comment">//通知释放阻塞状态的地方允许重新获得锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一：ReentrantLock 可多次调用lock()函数，但必须与unlock()函数成对出现</p>
<p>注意二：条件对象await必须是已经获得锁后调用，不然会爆出IllegalMonitorStateException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">//未达到条件) &#123;</span></span><br><span class="line">            wait(); <span class="comment">// 临时释放锁并进入阻塞状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do somethind</span></span><br><span class="line">        notifyAll(); <span class="comment">// 通知释放阻塞状态的地方允许重新获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方式与锁对象方式一模一样</p>
<p>值得注意的是，条件对象调用的是**await()<strong>方法，同步方法调用的是</strong>wait()**方法，别用错了</p>
<h5 id="volatile域"><a href="#volatile域" class="headerlink" title="volatile域"></a>volatile域</h5><p>作用：内存可见性、禁止指令重排序</p>
<p>JVM要求实现volatile必须要实现内存屏障，最终调用汇编指令为：<code>lock addl</code>，由于<code>lock</code>指令后面必须跟一条指令，但是Intel限制了<code>lock</code>指令不能跟<code>nop(空指令)</code>，所以后面添加了一个<code>addl(加0指令)</code></p>
<blockquote>
<p>LOCK 用于多处理器中执行指令时对共享内存的独占使用</p>
<p>他的作用时能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器缓存失效</p>
<p><strong>另外还提供了有序的指令无法越过内存屏障的作用，即lock指令前面的指令都无法越过这条指令</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (os::<span class="built_in">is_mp</span>()) &#123;<span class="comment">// 是否是多核cpu，可见volatile在单核cpu里并没有使用lock指令</span></span><br><span class="line">	<span class="comment">// 使用lock指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存屏障（JVM层面）</strong></p>
<p>写：<code>StoreStore</code> - <code>volatile写</code> - <code>StoreLoad</code></p>
<p>读：<code>volatile读</code> - <code>LoadStore</code> - <code>LoadLoad</code></p>
<h5 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h5><p>除了使用锁或<code>volatitle</code>修饰符，还有一种情况可以安全地访问一个共享域，即将该域声明为final：</p>
<p><code>final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</code></p>
<p>其它线程会在构造函数完成构造后才看到这个map变量</p>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>Unsafe内部最终调用汇编语句：多核：<code>lock cmpxchg</code> 单核：<code>cmpxchg</code></p>
<p><code>cmpxchg</code>：比较并交换操作数</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><blockquote>
<p><code>java.util.concurrent.atomic</code>包中有很多类使用高效的机器级指令来保证操作的原子性。</p>
<p>如：<code>AtomicInteger</code>的<code>getAndIncrement</code>和<code>incrementAndGet</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger integer = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">integer.set(Math.max(integer.get(), number));<span class="comment">//该操作不具有原子性，无法保证值的正常更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    oldValue = integer.get();</span><br><span class="line">    newValue = Math.max(oldValue, number)</span><br><span class="line">&#125; <span class="keyword">while</span>(!integer.compareAndSet(oldValue, newValue)); <span class="comment">// 需要通过比对再设值的方式保证原子性，CAS</span></span><br><span class="line"><span class="comment">// java8 可以通过内置函数免写以上循环操作，如updateAndGet、accumulateAndGet等函数</span></span><br></pre></td></tr></table></figure>

<p>注意一：如果大量线程要访问相同的类名开头为Atomic的原子值，性能会大幅下降，因为采用CAS乐观更新需要太多的循环重试操作。可通过类<code>LongAddr</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>和<code>DoubleAccumulator</code>来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原理：采用多个变量（加数），其总和为当前值。可以有多个线程同时更新不同的加数，线程增加会自动提供新的加数。</span></span><br><span class="line"><span class="comment">// 只有当所有工作都完成之后才需要总和的值，这个情况下该类操作会相当高效</span></span><br><span class="line">LongAdder adder</span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    adder.increment();<span class="comment">// 不会返回值，这样做回消除求和分解到多个加数所带来的性能提升</span></span><br><span class="line">	<span class="comment">// long total = adder.sum();// 不推荐这么操作，会失去性能的提升，如必须该操作，则使用Atomic会更好</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> total = adder.sum();</span><br></pre></td></tr></table></figure>

<p>注意二：上述提到CAS操作更新会存在ABA的异常，可通过<code>AtomicStampedReference</code>带版本号的原子类进行修复</p>
<p>让自己的类具有原子性：<code>AtomicReference</code>和<code>AtomicReferenceFieldUpdater</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicReference</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用AtomicReference对字符串进行封装</span></span><br><span class="line">    AtomicReference&lt;String&gt; atomicValue = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;HelloAtomic&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAtomicClass holder = <span class="keyword">new</span> MyAtomicClass();</span><br><span class="line">    holder.atomicValue.compareAndSet(<span class="string">&quot;HelloAtomic&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">	System.out.println(holder.atomicValue.get());</span><br><span class="line">	String value = holder.atomicValue.updateAndGet(<span class="keyword">new</span> UnaryOperator&lt;String&gt;() &#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;);</span><br><span class="line">  	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicReferenceFieldUpdater</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为value字段添加原子操作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;SimpleValueHolder, String&gt; valueUpdater</span><br><span class="line">        =  AtomicReferenceFieldUpdater.newUpdater(SimpleValueHolder.class, String.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用volatile声明</span></span><br><span class="line">	<span class="keyword">volatile</span> String value = <span class="string">&quot;HelloAtomic&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAtomicClass holder = <span class="keyword">new</span> MyAtomicClass();</span><br><span class="line">    holder.valueUpdater.compareAndSet(holder, <span class="string">&quot;HelloAtomic&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    System.out.println(holder.valueUpdater.get(holder));</span><br><span class="line">    String value = holder.valueUpdater.updateAndGet(holder, <span class="keyword">new</span> UnaryOperator&lt;String&gt;() &#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;);</span><br><span class="line">  	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AtomicReference</strong>与<strong>AtomicReferenceFieldUpdater</strong>的区别：</p>
<blockquote>
<p>两者的作用差不多，<code>AtomicReference</code>对字段进行包裹，<code>AtomicReferenceFieldUpdater</code>则为静态扩展字段功能</p>
<p><code>AtomicReference</code>和<code>AtomicReferenceFIeldUpdater</code>比起来，要多创建一个对象<br>对于 32 位的机器，这个对象的头占 12 个字节，它的成员占 4 个字节，也就是多出来 16 个字节<br>对于 64 位的机器，如果启动了指针压缩，那这个对象占用的也是 16 个字节<br>对于 64 位的机器，如果没启动指针压缩，那么这个对象就会占 24 个字节，其中对象头占 16 个字节，成员占 8 个字节</p>
<p>当要使用<code>AtomicReference</code>创建成千上万个对象时，这个开销就会变得很大</p>
<p>因为开销的原因，一般在实例较少的情况下如单例才会选择<code>AtomicReference</code>，不然推荐使用<code>AtomicReferenceFieldUpdater</code></p>
</blockquote>
<h5 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h5><p>线程间共享变量存在不同步异常问题，有些情况并不推荐使用共享变量，如：<code>SimpleDateFormat</code>类不是线程安全的。</p>
<p>假设有静态变量：</p>
<p><code>public static final SimpleDateFormat dateFormat = new SimpleDateForniat(&quot;yyyy-MM-dd&quot;)；</code></p>
<p>如果有两个线程同时执行以下操作</p>
<p><code>String dateStamp = dateFormat.format(new DateO);</code></p>
<p>结果可能会混乱，因为<code>dateFormat</code>内部数据可能会被并发的访问所破会。当然可以在该函数使用同步锁，但开销会很大，或者再使用时构造一个局部<code>SimpleDateForniat</code>对象，不过会有点浪费。</p>
<p>推荐为每个线程构造实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; initial = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>));<span class="comment">// 在使用时才会初始化SimpleDateFormat</span></span><br><span class="line">SimpleDateFormat simpleDateFormat = initial.get();</span><br></pre></td></tr></table></figure>

<p>在多个线程中生成随机数也存在类似的问题。Random类是线程安全的，但是如果多个线程需要等待一个共享的随机数生成器会很低效。</p>
<p>可以通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalRandom.current().nextInt()</span><br></pre></td></tr></table></figure>

<p>来解决此问题</p>
<h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><p>如果得不到锁可以执行其它逻辑，可以通过<strong>tryLock</strong>的方式获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mlock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可为<strong>tryLock</strong>添加超时逻辑,<code>mlock.tryLock(100,TimeUnit.MILLISECONDS)</code></p>
<p><code>lockInterruptibly</code>相当于无限时长的<code>tryLock</code></p>
<p>同样锁条件也可在等待时添加超时，<code>condition.await(100,TimeUnit.MILLISECONDS)</code></p>
<p><code>awaitUninterruptibly</code>相当于无限时长的<code>await</code>，但是不会抛出异常</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>在频繁读取少变更的情况下，可以使用读写锁来提高性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> data)</span> </span>&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><ol>
<li><p>通过<code>Executors</code>生成线程池</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程，空闲线程会被保留60 秒</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>该池包含固定数量的线程，空闲线程会一直被保留</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>只有一个线程的“ 池”， 该线程顺序执行每一个提交的任务</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>用于预定执行而构建的固定线程池</td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td>用于预定执行而构建的单线程“ 池”</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li><p>相关<code>Scheduled</code>线程池的用法:<br> <code>schedule</code>：预定在指定的时间之后执行任务<br> <code>scheduleAtFixedRate</code>：预定在初始的延迟结束后， 周期性地运行给定的任务， 周期长度是period<br> <code>scheduleWithFixedDelay</code>：预定在初始的延迟结束后周期性地运行给定的任务， 在一次调用完成和下一次调用开<br> 始之间有长度为delay 的延迟</p>
</li>
<li><p>控制任务组</p>
<p>  并行处理任务</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ....;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; futures = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span>(Future&lt;T&gt; result:results) &#123;</span><br><span class="line">	result.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以上方法有个缺点，必要要所有任务执行完毕了，<code>get</code>才会开始真正执行</p>
<p>  可通过<code>ExecutorCompletionService</code>类解决,使先完成的先返回</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorCompletionService&lt;T&gt; service = <span class="keyword">new</span> ExecutorCompletionService(executor);</span><br><span class="line"><span class="keyword">for</span> (Callable&lt;T&gt; task : tasks)</span><br><span class="line">    service,submit(task);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.sizeO；i ++)</span><br><span class="line">	processFurther(service.take().get())；</span><br></pre></td></tr></table></figure></li>
<li><p>Fork-Join框架</p>
<p>  在未满足最小计算单位时拆分成更多小的任务进行并行操作，以提高效率</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Task&lt;T&gt; extends RecursiveTask&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> to;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (from + to)/<span class="number">2</span>;</span><br><span class="line">            Task first = <span class="keyword">new</span> Task(from, mid);</span><br><span class="line">            Task second = <span class="keyword">new</span> Task(mid,to);</span><br><span class="line">            invokeAll(first, second);</span><br><span class="line">            <span class="keyword">return</span> first.join() + second.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task task = <span class="keyword">new</span> Task(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">pool.invoke(task)</span><br><span class="line">task.join();</span><br></pre></td></tr></table></figure></li>
<li><p>可完成Future【CompletableFuture】</p>
<p>  由于单纯使用Future会造成线程阻塞，java8引用了<code>CompletableFuture</code>来对<code>Future</code>进行改进，实现异步调用的逻辑</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">    CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">    <span class="comment">// 如果执行成功:</span></span><br><span class="line">    cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 如果执行异常:</span></span><br><span class="line">    cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error: &quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步器</p>
<table>
<thead>
<tr>
<th>类</th>
<th>能做什么</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CyclicBarrier</td>
<td>允许线程集等待直至其中预定数目的线程到达一个公共障栅（ barrier)，然后可以选择执行一个处理障栅的动作</td>
<td>当大量的线程需要在它们的结果可用之前完成时</td>
</tr>
<tr>
<td>Phaser</td>
<td>类似于循环障栅， 不过有一个可变的计数</td>
<td>Java SE 7 中引人</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>允许线程集等待直到计数器减为0</td>
<td>当一个或多个线程需要等待直到指定数目的事件发生</td>
</tr>
<tr>
<td>Exchanger</td>
<td>允许两个线程在要交换的对象准备好时交换对象</td>
<td>当两个线程工作在同一数据结构的两个实例上的时候， 一个向实例添加数据而另一个从实例清除数据</td>
</tr>
<tr>
<td>Samaphore</td>
<td>允许线程集等待直到被允许继续运行为止</td>
<td>限制访问资源的线程总数。如果许可数是1，常常阻塞线程直到另一个线程给出许可为止</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>允许一个线程把对象交给另一个线程</td>
<td>在没有显式同步的情况下， 当两个线程准备好将一个对象从一个线程传递到另一个时</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
</search>
