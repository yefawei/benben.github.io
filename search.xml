<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/11/hello-world/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><blockquote>
<p>Welcome to my blog.</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>正则</title>
    <url>/2020/09/19/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除“\n”和”\r”之外的任何单个字符。要匹配包括“\n”和”\r”在内的任何字符，请使用像“[\s\S]”的模式。</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
<td></td>
</tr>
<tr>
<td>$</td>
<td>匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，也能匹配“zo”以及“zoo”。</em>等价于{0,}。</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。</td>
<td></td>
</tr>
<tr>
<td>{n} {n,}{n,m}</td>
<td>匹配确定的<em>n</em>次 / 至少匹配<em>n</em>次 / 最少匹配<em>n</em>次且最多匹配<em>m</em>次</td>
<td></td>
</tr>
<tr>
<td>[]</td>
<td>字符集合</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>将两个匹配条件进行逻辑“或”（or）运算</td>
<td></td>
</tr>
<tr>
<td>\d \D</td>
<td>匹配一个数字字符。等价于[0-9] / 匹配一个非数字字符。等价于[^0-9]</td>
<td></td>
</tr>
<tr>
<td>\s \S</td>
<td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。/ 匹配任何可见字符。等价于[^\f\n\r\t\v]。</td>
<td></td>
</tr>
<tr>
<td>\w \W</td>
<td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_] / 匹配任何非单词字符,等价于“[^A-Za-z0-9]”</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>组</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>AIDL</title>
    <url>/2020/12/05/Android/AIDL/</url>
    <content><![CDATA[<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p>相关文章：</p>
<p><a href="Binder.md">关于Binder</a></p>
<blockquote>
<p>注：<br>一、如果不需要跨进程，则应继承<code>Binder</code>并返回给绑定服务调用处；参考：<a href="https://developer.android.com/guide/components/bound-services#Binder">https://developer.android.com/guide/components/bound-services#Binder</a><br>二、如果需要跨进程但不需要处理多线程，则建议使用<code>Messenger</code>来实现接口；参考：<a href="https://developer.android.com/guide/components/bound-services#Messenger">https://developer.android.com/guide/components/bound-services#Messenger</a></p>
</blockquote>
<h5 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h5><blockquote>
<p>注：最好把所有的aidl文件放在同一个包中,因为另一个进程调用时需要一样的包名才能生效</p>
</blockquote>
<p>新建一个以aidl为后缀的文件,其它类型参数必须标上方向:<code>in</code> <code>out</code> 或者<code>inout</code>。<br>in表示输入型参数，即数据只能从客户端传递向服务端，由服务端传递向客户端的参数会变成默认值<br>out表示输出型参数，即数据只能从服务端传递向客户端，由客户端传递向服务的参数会变成默认值<br>inout表示输入输出型，可以双向传递数据</p>
<p>IBookManager.aidl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.aidl;</span><br><span class="line"><span class="keyword">import</span> com.test.aidl.Book;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">Book <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h5><p>由于用到了自定义的Parcelable对象,必须新建一个和它同名的AIDL文件,并在其中声明它为Parcelable类型<br>例:上面我们用到了Book这个类,所以要创建<br>Book.aidl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.aidl;</span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>

<p>跨进程数据传递需要赋值封装,这样才能跨进程传递数据<br>Book.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mId;</span><br><span class="line">    <span class="keyword">public</span> String mName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一定要按照字段顺序写</span></span><br><span class="line">        mId = in.readInt();</span><br><span class="line">        mName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(mId);</span><br><span class="line">        dest.writeString(mName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Parcelable</span><br><span class="line">        .Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三"><a href="#第三" class="headerlink" title="第三"></a>第三</h5><p>远程服务端Service的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Book mBook = <span class="keyword">new</span> Book();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBook;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mBook = book;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第四"><a href="#第四" class="headerlink" title="第四"></a>第四</h5><p>客户端的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">            IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            bookManager.getBookList();<span class="comment">//做你要做的操作</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,BookManagerService.class);</span><br><span class="line">        bindService(intent,mConnection,Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h5><ol>
<li>要往子进程传递一个监听类如：<code>IOnNewBookArrivedListener </code>，那么该类必须是Binder的子类；由于跨进程通讯该监听类会序列化传递到子进程再反序列化重新生成一个对象，所以用普通的List去存储监听类是无法移除的；这里要使用<code>RemoteCallBackList</code>的<code>register</code>方法和<code>unregister</code>来存取；<ul>
<li>由于跨进程传输对象的底层Binder对象是同一个，<code>RemoteCallBackList</code>便是使用这一点来进行添加移除</li>
<li><code>RemoteCallBackList</code>的遍历需要通过<code>beginBroadcast</code>和<code>finishBroadcast</code>配对使用</li>
</ul>
</li>
</ol>
<h5 id="跨进程内存泄漏"><a href="#跨进程内存泄漏" class="headerlink" title="跨进程内存泄漏"></a>跨进程内存泄漏</h5><p>在跨进程调用IPC方法，即当前进程传递回调监听<code>Listener</code>到目标进程，在取消监听后该<code>Listener</code>不会立马被回收，会存入一个静态链表<code>ReferenceQueue</code>中，有一个专门的守护线程去维护这个链表，当该线程执行的时候会弹出里面的对象，执行他们的<code>finalize</code>方法，下次执行GC时才会被回收。</p>
<p>内存泄漏：<br>直接原因时该守护线程优先级比较低，运行的时间比较少。当<code>ReferenceQueue</code>持有的对象过多时，守护线程来不及弹出对象，造成无论如何GC都不会回收。<br>如果监听类持有<code>Context</code>等需要回收的对象，会造成内存泄漏</p>
<p>其中Android9.0之前对象会被<code>FinalizerFeference</code>持有并存入<code>ReferenceQueue</code>：</p>
<p><img src="/2020/12/05/Android/AIDL/Android8.1.png"></p>
<p>Android9.0起（含9.0）对象会被<code>Cleaner</code>持有并存入<code>ReferenceQueue</code>：</p>
<p><img src="/2020/12/05/Android/AIDL/Android9.0.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AIDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动流程</title>
    <url>/2020/12/07/Android/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88AMS%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h1><p><a href="https://mp.weixin.qq.com/s/1bfi-BVe23_96A2AlhaPKg">https://mp.weixin.qq.com/s/1bfi-BVe23_96A2AlhaPKg</a></p>
<h4 id="系统启动触发Launcher流程"><a href="#系统启动触发Launcher流程" class="headerlink" title="系统启动触发Launcher流程"></a>系统启动触发Launcher流程</h4><p>系统开机时加载引导程序并初始化各个硬件，初始化完成后会创建出第一个用户进程 <code>Init进程(pid=1)</code>，随后孵化出 <code>adbd(adb 命令)</code> 和 <code>logd(日志输出)</code> 两个守护进程，执行完成之后还会孵化出第一个 <code>java</code> 进程，也就是 <code>Zygote</code> 进程，它会调用 <code>ZygoteInit.java</code> 这个类，在这个类的入口方法会创建 <code>Framework</code> <code>SystemServer</code> 系统服务进程，即 <code>SystemServer.java</code> 这个类，在这个 <code>SystemServer</code> 这个类里面又会创建我们熟知的系统服务：<code>ActivityManagerService</code> 、 <code>WindowManagerService</code> 、<code>PowerManagerService</code> 、<code>InputManagerService</code> 等等，同时创建出 <code>binder</code> 线程池，当所有服务启动完毕后，就会调用 <code>ActivityManagerService.systemReady()</code> 来启动 <code>Launcher</code> 应用了。</p>
<h4 id="Launcher-启动-App-流程"><a href="#Launcher-启动-App-流程" class="headerlink" title="Launcher 启动 App 流程"></a>Launcher 启动 App 流程</h4><ul>
<li> <code>Launcher</code> 监听到点击app事件，调用 <code>Activity.startActivityForResult()</code> ,转到 <code>Instrumentation</code> 类的 <code>execStartActivity</code> 方法</li>
<li> <code>Instrumentation</code>  通过跨进程通信告诉 <code>ATMS</code> 要启动应用的需求</li>
<li><code>ATMS</code> 反馈 <code>Launcher</code> 让其进入 <code>Paused</code> 状态</li>
<li>随后 <code>ATMS</code> 转到 <code>ZygoteProcess</code> 类，通过 <code>socket</code> 与 <code>Zygote</code> 通信，告知 <code>Zygote</code> 需要新建进程</li>
<li><code>Zygote fork</code> 进程，并调用 <code>ActivityThread</code> 的 <code>main</code> 方法，也就是app的入口</li>
<li><code>ActivityThread</code> 创建 <code>ActivityThread</code> 实例，新建 <code>Looper</code> 实例，开始 <code>loop</code> 循环</li>
<li>同时 <code>ActivityThread</code> 告知 <code>AMS</code>，进程创建完毕，开始反射创建 <code>Application</code> <code>Provider</code>，并调用 <code>Application</code> 的 <code>attach</code> <code>onCreate</code> 的方法</li>
<li>最后创建上下文，反射创建 <code>Activity</code>，开始调用生命周期</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li><code>ActivityManagerService</code> 与 <code>ActivityTaskManagerService</code> 的区别?<ul>
<li>原本四大组件的通信都是 <code>AMS</code> 来处理，后期 <code>AMS</code> 过于臃肿，将 <code>Activity</code> 相关工作转移到 <code>ATMS</code> 中</li>
</ul>
</li>
<li>怎么判断应用进程存在？<ul>
<li>如果进程存在，<code>ATMS</code> 里面会保存有 <code>WindowProcessController</code> 信息，这个信息包括 <code>processName</code> 和 <code>uid</code>，<code>uid</code> 则是应用程序的 <code>id</code>，可以通过 <code>applicationInfo.uid</code> 获取。所以判断进程是否存在，根据 <code>processName</code> 和 <code>uid</code> 去判断是否有对应的 <code>WindowProcessController</code>，并且 <code>WindowProcessController</code> 里面的线程不为空。</li>
</ul>
</li>
<li>怎么创建进程，为什么要通过 socket 进行 IPC 通信而不是 binder？<ul>
<li>通过 <code>socket</code> 与 <code>Zygote</code> 进行通信，然后 <code>Zygote</code> 进行 <code>fork</code> 进程并返回新进程的 <code>pid</code></li>
<li>fork() 方法是类 Unix 操作系统上创建进程的主要方法，用于创建当前进程的副本</li>
<li>因为 binder 是多线程交互，而 fork 不允许存在多线程，原因是会出现死锁，例如主进程里的A线程持有锁后，fork 出的子进程同样将锁 fork 出来了，当子进程的线程需要用到该锁，那么就会出现死锁</li>
</ul>
</li>
</ol>
<p><strong><code>ZygoteInit.java</code> 里做的业务：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 预加载 frameworks/base/preloaded-classes 和 framework_res.apk 等系统资源</span></span><br><span class="line">    <span class="comment">// 应用在启动时需要大量调用系统资源，这里预先调用可以提高应用响应速度</span></span><br><span class="line">    preloadClasses();</span><br><span class="line">    preloadResources();</span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 启动 system_server 进程。该进程是 framework 核心</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>].equals(<span class="string">&quot;start-system-server&quot;</span>)) &#123;</span><br><span class="line">        startSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建 Socket 服务</span></span><br><span class="line">    registerZygoteSocket();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 进入阻塞状态，等待连接，用以处理来自 AMS 申请进程创建的请求</span></span><br><span class="line">    runSelectLoopMode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>SystemServer.java</code> 里做的业务：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建系统服务管理者</span></span><br><span class="line">    SystemServiceManager mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    <span class="comment">// 启动引导服务</span></span><br><span class="line">    startBootstrapServices(t);</span><br><span class="line">    <span class="comment">// 启动核心服务</span></span><br><span class="line">    startCoreServices(t);</span><br><span class="line">    <span class="comment">// 启动其它一般服务</span></span><br><span class="line">    startOtherServices(t);</span><br><span class="line">    <span class="comment">// 当所有服务启动完毕会调用ActivityManagerService.systemReady来启动launcher应用</span></span><br><span class="line">    mActivityManagerService.systemReady()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Launcher-启动流程示意"><a href="#Launcher-启动流程示意" class="headerlink" title="Launcher 启动流程示意"></a>Launcher 启动流程示意</h4><img src="/2020/12/07/Android/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88AMS%EF%BC%89/Launcher启动流程.png" style="zoom:50%;">

<p>相关成员：</p>
<ul>
<li><code>ActivityRecord</code>：<code>Server</code> 端 <code>Activity</code> 的映射，存放了 <code>Activity</code> 的各种信息，当 <code>Activity</code> 被回收时，临时保存的数据也会通过 <code>Instrumentation.callActivityOnSaveInstanceState</code> 跨进程通信保存在该类中</li>
<li><code>TaskRecord</code>：单个任务栈记录</li>
<li><code>ActivityStack</code>：<code>Activity</code> 的栈管理，出栈入栈顺序等信息</li>
<li><code> ActivityStackSupervisor</code>：管理各个app的任务栈管理者</li>
</ul>
<p><img src="/2020/12/07/Android/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88AMS%EF%BC%89/Activity%E4%BB%BB%E5%8A%A1%E6%A0%88.png"></p>
<p><strong>【重点】</strong>留意 <code>ActivityStarter</code>，里面有检查配置清单里的信息，如果要处理插件化，<code>Activity</code> 配置清单信息要如何处理同让需要参考该类并hook里面的逻辑</p>
<h4 id="Activity创建流程示意"><a href="#Activity创建流程示意" class="headerlink" title="Activity创建流程示意"></a>Activity创建流程示意</h4><p><img src="/2020/12/07/Android/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88AMS%EF%BC%89/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Annotation Processing</title>
    <url>/2020/12/03/Android/Annotation%20Processing/</url>
    <content><![CDATA[<h1 id="Annotation-Processing"><a href="#Annotation-Processing" class="headerlink" title="Annotation Processing"></a>Annotation Processing</h1><blockquote>
<p>简称APT，通过注解动态生成必要的类；</p>
<p>使用该技术的有：ButterKnife、EventBus</p>
</blockquote>
<h5 id="第一步：创建工程"><a href="#第一步：创建工程" class="headerlink" title="第一步：创建工程"></a>第一步：创建工程</h5><p>![](新建APT 库.png)</p>
<h5 id="第二步：复写AbstractProcessor和声明注解处理器"><a href="#第二步：复写AbstractProcessor和声明注解处理器" class="headerlink" title="第二步：复写AbstractProcessor和声明注解处理器"></a>第二步：复写AbstractProcessor和声明注解处理器</h5><p><img src="/2020/12/03/Android/Annotation%20Processing/APT%E5%A4%84%E7%90%86%E5%99%A8.png"></p>
<p>继承<code>AbstractProcessor</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> : <span class="type">AbstractProcessor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> filer: Filer</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(processingEnv: <span class="type">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(processingEnv)</span><br><span class="line">        filer = processingEnv.filer <span class="comment">// 在初始化函数中获取文件输出类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回回ture表示该注解已经被处理, 后续不会再有其他处理器处理; 返回false表示仍可被其他处理器处理</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(annotations: <span class="type">MutableSet</span>&lt;<span class="type">out</span> <span class="type">TypeElement</span>&gt;?, roundEnv: <span class="type">RoundEnvironment</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// 这里通过 Filer 输出目标文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合中指定支持的注解类型的名称（这里必须时完整的包名+类名)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持的命令行参数选项</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedOptions</span><span class="params">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedOptions()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定当前正在使用的Java版本</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedSourceVersion</span><span class="params">()</span></span>: SourceVersion &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedSourceVersion()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明注解处理器：</p>
<p>mian目录下声明 <code>resources/META-INF/services/javax.annotation.processing.Processor</code> 文件</p>
<p>文件内声明注解处理器类全称：com.benben.lib_processor.MyProcessor</p>
<p>引用：</p>
<p>annotationProcessor project(‘:lib-processor’)</p>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>可以使用 <code>Filer</code> 直接输出文件，也可以使用<code>javapoet</code> 第三方库来输出文件</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 中的线程模型</title>
    <url>/2020/11/10/Android/Android%20%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Android-中的线程模型"><a href="#Android-中的线程模型" class="headerlink" title="Android 中的线程模型"></a>Android 中的线程模型</h1><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h5 id="线程调度原理"><a href="#线程调度原理" class="headerlink" title="线程调度原理"></a>线程调度原理</h5><ul>
<li>任一时刻，一个 <code>CPU</code> 核心只有一个线程处于运行状态</li>
<li>多线程并发，轮流获取 <code>CPU</code> 使用权</li>
</ul>
<h5 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h5><ul>
<li>分时调度模型：轮流获取、均分 <code>CPU</code></li>
<li>抢占式调度模型：谁抢到谁使用，优先级高的线程抢到的概率更高</li>
</ul>
<h3 id="Android-线程调度"><a href="#Android-线程调度" class="headerlink" title="Android 线程调度"></a>Android 线程调度</h3><p>采用抢占式调度模型</p>
<ol>
<li><p><code>nice</code> 值，【注意】nice值不是优先级</p>
<p>Process 中定义，值越小优先级越高，默认时 <code>THREAD_PRIORITY_DEFAUT = 0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Process.setThreadPriority()</span><br></pre></td></tr></table></figure></li>
<li><p><code>priority</code>优先级</p>
<p>线程优先级，值越大优先级越高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Therad().setPriority()</span><br></pre></td></tr></table></figure></li>
<li><p><code>cgroup</code></p>
<p>更严格的群组调度策略，分前台 <code>group</code> 和后台 <code>group</code>，保证前台线程可以获取更多的 <code>CPU</code> 时间片</p>
</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>线程过多会导致 <code>CPU</code> 频繁切换，降低线程运行效率，还有可能出现线程饥饿（长时间没有得到执行）</li>
<li>优先级具有继承性</li>
<li>正确认识任务重要性决定优先级</li>
<li>线程必须命名，以定位归属</li>
<li>注意区分 <code>IO</code> 密集型和 <code>CPU</code> 密集型任务</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Base64 和 Base58</title>
    <url>/2020/11/29/Android/Base64%E5%92%8CBase58/</url>
    <content><![CDATA[<h1 id="Base64-和-Base58"><a href="#Base64-和-Base58" class="headerlink" title="Base64 和 Base58"></a>Base64 和 Base58</h1><h3 id="Base64算法："><a href="#Base64算法：" class="headerlink" title="Base64算法："></a>Base64算法：</h3><p>将原数据每6位对应成Base 64索引表中的一个字符编排成一个字符串（每个字符8位）。</p>
<h5 id="Base64索引表"><a href="#Base64索引表" class="headerlink" title="Base64索引表"></a>Base64索引表</h5><p><img src="/2020/11/29/Android/Base64%E5%92%8CBase58/Base64%E7%A0%81%E8%A1%A8.jpg"></p>
<p>编码示例：把【Man】进行Base64编码</p>
<p><img src="/2020/11/29/Android/Base64%E5%92%8CBase58/Base64%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B.jpg"></p>
<p>编码示例：Base64的末尾补足</p>
<p><img src="/2020/11/29/Android/Base64%E5%92%8CBase58/%E6%9C%AB%E5%B0%BE%E8%A1%A5%E8%B6%B3.jpg"></p>
<h5 id="Base64用途"><a href="#Base64用途" class="headerlink" title="Base64用途"></a>Base64用途</h5><ol>
<li>将二进制数据扩充了存储和传输途径，即：允许通过文本传输任何数据</li>
<li>有一定的保密性，非肉眼可见</li>
</ol>
<h5 id="Base64的缺点"><a href="#Base64的缺点" class="headerlink" title="Base64的缺点"></a>Base64的缺点</h5><p>因为原理是6位变8位，即每次编码后数据会增大1\3，所以会影响存储和传输性能。</p>
<h5 id="问题：Base64加密图片传输更安全和更高效？"><a href="#问题：Base64加密图片传输更安全和更高效？" class="headerlink" title="问题：Base64加密图片传输更安全和更高效？"></a>问题：Base64加密图片传输更安全和更高效？</h5><p>提供的安全性很小，Base64会让原有数据增大1\3，所以也并不高效，对传输速度有要求的就是画蛇添足的操作。</p>
<h3 id="Base58"><a href="#Base58" class="headerlink" title="Base58"></a>Base58</h3><p><strong>Base64的变种</strong>，数字货币常用的编码方式（比特币等）。去掉了数字0、字母大写O、字母大写I、和字母小写l，以及+和/符号，主要是方便人工抄写，去掉符号也让大多数软件方便双击复制</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitmap</title>
    <url>/2020/11/27/Android/Bitmap/</url>
    <content><![CDATA[<h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><blockquote>
<p><a href="https://developer.android.com/topic/performance/graphics/load-bitmap">参考：高效加载大型位图</a></p>
<p><a href="https://developer.android.com/topic/performance/graphics/manage-memory.html">参考：管理位图内存</a></p>
</blockquote>
<h4 id="不同-Android-版本时的Bitmap内存模型"><a href="#不同-Android-版本时的Bitmap内存模型" class="headerlink" title="不同 Android 版本时的Bitmap内存模型"></a>不同 Android 版本时的Bitmap内存模型</h4><table>
<thead>
<tr>
<th>API 级别</th>
<th>API 10-</th>
<th>API 11 ~ API 25</th>
<th>API 26+</th>
</tr>
</thead>
<tbody><tr>
<td>Bitmap 对象存放</td>
<td>Java heap</td>
<td>Java heap</td>
<td>Java heap</td>
</tr>
<tr>
<td>像素 (pixel data)数据存放</td>
<td>native heap</td>
<td>Java heap</td>
<td>native heap</td>
</tr>
</tbody></table>
<p><code>API 10-</code> 该方式有个缺点，就是 <code>java</code> 层已经被回收掉了，但是 <code>native</code> 层并不清楚，回收时机不明确，所以在 <code>API 11 ~ API 25</code> 将它放入到 <code>java</code> 层中，在 <code>  API 26+</code> 又做了优化，<code>java</code> 回收后能迅速通知到到 <code>native</code> 层</p>
<h5 id="获取-Bitmap-占用内存"><a href="#获取-Bitmap-占用内存" class="headerlink" title="获取 Bitmap 占用内存"></a>获取 Bitmap 占用内存</h5><ul>
<li><code>getByteCount</code> 函数：直接返回 <code>bitmap</code> 占用的内存，但需要运行时动态算出来</li>
</ul>
<h5 id="缩小图片"><a href="#缩小图片" class="headerlink" title="缩小图片"></a>缩小图片</h5><p>方案一：</p>
<p>该方案得到的结果宽高比例并不一定与 <code>inSampleSize</code> 一致，加载完后还会根据密度等比放大或缩小</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> targetSize = <span class="number">400</span></span><br><span class="line"><span class="keyword">val</span> options = BitmapFactory.Options()</span><br><span class="line">options.inJustDecodeBounds = <span class="literal">true</span></span><br><span class="line">BitmapFactory.decodeResource(resources, R.mipmap.avatar, options)</span><br><span class="line">options.inJustDecodeBounds = <span class="literal">false</span></span><br><span class="line"><span class="keyword">val</span> (height: <span class="built_in">Int</span>, width: <span class="built_in">Int</span>) = options.run &#123; outHeight to outWidth &#125;</span><br><span class="line"><span class="keyword">var</span> inSampleSize = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (height &gt; targetSize || width &gt; targetSize) &#123;</span><br><span class="line">    <span class="keyword">val</span> halfHeight: <span class="built_in">Int</span> = height / <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> halfWidth: <span class="built_in">Int</span> = width / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (halfHeight / inSampleSize &gt;= targetSize &amp;&amp; halfWidth / inSampleSize &gt;= targetSize) &#123;</span><br><span class="line">        inSampleSize *= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">options.inSampleSize = inSampleSize</span><br><span class="line"><span class="keyword">val</span> bitmap = BitmapFactory.decodeResource(resources, R.mipmap.avatar, options)</span><br></pre></td></tr></table></figure>

<p>方案二：</p>
<p>该方案会将图片按 <code>targetSize/outWidth</code> 的比例进行缩放</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> targetSize = <span class="number">400</span></span><br><span class="line"><span class="keyword">val</span> options = BitmapFactory.Options()</span><br><span class="line">options.inJustDecodeBounds = <span class="literal">true</span></span><br><span class="line">BitmapFactory.decodeResource(resources, R.mipmap.avatar, options)</span><br><span class="line">options.inJustDecodeBounds = <span class="literal">false</span></span><br><span class="line">options.inScaled = <span class="literal">true</span></span><br><span class="line">options.inDensity = options.outWidth</span><br><span class="line">options.inTargetDensity = targetSize</span><br><span class="line"><span class="keyword">val</span> bitmap = BitmapFactory.decodeResource(resources, R.mipmap.avatar, options)</span><br></pre></td></tr></table></figure>

<p>【注意】上述两种方案得到的Bitmap密度并不一致</p>
<h5 id="在-Android-3-0-及更高版本上管理内存"><a href="#在-Android-3-0-及更高版本上管理内存" class="headerlink" title="在 Android 3.0 及更高版本上管理内存"></a>在 Android 3.0 及更高版本上管理内存</h5><p>声明重用管理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SoftReference&lt;Bitmap&gt;&gt; mReusableBitmaps = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LruCache&lt;String, BitmapDrawable&gt; mMemoryCache = <span class="keyword">new</span> LruCache&lt;String, BitmapDrawable&gt;(<span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, <span class="meta">@NotNull</span> String key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@NotNull</span> BitmapDrawable oldValue, BitmapDrawable newValue)</span> </span>&#123;</span><br><span class="line">            Bitmap bitmap = oldValue.getBitmap();</span><br><span class="line">            <span class="keyword">if</span> (bitmap.isMutable()) &#123;</span><br><span class="line">                mReusableBitmaps.add(<span class="keyword">new</span> SoftReference&lt;&gt;(bitmap));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历可重复使用的Bitmap，查找出合适重用的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">getBitmapFromReusableSet</span><span class="params">(BitmapFactory.Options options)</span> </span>&#123;</span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mReusableBitmaps.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mReusableBitmaps) &#123;</span><br><span class="line">                <span class="keyword">final</span> Iterator&lt;SoftReference&lt;Bitmap&gt;&gt; iterator = mReusableBitmaps.iterator();</span><br><span class="line">                Bitmap item;</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    item = iterator.next().get();</span><br><span class="line">                    <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; item.isMutable()) &#123;</span><br><span class="line">                        <span class="comment">// 判断InBitmap是否可用</span></span><br><span class="line">                        <span class="keyword">if</span> (canUseForInBitmap(item, options)) &#123;</span><br><span class="line">                            bitmap = item;</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否允许重用Bitmap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidate     候选的Bitmap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetOptions 目标配置项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canUseForInBitmap</span><span class="params">(Bitmap candidate, BitmapFactory.Options targetOptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            <span class="keyword">int</span> width = targetOptions.outWidth / targetOptions.inSampleSize;</span><br><span class="line">            <span class="keyword">int</span> height = targetOptions.outHeight / targetOptions.inSampleSize;</span><br><span class="line">            <span class="keyword">int</span> byteCount = width * height * getBytesPerPixel(candidate.getConfig());</span><br><span class="line">            <span class="keyword">return</span> byteCount &lt;= candidate.getAllocationByteCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate.getWidth() == targetOptions.outWidth</span><br><span class="line">                &amp;&amp; candidate.getHeight() == targetOptions.outHeight</span><br><span class="line">                &amp;&amp; targetOptions.inSampleSize == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据位图的配置返回位图每像素的字节使用率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBytesPerPixel</span><span class="params">(Bitmap.Config config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config == Bitmap.Config.ARGB_8888) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config == Bitmap.Config.RGB_565) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config == Bitmap.Config.ARGB_4444) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config == Bitmap.Config.ALPHA_8) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromFile</span><span class="params">(String filename, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight, ImageCache cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeFile(filename, options);</span><br><span class="line">        <span class="comment">// 这里可能还需要做大小的缩放</span></span><br><span class="line">        addInBitmapOptions(options, cache);</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeFile(filename, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInBitmapOptions</span><span class="params">(BitmapFactory.Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           ImageCache cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试查找可用的inBitmap位图。</span></span><br><span class="line">            Bitmap inBitmap = cache.getBitmapFromReusableSet(options);</span><br><span class="line">            <span class="keyword">if</span> (inBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// inBitmap只适用于可变位图，因此强制解码器返回可变位图。</span></span><br><span class="line">                options.inMutable = <span class="keyword">true</span>;</span><br><span class="line">                options.inBitmap = inBitmap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment与ViewPager</title>
    <url>/2020/11/22/Android/Fragment%E4%B8%8EViewPager/</url>
    <content><![CDATA[<h1 id="Fragment与ViewPager"><a href="#Fragment与ViewPager" class="headerlink" title="Fragment与ViewPager"></a>Fragment与ViewPager</h1><blockquote>
<p>依附于Activity的组件，可以看作是拥有自己生命周期的UI组件</p>
</blockquote>
<h5 id="FragmentTransaction"><a href="#FragmentTransaction" class="headerlink" title="FragmentTransaction"></a>FragmentTransaction</h5><ul>
<li><p>show 方法：显示UI，不涉及生命周期</p>
</li>
<li><p>hide 方法：隐藏UI，不涉及生命周期</p>
</li>
<li><p>attach 方法：触发onStart和onResume</p>
</li>
<li><p>detach 方法：触发onPause和onStop</p>
</li>
<li><p>add 方法：添加Fragment并走完整的显示流程</p>
</li>
<li><p>remove 方法：移除Fragment并走完整的隐藏流程</p>
</li>
</ul>
<h5 id="FragmentPagerAdapter-与-FragmentStatePagerAdapter-区别"><a href="#FragmentPagerAdapter-与-FragmentStatePagerAdapter-区别" class="headerlink" title="FragmentPagerAdapter 与 FragmentStatePagerAdapter 区别"></a>FragmentPagerAdapter 与 FragmentStatePagerAdapter 区别</h5><p>FragmentPagerAdapter：适用页面较少的情况，核心流程走的是<code>attach</code>和<code>detach</code>方法</p>
<p>FragmentStatePagerAdapter ：适用页面较多的情况，核心流程走<code>add</code>和<code>remove</code>方法，会触发<code>onSaveInstanceState</code>数据保存</p>
<blockquote>
<p>有的人会将<code>onCreateView</code>里创建的变成全局变量长期持有，造成<code>FragmentStatePagerAdapter </code>所能释放的数据并不会有多少，在内存有严苛要求的情况下可以在<code>onDestoryView</code>里释放View，每次在<code>onCreateView</code>里重新创建View即可</p>
</blockquote>
<h5 id="在ViewPager中的生命周期问题"><a href="#在ViewPager中的生命周期问题" class="headerlink" title="在ViewPager中的生命周期问题"></a>在<code>ViewPager</code>中的生命周期问题</h5><p><strong>答：</strong>在缓存的范围内生命周期都会走到<code>onResume</code>方法，需要通过<code>setUserVisibleHint</code>方法来组合判断是否是当前显示页。同时需要注意的是，在<code>ViewPager</code>滑动时嵌套的子<code>Fragment</code>由于父<code>Fragment</code>没有任何生命周期变化，所以子<code>Framgent</code>的<code>setUserVisibleHint</code>并不会触发，需要自己手动通知子<code>Fragment</code>。<strong>这是一个优化点，只让当前页面进行网络请求和播放动画</strong></p>
<p><strong>答：</strong>在<code>AndroidX</code>中引入了<code>Lifecycle</code>生命周期判断，可以通过适配器中传入<code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code>，这样就只有当前页会走到<code>onResume</code>，其它不可见页面只会走到<code>onStart</code>方法，同时由于父<code>Fragment</code>生命周期的变化，嵌套的子<code>Fragment</code>也变相的会收到页面不可见的通知</p>
<h5 id="Fragment-界面显示异常解决思路"><a href="#Fragment-界面显示异常解决思路" class="headerlink" title="Fragment 界面显示异常解决思路"></a><code>Fragment</code> 界面显示异常解决思路</h5><p>Fragment 界面异常，有可能 <code>Activity</code> 触发了onSaveInstanceState，状态被保存了，后续所有提交的事务即commit都不会生效，可以循着这个方向找答案</p>
<h5 id="在ViewPager中适配器生成Fragment问题"><a href="#在ViewPager中适配器生成Fragment问题" class="headerlink" title="在ViewPager中适配器生成Fragment问题"></a>在<code>ViewPager</code>中适配器生成<code>Fragment</code>问题</h5><p><strong>答：</strong></p>
<p>有的人会提前将<code>Fragment</code>实例化添加到一个数组中，然后传入到<code>PagerAdapter</code>里，<code>Activity</code>回收时会产生重复创建的问题。由于<code>Activity</code>在回收时会将<code>Fragment</code>的状态保存下来存入到key为<code>android:support:fragments</code>的<code>Bundle</code>里，重建时在<code>onCreate</code>会尝试<code>Fragment</code>状态的恢复，不会触发适配器获取实例的方法，手动生成的<code>Fragment</code>数组就变成了错误的引用，外部对该数组进行操作就会产生异常（具体随业务而定）。</p>
<p><strong>解决方案</strong>：</p>
<p>方式一：在适当的函数里手动移除<code>Bundle</code>里存的值，可以在触发存储函数里，也可在<code>onCreate</code>函数里</p>
<p>方式二：自己适配数据重建逻辑，移除手动生成数组实例</p>
<h5 id="ViewPager2特性"><a href="#ViewPager2特性" class="headerlink" title="ViewPager2特性"></a>ViewPager2特性</h5><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650829623&amp;idx=1&amp;sn=79fa66ac994f09e501ae5c3563b5e5c2&amp;chksm=80b7a7a9b7c02ebfcbada5c7dea37d3c9b57c79d6de201a7b76be20d80ea673eb2b3f526bfa7&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650829623&amp;idx=1&amp;sn=79fa66ac994f09e501ae5c3563b5e5c2&amp;chksm=80b7a7a9b7c02ebfcbada5c7dea37d3c9b57c79d6de201a7b76be20d80ea673eb2b3f526bfa7&amp;scene=21#wechat_redirect</a></p>
<ol>
<li>基于RecyclerView实现。这意味着RecyclerView的优点将会被ViewPager2所继承</li>
<li>支持竖直滑动。只需要一个参数就可以改变 滑动方向</li>
<li>支持关闭用户输入。通过setUserInputEnabled来设置是否禁止用户滑动页面</li>
<li>支持通过编程方式滚动。通过fakeDragBy(offsetPx)代码模拟用户滑动页面</li>
<li>CompositePageTransformer 支持同时添加多个PageTransformer</li>
<li>支持DiffUtil ，可以添加数据集合改变的item动画</li>
<li>支持RTL (right-to-left)布局。我觉得这个功能对国内开发者来说可能用处不大..</li>
</ol>
<h5 id="ViewPager2的生命周期"><a href="#ViewPager2的生命周期" class="headerlink" title="ViewPager2的生命周期"></a>ViewPager2的生命周期</h5><p><strong>答：</strong>默认只有当前页会走到<code>onResume</code>方法，其它缓存页面会走到<code>onStart</code>，同时由于父<code>Fragment</code>生命周期的变化，嵌套的子<code>Fragment</code>也变相的会收到页面不可见的通知</p>
<h5 id="ViewPager2嵌套滚动问题"><a href="#ViewPager2嵌套滚动问题" class="headerlink" title="ViewPager2嵌套滚动问题"></a>ViewPager2嵌套滚动问题</h5><blockquote>
<p>在同方向的嵌套滚动中，<code>ViewPager2</code>内部的视图是无法滚动的。为了支持同方向的嵌套滚动，需要在<code>onInterceptTouchEvent</code>中判断是否需要请求父视图不要拦截<code>requestDisallowInterceptTouchEvent</code></p>
</blockquote>
<p>参考：<a href="https://developer.android.com/training/animation/vp2-migration#nested-scrollables">https://developer.android.com/training/animation/vp2-migration#nested-scrollables</a></p>
<p>方案：使用<code>NestedScrollableHost</code>包裹子滚动视图</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewConfiguration</span><br><span class="line"><span class="keyword">import</span> android.widget.FrameLayout</span><br><span class="line"><span class="keyword">import</span> androidx.viewpager2.widget.ViewPager2</span><br><span class="line"><span class="keyword">import</span> androidx.viewpager2.widget.ViewPager2.ORIENTATION_HORIZONTAL</span><br><span class="line"><span class="keyword">import</span> kotlin.math.absoluteValue</span><br><span class="line"><span class="keyword">import</span> kotlin.math.sign</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:         BenBen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateDate</span>:     2020/12/27 23:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedScrollableHost</span> : <span class="type">FrameLayout &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?) : <span class="keyword">super</span>(context, attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> touchSlop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initialX = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initialY = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> parentViewPager: ViewPager2?</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">var</span> v: View? = parent <span class="keyword">as</span>? View</span><br><span class="line">            <span class="keyword">while</span> (v != <span class="literal">null</span> &amp;&amp; v !<span class="keyword">is</span> ViewPager2) &#123;</span><br><span class="line">                v = v.parent <span class="keyword">as</span>? View</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> v <span class="keyword">as</span>? ViewPager2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> child: View? <span class="keyword">get</span>() = <span class="keyword">if</span> (childCount &gt; <span class="number">0</span>) getChildAt(<span class="number">0</span>) <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        touchSlop = ViewConfiguration.<span class="keyword">get</span>(context).scaledTouchSlop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInterceptTouchEvent</span><span class="params">(e: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        handleInterceptTouchEvent(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleInterceptTouchEvent</span><span class="params">(e: <span class="type">MotionEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> orientation = parentViewPager?.orientation ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Early return if child can&#x27;t scroll in same direction as parent</span></span><br><span class="line">        <span class="keyword">if</span> (!canChildScroll(orientation, -<span class="number">1f</span>) &amp;&amp; !canChildScroll(orientation, <span class="number">1f</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e.action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            initialX = e.x</span><br><span class="line">            initialY = e.y</span><br><span class="line">            Log.e(<span class="string">&quot;request&quot;</span>, <span class="string">&quot;true 1&quot;</span>)</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.action == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            <span class="keyword">val</span> dx = e.x - initialX</span><br><span class="line">            <span class="keyword">val</span> dy = e.y - initialY</span><br><span class="line">            <span class="keyword">val</span> isVpHorizontal = orientation == ORIENTATION_HORIZONTAL</span><br><span class="line"></span><br><span class="line">            <span class="comment">// assuming ViewPager2 touch-slop is 2x touch-slop of child</span></span><br><span class="line">            <span class="keyword">val</span> scaledDx = dx.absoluteValue * <span class="keyword">if</span> (isVpHorizontal) <span class="number">.5f</span> <span class="keyword">else</span> <span class="number">1f</span></span><br><span class="line">            <span class="keyword">val</span> scaledDy = dy.absoluteValue * <span class="keyword">if</span> (isVpHorizontal) <span class="number">1f</span> <span class="keyword">else</span> <span class="number">.5f</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scaledDx &gt; touchSlop || scaledDy &gt; touchSlop) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isVpHorizontal == (scaledDy &gt; scaledDx)) &#123;</span><br><span class="line">                    <span class="comment">// Gesture is perpendicular, allow all parents to intercept</span></span><br><span class="line">                    Log.e(<span class="string">&quot;request&quot;</span>, <span class="string">&quot;false 1&quot;</span>)</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Gesture is parallel, query child if movement in that direction is possible</span></span><br><span class="line">                    <span class="keyword">if</span> (canChildScroll(orientation, <span class="keyword">if</span> (isVpHorizontal) dx <span class="keyword">else</span> dy)) &#123;</span><br><span class="line">                        <span class="comment">// Child can scroll, disallow all parents to intercept</span></span><br><span class="line">                        Log.e(<span class="string">&quot;request&quot;</span>, <span class="string">&quot;true 2&quot;</span>)</span><br><span class="line">                        parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Log.e(<span class="string">&quot;request&quot;</span>, <span class="string">&quot;false 2&quot;</span>)</span><br><span class="line">                        <span class="comment">// Child cannot scroll, allow all parents to intercept</span></span><br><span class="line">                        parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">canChildScroll</span><span class="params">(orientation: <span class="type">Int</span>, delta: <span class="type">Float</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> direction = -delta.sign.toInt()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (orientation) &#123;</span><br><span class="line">            <span class="number">0</span> -&gt; child?.canScrollHorizontally(direction) ?: <span class="literal">false</span></span><br><span class="line">            <span class="number">1</span> -&gt; child?.canScrollVertically(direction) ?: <span class="literal">false</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle Plugin</title>
    <url>/2020/11/21/Android/Gradle%20Plugin/</url>
    <content><![CDATA[<h1 id="Gradle-Plugin"><a href="#Gradle-Plugin" class="headerlink" title="Gradle Plugin"></a>Gradle Plugin</h1><blockquote>
<p>能够允许我们在编译出的 jar 或 class 文件之后打包成 apk 之前修改文件</p>
<p>插件可以拿 java 、kotlin 或 groovy语言编写</p>
</blockquote>
<h5 id="自定义插件、扩展和配置"><a href="#自定义插件、扩展和配置" class="headerlink" title="自定义插件、扩展和配置"></a>自定义插件、扩展和配置</h5><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Plugin接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BenBenPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project target) &#123;</span><br><span class="line">        <span class="keyword">def</span> extension = target.extensions.create(<span class="string">&quot;benben&quot;</span>, BenBenExtension) <span class="comment">// 引入扩展并重命名</span></span><br><span class="line">        println <span class="string">&quot;1: $&#123;extension.name&#125;&quot;</span> <span class="comment">// 会在 apply 后调用，输出：1: benben extension</span></span><br><span class="line">        target.afterEvaluate &#123;</span><br><span class="line">            println <span class="string">&quot;2: $&#123;extension.name&#125;&quot;</span> <span class="comment">// 会在配置完扩展后调用，输出：2: benben config</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义扩展</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BenBenExtension</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> name = <span class="string">&quot;benben extension&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">apply <span class="attr">plugin:</span> BenBenPlugin <span class="comment">// 引入插件</span></span><br><span class="line">benben &#123;</span><br><span class="line">    name <span class="string">&quot;benben config&quot;</span> <span class="comment">// 配置扩展</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="构建Gradle-Plugin库"><a href="#构建Gradle-Plugin库" class="headerlink" title="构建Gradle Plugin库"></a>构建Gradle Plugin库</h5><ol>
<li>在项目新建 <code>buildSrc/src/main/groovy/&lt;包名&gt;/&lt;插件文件&gt;.groovy</code> 文件</li>
<li>在 main 目录内添加插件声明 <code>resources/META-INF/gradle-plugins/&lt;插件声明&gt;.properties</code></li>
<li>在需要使用插件的库中引用：apply plugin: ‘&lt;插件声明&gt;’，参考原生插件</li>
</ol>
<p>注意：</p>
<p>如果在实现<code>Plugin</code>时没有对应的包，则需要参考上图 <code>build.gradle</code> 配置 <code>gradle</code> 依赖</p>
<p>不要在<code>settings.gradle</code>中声明 <code>buildSrc</code> 库，该库为默认引用</p>
<h5 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h5><ol>
<li><p>声明 <code>Transform</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.benben.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.Format</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.QualifiedContent</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.Transform</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.TransformException</span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.TransformInvocation</span><br><span class="line"><span class="keyword">import</span> com.android.build.gradle.internal.pipeline.TransformManager</span><br><span class="line"><span class="keyword">import</span> com.android.utils.FileUtils</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BenBenTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;benben&#x27;</span> <span class="comment">// 任务名称：可以在gradle的 app/Tasks/other 中找到 transformClassesWith&lt;任务名&gt;For&lt;构建类型&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS <span class="comment">// 要处理的输入类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT <span class="comment">// 要处理的项目范围</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里只是简单的进行中转，并没有对文件做任何操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        def inputs = transformInvocation.inputs <span class="comment">// 输入文件</span></span><br><span class="line">        def outputProvider = transformInvocation.outputProvider <span class="comment">// 输出目的地</span></span><br><span class="line">        inputs.each &#123;</span><br><span class="line">            it.jarInputs.each &#123;</span><br><span class="line">                File dest = outputProvider.getContentLocation(it.name, it.contentTypes, it.scopes, Format.JAR)<span class="comment">// 获取jar文件目标地址</span></span><br><span class="line">                println <span class="string">&quot;Jar：$&#123;it.file&#125;，Dest：$&#123;dest&#125;&quot;</span></span><br><span class="line">                FileUtils.copyFile(it.file, dest) <span class="comment">// 将输入的文件拷贝到目标目录</span></span><br><span class="line">            &#125;</span><br><span class="line">            it.directoryInputs.each &#123;</span><br><span class="line">                File dest = outputProvider.getContentLocation(it.name, it.contentTypes, it.scopes, Format.DIRECTORY)<span class="comment">// 获取目录目标地址</span></span><br><span class="line">                println <span class="string">&quot;Dir：$&#123;it.file&#125;，Dest：$&#123;dest&#125;&quot;</span></span><br><span class="line">                FileUtils.copyDirectory(it.file, dest) <span class="comment">// 将输入的目录拷贝到目标目录</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BenBenPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project target) &#123;</span><br><span class="line">        <span class="keyword">def</span> transfrom = <span class="keyword">new</span> BenBenTransform()</span><br><span class="line">        <span class="keyword">def</span> baseExtension = target.extensions.getByType(BaseExtension)</span><br><span class="line">        baseExtension.registerTransform(transfrom)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：</p>
<p>如果已经注册了<code>Transfrom</code>，就必须实现<code>transform</code>方法来实现文件输出</p>
<p>正常情况下会通过 <code>javassist</code> 或 <code>ASM</code>等字节码处理库对中间文件进行修改</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle 基本语法结构</title>
    <url>/2020/11/21/Android/Gradle%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Gradle-基本语法结构"><a href="#Gradle-基本语法结构" class="headerlink" title="Gradle 基本语法结构"></a>Gradle 基本语法结构</h1><h5 id="语法一"><a href="#语法一" class="headerlink" title="语法一"></a>语法一</h5><blockquote>
<p><code>Closure</code>：闭包，一个可以被传递的方法</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> test(<span class="keyword">int</span> i , Closure data) &#123;</span><br><span class="line">    println(<span class="string">&quot;test run!&quot;</span>)</span><br><span class="line">    data.run()<span class="comment">// 触发 closure 函数</span></span><br><span class="line">&#125;</span><br><span class="line">test <span class="number">1</span>, &#123;</span><br><span class="line">    println(<span class="string">&quot;test closure!&quot;</span>)</span><br><span class="line">&#125;<span class="comment">// 这里调用 test 函数省略了括号</span></span><br></pre></td></tr></table></figure>



<h5 id="语法二"><a href="#语法二" class="headerlink" title="语法二"></a>语法二</h5><blockquote>
<p><code>methodMissing</code>：默认方法，当调用不存在的方法时会触发该函数</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> Object methodMissing(String name, Object args) &#123;</span><br><span class="line">		<span class="comment">// ... do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> a = <span class="keyword">new</span> A()</span><br><span class="line">a.gogo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 当A类没有该函数时回触发a的 methodMissing 方法</span></span><br></pre></td></tr></table></figure>



<h5 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h5><blockquote>
<p>构建类型</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    internal &#123;	<span class="comment">// 自建类型</span></span><br><span class="line">        initWith debug <span class="comment">// 继承至debug</span></span><br><span class="line">    &#125;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="literal">false</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过 <code>BuildVariants</code> 选项选取要编译的类型</p>
<p><img src="/2020/11/21/Android/Gradle%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B(BuildVariants).png"></p>
<p>也可通过配置对应文件夹进行代码配置，以执行不同的逻辑</p>
<p><img src="/2020/11/21/Android/Gradle%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/%E6%96%B9%E6%A1%88%E9%85%8D%E7%BD%AE.png"></p>
<h5 id="productFlavors"><a href="#productFlavors" class="headerlink" title="productFlavors"></a>productFlavors</h5><blockquote>
<p>多版本打包</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">flavorDimensions <span class="string">&#x27;paying&#x27;</span>,<span class="string">&#x27;nation&#x27;</span>	<span class="comment">// 分组</span></span><br><span class="line">productFlavors &#123; <span class="comment">// 构建版本</span></span><br><span class="line">    free &#123; <span class="comment">// 免费</span></span><br><span class="line">        dimension <span class="string">&#x27;paying&#x27;</span>	<span class="comment">// 所属组</span></span><br><span class="line">    &#125;</span><br><span class="line">    paid &#123; <span class="comment">// 付费</span></span><br><span class="line">        dimension <span class="string">&#x27;paying&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    china &#123; <span class="comment">// 中国版</span></span><br><span class="line">        dimension <span class="string">&#x27;nation&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    global &#123; <span class="comment">// 国际版</span></span><br><span class="line">        dimension <span class="string">&#x27;nation&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过 <code>BuildVariants</code> 选项选取要编译的类型</p>
<p>此时构建类型会有以下组合：<code>buildTypes</code>数量 *  <code>productFlavors</code>组1数量 * <code>productFlavors</code>组2数量</p>
<p><code>freeChinaDebug</code>、<code>freeChinaRelease</code>、<code>freeGlobalDebug</code> ……</p>
<p>跟<code>buildTypes</code>一样，同样可以通过配置对应文件夹进行代码配置，以执行不同的逻辑，文件夹名称以构建类型自由组合，如：<code>free</code>、<code>freeDebug</code>、<code>china</code>、<code>chinaDebug</code>、<code>freeChinaDebug</code>等等</p>
<p>这样就可以非常精细的配置类型</p>
<h5 id="task"><a href="#task" class="headerlink" title="task"></a>task</h5><blockquote>
<p>groovy 任务，被 task 声明的函数内部都属于配置项</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无论是执行 gradlew 还是执行 gradlew clean，都会打印 1、2 和 7</span></span><br><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    println <span class="number">1</span></span><br><span class="line">    delete rootProject.buildDir <span class="comment">// 这一行需要 gradlew clean 才回进行真正的delete，否则只是单纯的配置</span></span><br><span class="line">    println <span class="number">2</span></span><br><span class="line">    doFirst &#123;&#125; <span class="comment">// 需要 gradlew clean 才会执行</span></span><br><span class="line">    doLast &#123;&#125; <span class="comment">// 需要 gradlew clean 才会执行</span></span><br><span class="line">&#125;</span><br><span class="line">task test() &#123;</span><br><span class="line">    println <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先行任务<code>doFirst</code>：如果<code>task</code>有多个<code>doFirst</code>，第二个会插在第一个的前面，第三个插在第二个前面，以此类推</p>
<p>后续任务<code>doLast</code>：如果<code>task</code>有多个<code>doLast</code>，会在<code>doFirst</code>后面进行按顺序插入</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行 gradlew clean，会以1、2、7 和 5、3、4、6的形式打印</span></span><br><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">    println <span class="number">1</span></span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">    println <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task test() &#123;</span><br><span class="line">    println <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="task依赖"><a href="#task依赖" class="headerlink" title="task依赖"></a>task依赖</h5><blockquote>
<p>通过 dependsOn: task 的方式来依赖另一个任务，会先执行依赖任务再执行自身任务</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会先 打印 1、2 再打印 3、4</span></span><br><span class="line">task task1() &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task task2(<span class="attr">dependsOn:</span> task1) &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Gradle生命周期"><a href="#Gradle生命周期" class="headerlink" title="Gradle生命周期"></a>Gradle生命周期</h5><blockquote>
<p>三个阶段：初始化阶段（setting.gradle） -&gt; 定义阶段/配置阶段（build.gradle） -&gt; 执行阶段</p>
</blockquote>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler 原理</title>
    <url>/2020/11/15/Android/Handler%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Handler-原理"><a href="#Handler-原理" class="headerlink" title="Handler 原理"></a>Handler 原理</h1><ol>
<li><p><strong><code>Handler</code> 被设计出来的原因？有什么用？</strong></p>
<p>提供一种方便线程间通信的解决方案</p>
</li>
<li><p><strong><code>Handler</code> 的基本原理</strong></p>
<p>外部通过 <code>Handler</code> 往 <code>MessageQueue</code> 里插入任务<br><code>Looper</code> 在做死循环，一直从 <code>MessageQueue</code> 中获取任务<br>如果此时任务为空或当前没有需要执行的任务，则先判断 <code>IdleHandler</code>，<code>IdleHandler</code>为空则阻塞</p>
</li>
<li><p><strong>子线程中怎么使用 <code>Handler</code>，为什么我们在主线程不用做准备操作</strong></p>
<p><code>Looper.prepare()</code> 创建 <code>Looper</code> 并添加到 <code>ThreadLocal</code> 中<br><code>Looper.loop()</code> 开始死循环从 <code>MessageQueue</code> 获取消息<br>程序起来时在 <code>ActivityThread.main()</code> 方法以经初始化过，所以直接使用就行</p>
</li>
<li><p><strong>为什么建议使用 <code>Message.obtain()</code> 来创建 <code>Message</code> 实例</strong></p>
<p>对 <code>Message</code> 有效复用，可以有效的解决频繁创建 <code>Message</code> 实例问题</p>
</li>
<li><p><strong><code>MessageQueue</code> 获取消息是怎么等待</strong></p>
<p>通过 <code>epoll</code> 进行等待和唤醒<br>在 <code>next</code> 方法汇中，如果当前没有需要执行的任务，则调用 <code>nativePollOnce</code> 进行阻塞</p>
<p><strong><code>nextPollTimeoutMillis</code> 三种情况：</strong></p>
<ul>
<li><p>等于0，不阻塞立即返回</p>
</li>
<li><p>大于0，阻塞等待的时间</p>
</li>
<li><p>等于-1，无消息时会一直阻塞</p>
</li>
</ul>
<p><code>epoll</code> 机制是一种IO多路复用机制，具体逻辑是一个进程可以监视多个描述符，当某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作，这个读写操作是阻塞的，在 <code>Android</code> 中，会创建一个 <code>Linux</code>  管道来处理阻塞和唤醒</p>
<ul>
<li>当消息队列为空，管道的读端等待管道中有新内容可读，就会通过 <code>epoll</code> 机制进入阻塞状态</li>
<li>当有消息要处理，就会通过管道的写端写入内容，唤醒主线程</li>
</ul>
</li>
<li><p><strong>为什么不用 <code>wait</code> 而用 <code>epoll</code></strong></p>
<p>在 Android 2.2 及以前，使用的就是 wait/notify 进行等待，之后为了同时处理 <code>native</code> 侧的消息，改用了 <code>pipe/epoll</code> 机制</p>
<p>关于 select 、poll 、epoll，参考：<a href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw">https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw</a></p>
<p>【备注】在兼容 <code>native</code> 侧消息时，早期使用的是 <code>select</code>，后面才改成 <code>epoll</code>，参考commit：<a href="https://android.googlesource.com/platform/frameworks/base/+/46b9ac0ae2162309774a7478cd9d4e578747bfc2%5E%21/#F16">https://android.googlesource.com/platform/frameworks/base/+/46b9ac0ae2162309774a7478cd9d4e578747bfc2%5E%21/#F16</a></p>
</li>
<li><p><strong>线程和 <code>Handler</code> <code>Looper</code> <code>MessageQueue</code> 的关系</strong></p>
<p>一个线程对应一个 <code>MessageQueue</code> 、一个 <code>Looper</code> 、多个 <code>Handler</code></p>
</li>
<li><p><strong>多个线程给 <code>MessageQueue</code> 发消息，如何保证线程安全</strong></p>
<p>在 <code>enqueueMessage</code> 里进行了加锁</p>
</li>
<li><p><strong><code>Handler</code> 消息延迟是怎么处理的</strong></p>
<p>在插入任务时会将时间转换成距离开机时间的毫秒数，然后在 <code>MessageQueue</code> 中按时间顺序插入</p>
<p>在调用 <code>MessageQueue.next()</code> 中获取任务，如果还没有到达执行时间，先处理 <code>IdleHandler</code>，处理完后再 <code>nativePollOnce</code> 阻塞</p>
</li>
<li><p><strong><code>View.post</code> 和 <code>Handler.post</code> 的区别</strong></p>
<p><code>View.post</code> 时会判断有没有 <code>AttachInfo</code>，如果有则直接调用里面的 <code>Handler</code> 处理<br>如果没有则等待 <code>dispatchAttachedToWindow</code>，然后在通过 <code>Handler</code> 进行处理<br><code>dispatchAttachedToWindow</code> 函数是在 <code>ViewRootImpl</code> 的 <code>performTraversals</code> 中调用，<br>这也是为什么 <code>View.Post</code> 能够获取到 <code>View</code> 的宽高的原因，因为已经执行过 <code>performTraversals</code> 了</p>
</li>
<li><p><strong><code>Handler</code> 导致的内存泄漏</strong></p>
<p>匿名内部类持有外部类，Handler有延迟消息造成无法回收，这样就造成了外部类无法回收<br>方法一：静态内部类 + 弱引用<br>方法二：将该Handler的消息全部移除</p>
</li>
<li><p><strong>非 <code>UI</code> 线程真的不能操作 <code>View</code> 吗</strong></p>
<p>大部分情况是不可以的，因为在 <code>ViewRootImpl</code> 中的 <code>requestLayout</code> 会判断线程是否为创建线程，该创建线程默认就是 <code>UI</code> 线程<br>其它情况如：<code>ViewRootImpl</code> 未创建修改View，子线程创建 <code>ViewRootImpl</code>，或者修改 <code>View</code> 不会触发 <code>requestLayout</code> 的场景</p>
</li>
<li><p><strong><code>Looper</code> 在主线程死循环，为什么不会 <code>ANR</code></strong></p>
<p><code>ANR</code> 的原因是有任务在进行耗时操作，让本该执行的任务无法在合适的时间内执行<br>在于任务本身，而非死循环</p>
</li>
<li><p><strong>同步屏障和异步消息是怎么实现的</strong></p>
<ul>
<li><strong>同步消息</strong>：就是普通消息</li>
<li><strong>异步消息</strong>：通过 <code>setAsynchronous(true)</code> 设置的消息</li>
<li><strong>同步屏障消息</strong>：通过 <code>postSyncBarrier</code> 方法添加的消息，特点是 <code>target</code> 为空，即没有对应的 <code>handler</code></li>
</ul>
<p>三者关系</p>
<ul>
<li>正常情况下，同步消息和异步消息都是根据 <code>when</code> 来取消息，处理消息</li>
<li>当遇到同步屏障消息时，就开始从消息队列里找异步消息，找到了再根据时间决定阻塞还是返回消息</li>
</ul>
<p>同步屏障和异步消息存在的意义就是用于处理 “加急消息”</p>
<p>在 <code>ViewRootImpl.scheduleTraversals()</code> 中有具体应用</p>
</li>
<li><p><strong><code>Looper</code> 安全退出和非安全退出有什么区别</strong></p>
<ul>
<li>非安全退出：<code>removeAllMessagesLocked</code>，会直接清空所有未执行的消息</li>
<li>安全退出：<code>removeAllFutureMessagesLocked</code>，只清空延迟消息，非延迟消息继续处理</li>
</ul>
</li>
<li><p><strong><code>Message</code> 如何实现插队</strong></p>
<ul>
<li><code>sendMessageAtTime(msg, 0)</code> ，时间传0即可</li>
<li>如果不一定要插入队头，可以通过异步消息，也能实现一定的插队效果 <code>msg.setAsynchronous(true)</code></li>
</ul>
</li>
<li><p><strong>利用 <code>HanIder</code> 机制设计一个不崩溃的 <code>App</code></strong></p>
<ul>
<li><p>第一步：设置自己的异常捕捉处理者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler()</span><br></pre></td></tr></table></figure>

<p>此时子线程出现异常已经不会崩溃了</p>
<p>但是 <code>UI</code> 线程触发异常会让 <code>Looper.loop</code> 死循环退出，接下来的消息无法处理同样会让app卡死</p>
</li>
<li><p>第二步：对主线程异常进行捕获</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Handler(Looper.getMainLooper()).post &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Looper.loop()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>UI</code> 线程触发异常会被捕捉并重新 <code>Looper.loop()</code>，这样后续的消息又能继续处理，从而解决app崩溃异常</p>
</li>
<li><p>【注意：】经过上面两步确认解决了app崩溃的问题，但是如果在Activity的生命周期内触发异常，如 <code>onCreate</code> 中，则会出现黑屏白屏的情况，原因是生命周期内抛出异常，会导致界面无法完成， <code>Activity</code> 无法正确启动，就会出现黑屏白屏的情况。由于 <code>Activity</code> 的生命周期都是通过主线程的 <code>Handler</code> 进行处理的，可以通过反射 <code>ActivityThread</code> 中的 <code>Handler</code> 进行 <code>Activity</code> 生命周期异常捕获，然后进行 <code>finishActivity</code> 或者杀死进程的操作</p>
</li>
<li><p>【说明】第二步中可以理解为外部 <code>loop</code> 一直在等待 <code>post</code> 里的 <code>loop</code> 结束</p>
</li>
<li><p>【参考一：】<a href="https://juejin.cn/post/6904283635856179214">https://juejin.cn/post/6904283635856179214</a></p>
</li>
<li><p>【参考二：】<a href="https://github.com/android-notes/Cockroach/blob/master/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.md">https://github.com/android-notes/Cockroach/blob/master/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.md</a></p>
</li>
<li><p>【相关库：】<a href="https://github.com/android-notes/Cockroach">https://github.com/android-notes/Cockroach</a></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>RecycleView</title>
    <url>/2020/11/15/Android/RecycleView/</url>
    <content><![CDATA[<h1 id="RecycleView"><a href="#RecycleView" class="headerlink" title="RecycleView"></a>RecycleView</h1><blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s/auphzaQF6_wJx6dGFY6niA">https://mp.weixin.qq.com/s/auphzaQF6_wJx6dGFY6niA</a></p>
</blockquote>
<h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>在 <code>RecycleView</code> 的 <code>onMeasure</code> 阶段，默认采用自动测量模式，如果自身宽高不确定，<strong>会尝试通过 <code>LayoutManager</code> 测量子 <code>Item</code> 来确定自己的宽高</strong>，所以尽可能的使用 <code>match_parent</code> 或固定宽高来布局 <code>RecycleView</code>，<strong>减少性能的损耗</strong></p>
<p><strong>在 <code>RecycleView</code> 的 <code>onLayout</code> 阶段，才会真正调用调用 <code>LayoutManager.onLayoutChildren()</code> 来对 <code>Item</code> 进行测量和布局</strong></p>
<p>在 <code>LayoutManager.onLayoutChildren()</code> 方法中，会先通过 <code>detachAndScrapAttachedViews()</code> 函数回收布局，然后再通过 <code>file()</code> 函数进行布局，具体流程如下：</p>
<p><code>file() -&gt; layoutChunk() -&gt; LayoutState.next() -&gt; addView() -&gt; measureChildWithMargins() -&gt; layoutDecoratedWithMargins() </code></p>
<p>可以看到 <code>LayoutState.next()</code> 函数里最终调用 <code>tryGetViewHolderForPositionByDeadline()</code> 函数，然后通过 <code>Recyler</code> 四级缓存或创建来获取 <code>ViewHolder</code></p>
<p>从上面可以得出，会先回收布局，然后再从缓存中取出来，这里是不是没事找事做了？这里应该是一种职责分离吧，<code>layout</code> 的事归 <code>LayoutManager</code> 管，缓存的事归 <code>Recycler</code> 管。<code>LayoutManager</code> 不应该知道哪个 <code>viewHolder</code> 是否有效</p>
<p>可以看到 <code>RecycleView</code>为了提高效率，部分交互是通过 <code>attachViewToParent</code> 和 <code>detachViewFromParent</code> 来对 <code>View</code> 进行轻量级的添加和移除，<strong>其中 <code>attachViewToParent</code> 可以调整 <code>View</code> 的布局顺序，注意与 <code>getChildDrawingOrder</code> 的区别</strong></p>
<p>【备注一】<code>detach</code> 在 <code>ViewGroup</code> 中的实现很简单，只是将当前 <code>View</code> 从 <code>ParentView</code> 的 <code>ChildView</code> 数组中移除，将当前 <code>View</code> 的 <code>mParent</code> 设置为null, 可以理解为轻量级的临时 <code>remove</code>。</p>
<p>【备注二】<code>remove</code> 代表真正的移除，不光从 <code>ChildView</code> 数组中移除，其他和View树各项联系也会被彻底斩断。</p>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ul>
<li><code>LayoutManager</code>：负责 <code>item</code> 的 <code>measure</code> 、<code>layout</code></li>
<li><code>Recycler</code>：四级回收、复用机制</li>
<li><code>SmoothScroller</code>：滑动速度控制<ul>
<li><code>LinearSmoothScroller</code></li>
</ul>
</li>
<li><code>SnapHelper</code>：惯性滑动控制<ul>
<li><code>LinearSnapHelper</code></li>
<li><code>PagerSnapHelper</code></li>
</ul>
</li>
<li><code>ItemAnimator</code>：<code>Item</code> 动画<ul>
<li><code>SimpleItemAnimator</code></li>
<li><code>DefaultlteAnimator</code></li>
</ul>
</li>
<li><code>ItemDecoration</code>：<code>Item</code> 样式装饰<ul>
<li><code>DividerItemDecoration</code></li>
<li><code>ItemTouchHelper</code>：可以实现侧滑删除，拖动排序</li>
<li>可以扩展吸点悬浮的效果</li>
</ul>
</li>
<li><code>OnItemTouchListener</code>：手势拦截器</li>
<li><code>DiffUtil</code>：差分刷新</li>
</ul>
<h4 id="Recyler-回收池-RecycleView-四级缓存"><a href="#Recyler-回收池-RecycleView-四级缓存" class="headerlink" title="Recyler 回收池 - RecycleView 四级缓存"></a><code>Recyler</code> 回收池 - <code>RecycleView</code> 四级缓存</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Recycler</span> </span>&#123;</span><br><span class="line">	<span class="comment">// #1 屏幕内，复用时不需要重新bindViewHolder，因为还会出现在屏幕上面，数据和状态是不会重置的</span></span><br><span class="line">    ArrayList&lt;ViewHolder&gt; mAttachedScrap;</span><br><span class="line">    <span class="comment">// 屏幕上发生变化的会放入changed中，其余放入到attached中</span></span><br><span class="line">    ArrayList&lt;ViewHolder&gt; mChangedScrap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2 划出屏幕，默认大小为2，划出去的item存放在这里，再次划进屏幕也是不需要重新绑定数据的；通过setItemViewCacheSize()这个方法调整它的大小</span></span><br><span class="line">    ArrayList&lt;ViewHolder&gt; mCachedViews;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3 自定义扩展View缓存，允许开发者自定义缓存逻辑，当一二级缓存未命中时会调用该缓存；</span></span><br><span class="line">    <span class="comment">//    注意：该扩展缓存限制较多，因为RecyclerView不知道你创建的viewHolder</span></span><br><span class="line">    ViewCacheExtension mViewCacheExtension;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4 根据viewType存取ViewHolder，当mCachedViews放不下时会缓存到此</span></span><br><span class="line">    <span class="comment">//    可通过setRecycledViewPool调整，每个类型容量默认为5</span></span><br><span class="line">    RecycledViewPool mRecyclerPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><ol>
<li><p>当我们调用 <code>notifyDataSetChanged()</code> 或 <code>notifyItemRangeChanged(p, c) </code> (c这个范围非常大的时候)，会将所有的 <code>ViewHolder</code> 全部放入到 <code>pool</code> 中，即第四级缓存中，由于第四级缓存默认大小为5，所以当界面显示的数量大于5时，会出现丢弃的情况，造成需要重新 <code>craete</code> 和 <code>bind</code> 来补充缺失的 <code>item</code>，对性能影响比较大(<code>notifyItemRangeChanged</code> 哪怕超出屏幕的 <code>item</code> 都会尝试 <code>create</code> 和 <code>bind</code>，同样性能损耗较大)。如果列表显示很多行，且 <code>notifyDataSetChanged()</code> 函数调用较为频繁，可以考虑设置 <code>pool</code> 的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">recyclerView.getRecycledViewPool().setMaxRecycledViews(<span class="number">0</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>或者给条目设置全局ID：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adapter 中复写</span></span><br><span class="line"><span class="function">override fun <span class="title">getItemId</span><span class="params">(position: Int)</span>: Long </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position.toLong()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mAdapter.setHasStableIds(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>当知道 <code>Item</code> 的改变不会影响到 <code>RecycleView</code> 的宽高时，可以通过 <code>setHasFixedSize(true)</code> 函数增加提高增删改插时的性能，原因如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onItemRangeChanged</span></span><br><span class="line"><span class="comment">// onItemRangeRemoved</span></span><br><span class="line"><span class="comment">// onItemRangeMoved</span></span><br><span class="line"><span class="comment">// onItemRangeInserted</span></span><br><span class="line"><span class="comment">// 当 mHasFixedSize = true 时，上述四种方法都不会触发 requestLayout 重新布局</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triggerUpdateProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123;</span><br><span class="line">        ViewCompat.postOnAnimation(RecyclerView.<span class="keyword">this</span>, mUpdateChildViewsRunnable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAdapterUpdateDuringMeasure = <span class="keyword">true</span>;</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】<code>notifyDataSetChanged()</code> 最终会触发 <code>onChanged()</code> 并调用 <code>requestLayout()</code> 重新测量布局</p>
</li>
<li><p>数据预取， <code>Android 5.0</code> 起，显示分为两个阶段：</p>
<ol>
<li>UI线程先处理布局信息，即创建和绑定View</li>
<li>渲染(Render)线程把指令发送给GPU</li>
</ol>
<p>在不卡顿的前提下，帧与帧之间UI线程会有闲置的时机，<code>RecycleView</code> 在新条目即将进入视野前，会花大量的时间来创建和绑定 <code>View</code>，造成下一帧出现卡顿，数据预取的思想就是利用闲置的线程，提前将下一帧创建和绑定 <code>View</code> 的工作移至前一帧的空闲时间来完成。</p>
<p>如果使用 <code>RecycleView</code> 内部的 <code>LayoutManager</code>，已经自动优化了。</p>
<p>需要手动优化有以下两种场景：</p>
<ol>
<li>嵌套 <code>RecyclerView</code>：内部的 <code>LayoutManager</code> 需要调用  <code>LinearLayoutManager#setInitialPrefetchItemCount</code> 来设置预存取的数量，如：至少展示三个条目，则需要传入4</li>
<li>自定义 <code>LayoutManager</code>：需要重写 <code>LayoutManager#collectInitialPrefetchPositions</code> 方法实现预取逻辑，参考：<a href="https://juejin.cn/post/6844903661382959118">https://juejin.cn/post/6844903661382959118</a></li>
</ol>
</li>
<li><p>在 <code>TabLayout+ViewPager+RecyclerView</code> 的场景中，多个界面的条目布局是一致的，可以考虑多个 <code>RecyclerView</code> 共用一个 <code>RecycledViewPool</code> 来减少创建 <code>ViewHolder</code> 的开销</p>
</li>
<li><p>在条目中需要加载图片等场景，滚动时加载或只加载内存中的图片</p>
</li>
<li><p>尽可能的使用局部刷新函数，善用 <code>DiffUtil</code></p>
</li>
<li><p>避免在 <code>onCreate</code> 和 <code>onBind</code> 中创建过多对象</p>
</li>
<li><p><code>RecycleView</code> 和 <code>Item</code> 尽可能的不要使用 <code>wrap_content</code></p>
</li>
<li><p>不要在 <code>ScrollView</code> 中添加 <code>RecycleView</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>原理</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>SparseArray和ArrayMap</title>
    <url>/2020/11/15/Android/SparseArray%E5%92%8CArrayMap/</url>
    <content><![CDATA[<h1 id="SparseArray和ArrayMap"><a href="#SparseArray和ArrayMap" class="headerlink" title="SparseArray和ArrayMap"></a>SparseArray和ArrayMap</h1><h5 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h5><ol>
<li>以双数组键值分开的形式存储，基于二分查找获取数据；</li>
<li>采用int作为Key，避免了HashMap的装箱拆箱操作，同时它的数据结构不需要额外的Entry对象</li>
<li>采用了延迟删除的机制（针对数组删除位移问题的优化），在remove时把目标值标记为delete，在下次有符合的值直接放到该位置，就没有位移了</li>
</ol>
<h5 id="SparseArray与HashMap比较"><a href="#SparseArray与HashMap比较" class="headerlink" title="SparseArray与HashMap比较"></a>SparseArray与HashMap比较</h5><ol>
<li>查询效率：在少量数据上区别不大，但在数量以万为单位时，HashMap更优一点</li>
<li>正序插入：效率比HashMap更快且更省内存</li>
<li>倒序插入：为保证有序，需要对数组里的数据后移，效率最差，HashMap无论正序还是倒序都只需要处理哈希冲突，效率更高</li>
</ol>
<p><strong>总结</strong></p>
<p>SparseArray是以时间换空间的一种存储方式，在key为整形、元素相对较少的情况下建议使用</p>
<h5 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h5><blockquote>
<p>为了节省内存有更加保守的内存扩张以及内存收缩策略</p>
</blockquote>
<p><img src="/2020/11/15/Android/SparseArray%E5%92%8CArrayMap/ArrayMap.jpg"></p>
<ol>
<li>同样采用双数组的形式存储，mHashes记录所有key的hashcode组成的数组，从小到大排序，采用二分查找</li>
<li>mArray记录着key-value键值组成的数组，为mHashes大小的2倍；</li>
<li>以追加的形式解决追加的方式，后面的数据全部后移一位</li>
<li>有两个缓存数组：mBaseCache（大小为4）、mTwiceBaseCacheSize（大小为8），都是分别超过10个不再缓存</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>原理</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>View 的绘制流程及原理</title>
    <url>/2020/11/14/Android/View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="View"><a href="#View" class="headerlink" title="View"></a>View</h1><h4 id="View-是如何被添加到屏幕窗口上"><a href="#View-是如何被添加到屏幕窗口上" class="headerlink" title="View 是如何被添加到屏幕窗口上"></a>View 是如何被添加到屏幕窗口上</h4><p>当我们在调用 <code>Activity#setContentView(int layoutResID)</code> 时，实际上调用的是 <code>PhoneWindow#setContentView(int layoutResID)</code><br><code>PhoneWindow</code> 流程代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    installDecor(); <span class="comment">// 初始化DecorView和content父布局</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent); <span class="comment">// 将我们的布局文件加载到content父布局</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... 根据主题获取对应的布局</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); <span class="comment">// 【注】这里既然使用mDecor为啥还要传入参数decor ...</span></span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); <span class="comment">// 通过全局ID获取content父布局</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AppCompatActivity#setContentView(int resId)</code> 兼容实际上调用的是 <code>AppCompatDelegateImpl#setContentView(int resId)</code><br><code>AppCompatDelegateImpl</code> 流程代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureSubDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSubDecorInstalled) &#123;</span><br><span class="line">        mSubDecor = createSubDecor();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ViewGroup <span class="title">createSubDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... 根据主题获取subDecor</span></span><br><span class="line">    <span class="keyword">final</span> ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById(</span><br><span class="line">            R.id.action_bar_activity_content);</span><br><span class="line">    <span class="keyword">final</span> ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content);</span><br><span class="line">    <span class="keyword">if</span> (windowContentView != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// ... 将原生的content父布局替换成subDecor的父布局</span></span><br><span class="line">        windowContentView.setId(View.NO_ID);</span><br><span class="line">        contentView.setId(android.R.id.content);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    mWindow.setContentView(subDecor); <span class="comment">// 将兼容布局设置到PhoneWindow</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> subDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="View-的绘制流程"><a href="#View-的绘制流程" class="headerlink" title="View 的绘制流程"></a>View 的绘制流程</h4><ul>
<li><p>绘制入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActivityThread.handleResumeActivity</span><br><span class="line">--&gt; WindowManagerImpl.addView()</span><br><span class="line">--&gt; WindowManagerGlobal.addView() --&gt; <span class="keyword">new</span> ViewRootImpl() <span class="comment">// 在创建ViewRootImpl时创建Surface</span></span><br></pre></td></tr></table></figure></li>
<li><p>绘制的类及方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewRootImpl.setView()</span><br><span class="line">--&gt; ViewRootImpl.requestLayout()</span><br><span class="line">--&gt; ViewRootImpl.scheduleTraversals() <span class="comment">// 这里会插入同步屏障postSyncBarrier</span></span><br><span class="line">	<span class="comment">// 这里等待Choreographer$FrameDisplayEventReceiver接收到Vsync信号进行回调</span></span><br><span class="line">--&gt; ViewRootImpl.doTraversal()</span><br><span class="line">--&gt; ViewRootImpl.performTraversals()</span><br></pre></td></tr></table></figure></li>
<li><p>绘制三大步骤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">测量：ViewRootImpl.performMeasure -&gt; view.onMeasure -&gt; view.setMeasuredDimension -&gt; view.setMeasuredDimensionRaw</span><br><span class="line">布局：ViewRootImpl.performLayout -&gt; view.layout -&gt; view.onLayout</span><br><span class="line">绘制：ViewRootImpl.performDraw -&gt; ViewRootImpl.draw -&gt; ViewRootImpl.drawSoftware -&gt; view.draw <span class="comment">// trackFPS、lockCanvas、unlockCanvasAndPost</span></span><br></pre></td></tr></table></figure></li>
<li><p>Measure类型</p>
<ul>
<li>EXACTLY：固定大小，父容器检测出子 View 的大小【match_parent、<code>dp/px</code>】</li>
<li>AT_MOST：最大大小，父容器指定一个可用大小，View的大小不能超过该值【wrap_content】</li>
<li>UNSPECIFIED：不对 View 做任何限制，系统内部使用</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><code>childLayoutParams\parentSpecMode</code></th>
<th align="center">EXACTLY</th>
<th align="center">AT_MOST</th>
<th align="center">UNSPECIFIED</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>dp/px</code></td>
<td align="center"><code>EXACTLY/childSize</code></td>
<td align="center"><code>EXACTLY/childSize</code></td>
<td align="center"><code>EXACTLY/childSize</code></td>
</tr>
<tr>
<td align="center">match_parent</td>
<td align="center"><code>EXACTLY/parentSize</code></td>
<td align="center"><code>AT_MOST/parentSize</code></td>
<td align="center"><code>UNSPECIFIED/0</code></td>
</tr>
<tr>
<td align="center">wrap_content</td>
<td align="center"><code>AT_MOST/parentSize</code></td>
<td align="center"><code>AT_MOST/parentSize</code></td>
<td align="center"><code>UNSPECIFIED/0</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize; <span class="comment">// 这也是为什么View大小wrap_content和match_parent的原因</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant Activity</span><br><span class="line">participant PhoneWindow</span><br><span class="line">participant DecorView</span><br><span class="line">participant ViewGroup</span><br><span class="line">participant View</span><br><span class="line"></span><br><span class="line">Activity -&gt; PhoneWindow:superDispatchTouchEvent()</span><br><span class="line">PhoneWindow -&gt; DecorView:superDispatchTouchEvent()</span><br><span class="line">DecorView -&gt; ViewGroup:dispatchTouchEvent()</span><br><span class="line">ViewGroup -&gt; ViewGroup:onInterceptTouchEvent()</span><br><span class="line">ViewGroup -&gt; View:onTouchEvent()</span><br><span class="line">View -&gt; ViewGroup:return false</span><br><span class="line">ViewGroup -&gt; DecorView:return false</span><br><span class="line">DecorView -&gt; PhoneWindow:return false</span><br><span class="line">PhoneWindow -&gt; Activity:return false</span><br><span class="line">Activity -&gt; Activity:onTouchEvent()</span><br></pre></td></tr></table></figure>

<p><code>dispatchTouchEvent</code>：是否分发</p>
<p><code>onInterceptTouchEvent</code>：是否拦截</p>
<p><code>onTouchEvent</code>：是否消费</p>
<h5 id="事件分发流程"><a href="#事件分发流程" class="headerlink" title="事件分发流程"></a>事件分发流程</h5><p>当屏幕被触摸，首先会通过硬件产生触摸事件传入内核，然后走到 <code>FrameWork</code> 层（具体流程感兴趣的可以看看参考链接），最后经过一系列事件处理到达<code>ViewRootImpl</code> 的 <code>processPointerEvent</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//mView分发Touch事件，mView就是DecorView</span></span><br><span class="line">        <span class="keyword">boolean</span> handled = mView.dispatchPointerEvent(event);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DecorView.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">        <span class="comment">//分发Touch事件</span></span><br><span class="line">        <span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cb其实就是对应的Activity</span></span><br><span class="line">    <span class="keyword">final</span> Window.Callback cb = mWindow.getCallback();</span><br><span class="line">    <span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></span><br><span class="line">            ? cb.dispatchTouchEvent(ev) : <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PhoneWindow.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DecorView.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>事件的分发流程就比较清楚了：</p>
<p><code>ViewRootImpl --&gt; DecorView --&gt; Activity --&gt; PhoneWindow --&gt; DecorView --&gt; ViewGroup</code></p>
<p>这里绕来绕去主要原因在于解耦：</p>
<ul>
<li><code>ViewRootImpl</code>并不知道有Activity这种东西存在，它只是持有了 <code>DecorView</code>。所以先传给了 <code>DecorView</code>，而 <code>DecorView</code> 知道有AC，所以传给了AC。</li>
<li><code>Activity</code>也不知道有 <code>DecorView</code>，它只是持有 <code>PhoneWindow</code>，所以这么一段调用链就形成了。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>原理</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2020/11/14/Git/Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h5 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h5><p><strong>分支：</strong>一个指向特定提交记录的<strong>引用</strong></p>
<p><strong>指针：</strong>当前操作位置的<strong>引用</strong></p>
<p><strong>本地指针：</strong>我们能操作位置的引用</p>
<img src="/2020/11/14/Git/Git/仓库说明.png">



<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><ol>
<li><p>拉取分支</p>
<p><code>git clone [url] &lt;目录名&gt;</code></p>
</li>
<li><p>推送变更到远程仓库</p>
<p><code>git push</code></p>
<p><img src="/2020/11/14/Git/Git/push.png"></p>
<p>注意：如上图所示，将 4 推送到仓库需要 <code>remote</code> 仓库的 <code>HEAD</code> 指向非 <code>master</code> 分支或指向 <code>hash</code></p>
</li>
<li><p>将远端镜像更新到本地【注：本地head指向并没有发生改变】</p>
<p><code>git fetch</code></p>
<p><img src="/2020/11/14/Git/Git/fetch.png"></p>
<p>需要手动合并分支：<code>git merge origin/[分支名]</code></p>
</li>
<li><p>获取变更并合并【注：本地head会指向最新变更】</p>
<p><code>git pull</code></p>
<p>相当于：<code>git fetch</code>和<code>git merge origin/[分支名]</code></p>
</li>
<li><p>分支</p>
<p>创建分支：<code>git branch [分支名]</code></p>
<p>切换分支：<code>git checkout [分支名]</code></p>
<p><code>HEAD</code>指向提交记录：<code>git checkout [hash]/--detach</code>，该操作会直接让<code>HEAD</code>直接指向<code>hash</code></p>
<p>创建分支并切换：<code>git checkout &lt;远程分支名&gt; -b [分支名]</code></p>
<p>删除分支：<code>git branch -d [分支名]</code></p>
<p>切换远程分支：<code>git checkout [远程分支名]</code>，注意该切换会直接将<code>HEAD指针</code>指向<code>hash</code>，如下图</p>
<p><img src="/2020/11/14/Git/Git/checkout.png"></p>
</li>
<li><p>暂存区</p>
<p>添加到暂存区：<code>git add [文件路径]/[.]</code></p>
<p>交互式add，允许提交文件内容的一部分：<code>git add -i</code></p>
<p>移除暂存区：<code>git restore --staged [文件路径]/[.]</code></p>
<p>还原文件：<code>git restore [文件路径]</code> 或 <code>git checkout [文件路径]</code></p>
</li>
<li><p>提交变更</p>
<p><code>git commit -m &quot;描述&quot;</code></p>
<p>替换最新变更：<code>git commit --amend</code></p>
<p><img src="/2020/11/14/Git/Git/amend.png"></p>
<p>通过 <code>--amend</code> 命令将 <code>master</code> 引用指向新的提交，上图为 <code>4</code> 变更为 <code>4&#39;</code></p>
<p>当 <code>--amend</code> 命令触发 <code>COMMIT_EDITMSG</code> 编辑时，可通过 <code>ESC</code> 推出编辑模式，然后按两次大写 <code>Z</code>退出</p>
</li>
<li><p>合并分支</p>
<p><code>git merge [分支名]</code></p>
<p>当merge发生冲突并解决时：<code>git add .</code> 然后 <code>git merge --continue</code></p>
<p>非<code>Fast-forward</code>合并：<code>git merge [分支名] --no-ff</code></p>
<p><img src="/2020/11/14/Git/Git/merge.png"></p>
</li>
<li><p>reset 引用回退</p>
<p><code>git reset &lt;mode&gt; [hash]</code></p>
<p>mode 类型有：</p>
<ul>
<li>–soft：使分支和<code>HEAD</code>回退到指定<code>commit</code>并保留所有变更在<strong>非暂存区</strong></li>
<li>–mixed 默认模式：使分支和<code>HEAD</code>回退到指定<code>commit</code>并保留所有变更在<strong>暂存区</strong></li>
<li>–hard：使分支和<code>HEAD</code>回退到指定<code>commit</code>并移除所有变更</li>
</ul>
<p>注意：可以通过<code>reset</code>回退到<code>git reflog</code>里的任意记录</p>
</li>
<li><p>rebase 调整提交过程</p>
<p><code>git rebase [分支名]/[hash]</code></p>
<p><img src="/2020/11/14/Git/Git/rebase.png"></p>
<p>如果想将branch的提交记录变更为：<code>1 - 2 - 3 - a - 4 - 5</code> 的形式</p>
<p>通过 <code>git rebase master</code> 进行调整</p>
<p>当 <code>rebase</code> 发生冲突并解决时【注：再次冲突重复冲突操作即可】</p>
<p><code>git add .</code></p>
<p><code>git rebase --continue</code></p>
<p>修改提交历史，即代码有没有冲突，都要求一步一步编辑历史，如：<code>3 - 4 - 5</code></p>
<p><code>git rebase -i [分支名]/[hash]</code></p>
<p>会要求对每一步都进行类冲突处理</p>
</li>
<li><p>revert 反向操作，会全部还原成指定hash的前一个提交的状态</p>
<p><code>git revert [分支名]/[hash]</code></p>
</li>
<li><p>获取其它分支的提交内容</p>
<p><code>git cherry-pick [hash1、hash2、hash3]</code></p>
</li>
<li><p>查看差异</p>
<p><code>git diff</code>：查看未缓存的改动</p>
<p><code>git diff --staged</code>：查看缓存区与 <code>HEAD</code> 的改动</p>
<p><code>git dif [hash1] [hash2]</code>：对比两次提交的差异</p>
</li>
<li><p>查看日志</p>
<p><code>git log &lt;--oneline&gt; &lt;--pretty=oneline&gt; &lt;--graph&gt; &lt;--all&gt;</code></p>
</li>
<li><p>查看状态</p>
<p><code>git status</code></p>
</li>
<li><p>查看提交的内容</p>
<p><code>git show [hash]</code></p>
</li>
<li><p>创建 tag</p>
<p><code>git tag [tag名称] &lt;-a&gt;</code></p>
<p>-a 选项为增加描述</p>
</li>
<li><p>查看引用历史</p>
<p><code>git reflog</code></p>
</li>
</ol>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ol>
<li><p>查看配置</p>
<p><code>git config --list</code></p>
</li>
<li><p>查看用户名</p>
<p><code>git config user.name</code></p>
</li>
<li><p>查看邮箱</p>
<p><code>git config user.email</code></p>
</li>
<li><p>全局配置用户名</p>
<p><code>git config --global user.name &quot;name&quot;</code></p>
</li>
<li><p>全局配置邮箱</p>
<p><code>git config --global user.email &quot;eamil@gmail.com&quot;</code></p>
</li>
</ol>
<h5 id="扩展-得练习并验证"><a href="#扩展-得练习并验证" class="headerlink" title="扩展(得练习并验证)"></a>扩展(得练习并验证)</h5><ol>
<li><p>给本地仓库添加远程仓库【注：该远程仓库可以是其它本地仓库或其它电脑的仓库】</p>
<p><code>git remote add &lt;给个远端仓库名&gt; &lt;名称&gt;@&lt;ip&gt;:&lt;远端仓库目录&gt;</code></p>
<p><code>git push &lt;远端仓库名&gt; &lt;分支&gt;:&lt;分支&gt;</code>：得验证分支到底那个是创建，那个是本地</p>
</li>
</ol>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>提交完发现写错了？</p>
<ol>
<li>第一种：刚提交完，发现有错<ul>
<li><code>git commit --amend</code></li>
</ul>
</li>
<li>第二种：非最新提交，发现有错<ul>
<li><code>git rebase [hash]</code></li>
</ul>
</li>
<li>第三种：已经push到远程仓库，发现有错<ul>
<li><code>git revert [hash]</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术卷一基础知识-笔记</title>
    <url>/2020/09/13/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ol>
<li>已经清楚或能够估计出元素容量，可以在添加元素前调用【ensureCapacity(100)】函数，或在构造函数中传入【new ArrayList&lt;&gt;(100)】</li>
<li>添加完元素后明确不再添加任何元素时，可调用【trimToSize()】，以释放多余空间</li>
</ol>
<h5 id="带资源try语句"><a href="#带资源try语句" class="headerlink" title="带资源try语句"></a>带资源try语句</h5><p>普通try-catch方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//open a resource</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// catch error</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//close the resource</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缺点：</span></span><br><span class="line"><span class="comment">//     当try块发生非catch能处理的异常，如果此时finally块也发生异常，那么会丢失原始异常，转而抛出finally产生的异常</span></span><br><span class="line"><span class="comment">//     这样会有一个问题，如果需要将try块的异常向外抛出，需要对try块异常通过变量存起来，并在finally中判断是否需要向外抛出</span></span><br></pre></td></tr></table></figure>

<p>带资源try方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Recource res = ...) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     资源需要属于AutoCloseable的子接口的子类才能使用这种方式，其中Closeable接口为AutoCloseable的子接口</span></span><br><span class="line"><span class="comment">//     try块正常退出或者存在一个异常时，都会自动调用res.close()方法，同时还可以指定多个资源</span></span><br><span class="line"><span class="keyword">try</span>(InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     上面提到，原始try-catch方式当try抛出异常，finally块也抛出异常，会产生一个难题</span></span><br><span class="line"><span class="comment">//     带资源的try方式能很好的处理这种情况，原来的异常会重新抛出，close产生的异常会被try异常通过addSuppressed添加进去，该过程称为“抑制”</span></span><br><span class="line"><span class="comment">//     如果对close产生的异常感兴趣，可以调用getSuppressed获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>(Recource res = ...) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// catch error</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// do finally block</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     带资源的try语句同样也可以添加catch子句和finally子句</span></span><br><span class="line"><span class="comment">//     执行顺序为 try块 -&gt; close -&gt; catch块(如果有异常的话) -&gt; finally块</span></span><br></pre></td></tr></table></figure>



<h5 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以获取所有线程的堆栈轨迹</span></span><br><span class="line">Thread.getAllStackTraces();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印堆栈轨迹：内部实际是new Exception(&quot;Stack trace&quot;).printStackTrace();</span></span><br><span class="line">Thread.dumpStack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常捕获处理顺序：线程 -&gt; 线程对象 -&gt; 未捕获异常Handler</span></span><br><span class="line"><span class="comment">// 设置未捕获异常处理器，用于捕获线程未捕获的异常</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个“抑制”异常，如在带资源try中会出现</span></span><br><span class="line">addSuppressed(Throwable t)</span><br><span class="line"><span class="comment">// 将该异常对象设置为“原因”</span></span><br><span class="line">initCause(Throwable t)</span><br><span class="line"><span class="comment">// 例：</span></span><br><span class="line"><span class="keyword">try</span>&#123;&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    Exception r = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    r.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Java日志"><a href="#Java日志" class="headerlink" title="Java日志"></a>Java日志</h5><p>全局日志记录器：<br><code>Logger.getGlobal().info(&quot;msg&quot;);</code></p>
<p>自定义日志记录器：<br><code>private static final Logger myLogger = Logger.getLogger(&quot;com.mycompany.myapp&quot;);</code></p>
<h5 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h5><blockquote>
<p>消除函数调用,采用类变量直接访问，可以减少函数栈的调用，提高效率</p>
<p>从【c.getName()】 变更为【c.name】的形式</p>
</blockquote>
<p>即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“ 内联”）。即时编译器知道那些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。</p>
<p>是否将某个方法设置为内联方法是Java 虚拟机的任务。即时编译器会监视调用那些<strong>简洁</strong>、<strong>经常被调用</strong>、<strong>没有被重载</strong>以及<strong>可优化</strong>的方法。</p>
<p>在早期的Java 中， 有些程序员为了避免动态绑定带来的系统开销而使用final 关键字。如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理， 这个过程为称为内联( inlining )。例如，内联调用e.getName( ) 将被替换为访问e.name 域。这是一项很有意义的改进， 这是由于CPU 在处理调用方法的指令时， 使用的分支转移会扰乱预取指令的策略， 所以，这被视为不受欢迎的。然而， 如果getName 在另外一个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作， 因此也就不能对它进行内联处理了。</p>
<p>幸运的是， 虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系， 并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正地被覆盖， 那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖， 那么将会发生什么情况呢？ 优化器将取消对覆盖方法的内联。这个过程很慢， 但却很少发生。</p>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TestEnum</span> </span>&#123;</span><br><span class="line">    Red(<span class="string">&quot;red&quot;</span>), Blue(<span class="string">&quot;blue&quot;</span>), Green(<span class="string">&quot;green&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    TestEnum(String color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnum</span> <span class="keyword">extends</span> <span class="title">Enum</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestEnum[] values()&#123;</span><br><span class="line">        <span class="keyword">return</span> (TestEnum[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestEnum <span class="title">valueOf</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (TestEnum)Enum.valueOf(com/benben/TestEnum, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestEnum</span><span class="params">(String s, <span class="keyword">int</span> i, String s1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        mColor = s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Red;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Blue;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Green;</span><br><span class="line">    <span class="keyword">private</span> String mColor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum $VALUES[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Red = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Red&quot;</span>, <span class="number">0</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        Blue = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Blue&quot;</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        Green = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Green&quot;</span>, <span class="number">2</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> TestEnum[] &#123;</span><br><span class="line">            Red, Blue, Green</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意一：从上面可以看出，枚举会消耗更多的内存，类似于饿汉式的单例</strong></p>
<p><strong>注意二：Proguard以及Android的R8也会对简单的枚举（即不实现接口也没有额外成员的枚举）做优化</strong></p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><blockquote>
<p>对于final的基本变量类型，在编译字节码的时候会被认为不会再改变，会将值直接放入调用处，所以反射对它无效</p>
<p>如果是static final的基本变量类型，修改值会产生异常，必须要修改可以再反射修改它的<code>modifiers</code>值以达到能修改的目的，注意：目前jvm并没有对该字段有限制</p>
</blockquote>
<h5 id="反射效率低"><a href="#反射效率低" class="headerlink" title="反射效率低"></a>反射效率低</h5><p>java反射效率低的主要原因是：</p>
<ol>
<li>Method#invoke 方法会对参数做封装和解封操作</li>
<li>需要检查方法可见性。原因：反射时每次调用都必须检查方法的可见性（在Method.invoke里）</li>
<li>需要校验参数。反射时也必须检查每个实际参数与形式参数的类型匹配性（在NativeMethodAccessorImpl.invoke0 里或者生成的 Java 版 MethodAccessor.invoke 里）</li>
<li>反射方法难以内联。参考：<a href="https://www.iteye.com/blog/rednaxelafx-548536">https://www.iteye.com/blog/rednaxelafx-548536</a></li>
<li>JIT 无法优化。原因：因为涉及到动态解析的类型，所以无法优化</li>
</ol>
<p>提高反射性能的方式：</p>
<ol>
<li>将反射获取到的类，构造函数，函数，对象实例缓存起来，不用每次都全新查找</li>
<li>可通过调用method.setAccessible(true)的方式来关闭Method.invoke可见性检查</li>
<li>需要更极致的提高效率可以通过字节码生成的方式来实现反射机制。参考：<a href="https://github.com/EsotericSoftware/reflectasm">https://github.com/EsotericSoftware/reflectasm</a></li>
</ol>
<h5 id="Lambda高阶参考"><a href="#Lambda高阶参考" class="headerlink" title="Lambda高阶参考"></a>Lambda高阶参考</h5><p><a href="https://baijiahao.baidu.com/s?id=1606476168883238803&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1606476168883238803&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术卷二高级特性-笔记</title>
    <url>/2020/09/18/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%BA%8C%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h5 id="Java-SE-8-流库"><a href="#Java-SE-8-流库" class="headerlink" title="Java SE 8 流库"></a>Java SE 8 流库</h5><blockquote>
<p>参考：<a href="https://blog.csdn.net/Al_assad/article/details/82356845">https://blog.csdn.net/Al_assad/article/details/82356845</a></p>
</blockquote>
<h5 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h5><ul>
<li>重点关注内存映射：<code>FileChannel</code></li>
</ul>
<h5 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h5><ul>
<li><code>Date</code></li>
<li><code>SimpleDateFormat</code> 和 <code>Calendar</code></li>
<li><code>LocalDateTime</code> 和 <code>DateTimeFormatter</code></li>
</ul>
<h5 id="Shocket-通讯"><a href="#Shocket-通讯" class="headerlink" title="Shocket 通讯"></a>Shocket 通讯</h5><ul>
<li><code>Socket</code> 和 <code>ServerSocket</code></li>
<li><code>URL</code> 和 <code>HttpURLConnection</code></li>
<li>重点关注可中断套接字：<code>SocketChannel</code>、<code>Channels.newInputStream</code> 、 <code>Channels.newOutputStream</code>、<code>DatagramChannel</code>、<code>MulticastChannel</code></li>
<li>UDP通讯：<code>DatagramSocket</code>和<code>DatagramPacket</code>【只允许发送到指定目标地址】</li>
<li>UDP 多点通讯：<code>MulticastSocket</code>【组播】</li>
</ul>
<h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h5><p>每个Java程序至少拥有三个类加载器，除引导类加载器外，每个类加载器都有父类加载器【注：双亲委派机制】</p>
<ul>
<li><p>引导类加载器【通常由C语言实现】</p>
</li>
<li><p>扩展类加载器【用于加载<code>jre/lib/ext</code>类文件】</p>
</li>
<li><p>系统类加载器（又名应用类加载器）【用于加载应用类文件】</p>
</li>
<li><p>自定义类加载器</p>
<p>需要重写<code>findClass</code>函数，在超类的<code>loadClass</code>委托其父类加载器加载失败时会调用<code>findClass</code>方法</p>
<p>在<code>findClass</code>函数内加载到类数据时需要调用超类<code>defineClass</code>方法，向虚拟机提供字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = ...;<span class="comment">// 加载类字节码数据</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name,classData,off,len);<span class="comment">// 加载字节码并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="消息摘要"><a href="#消息摘要" class="headerlink" title="消息摘要"></a>消息摘要</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MD5 SHA-1 SHA-256 SHA-384 SHA-512....M</span></span><br><span class="line">MessageDigest digest = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    digest.update(<span class="keyword">byte</span>[]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] result = digest.digest();</span><br></pre></td></tr></table></figure>

<h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p><code>KeyGenerator</code>、<code>SecureRandom</code>、<code>Cipher</code>、<code>KeyPairGenerator</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>代理</title>
    <url>/2020/11/09/Java/%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>主要目的是扩展原有类的功能</p>
</blockquote>
<h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerImpl</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handle: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerProxy</span> <span class="keyword">implements</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="comment">// 传入需要代理的实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerProxy</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩展其用法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        mHandler.handle(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">new</span> HandlerProxy(<span class="keyword">new</span> HandlerImpl()).handle(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>就这样，知道缺点是被代理的类扩展了代理类也需一并扩展。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerImpl</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handle: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明实现InvocationHandler的处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入需要代理的实例对象</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        <span class="comment">// 利用反射机制将请求分派给委托类处理</span></span><br><span class="line">        Object invoke = method.invoke(mHandler, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Handler o = (Handler) Proxy.newProxyInstance(</span><br><span class="line">	    <span class="comment">// 类加载器</span></span><br><span class="line">        HandlerImpl.class.getClassLoader(),</span><br><span class="line">    	<span class="comment">// 需要代理的接口，也可：HandlerImpl.class.getInterfaces()</span></span><br><span class="line">    	<span class="keyword">new</span> Class[]&#123;Handler.class&#125;,</span><br><span class="line">    	<span class="comment">// 处理器</span></span><br><span class="line">        <span class="keyword">new</span> MyHandler(<span class="keyword">new</span> HandlerImpl()));</span><br><span class="line">o.handle(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，动态代理跟静态代理一样，在代理类内部保存了一个委托类的实例，实际上都是调用原来的委托实例来进行需要的操作。</p>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ol>
<li>动态代理跟静态代理最大的不同便是生成代理类的时期不同，静态代理是在编译期，而动态代理则是在运行时根据委托类信息动态生成</li>
<li>动态代理实现的是<code>InvocationHandler</code>接口，而静态代理则是直接实现公共接口</li>
<li>动态代理可以获得更多的运行时信息，使用起来也会更加灵活</li>
</ol>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>由于最终调用实际逻辑采用方法反射调用的方式，效率并不是很高</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>最终通过<code>ProxyGenerator.generateProxyClass()</code>函数动态生成代理字节码二进制数据，然后通过native方法<code>defineClass0</code>将字节码加载进方法区，并获取参数为<code>InvocationHandler</code>的构造器，然后通过该构造器生成实例并传入我们自定义的处理器</p>
<p><strong>注：android中直接通过<code>generateProxy</code>生成了代理类，并没有走<code>ProxyGenerator</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant Proxy</span><br><span class="line">participant Proxy#ProxyClassFactory</span><br><span class="line">participant WeakCache</span><br><span class="line">participant WeakCache#Factory</span><br><span class="line"></span><br><span class="line">Note left of WeakCache:Proxy类里有静态实例WeakCache成员变量\n生成该实例时传入ProxyClassFactory实例</span><br><span class="line">Proxy -&gt; WeakCache:Proxy.getProxyClass0()</span><br><span class="line">Note right of WeakCache:优先查找缓存</span><br><span class="line">WeakCache -&gt; WeakCache:proxyClassCache.get()</span><br><span class="line">WeakCache -&gt; Proxy:有缓存</span><br><span class="line">Note right of WeakCache:构建Factory工厂类</span><br><span class="line">WeakCache -&gt; WeakCache:new Factory()</span><br><span class="line">WeakCache -&gt; WeakCache#Factory:supplier.get()</span><br><span class="line">WeakCache#Factory -&gt; Proxy#ProxyClassFactory:valueFactory.apply()</span><br><span class="line">Note right of Proxy#ProxyClassFactory:1.类加载器是否解析出相同的class对象</span><br><span class="line">Note right of Proxy#ProxyClassFactory:2.class是否是一个接口</span><br><span class="line">Note right of Proxy#ProxyClassFactory:3.数组类是否重复等判断</span><br><span class="line">Note right of Proxy#ProxyClassFactory:调用defineClass0（native方法）动态生成字节码</span><br><span class="line">Proxy#ProxyClassFactory -&gt; Proxy:ProxyGenerator.generateProxyClass() \n defineClass0()</span><br><span class="line">Note right of Proxy:取参数为InvocationHandler构造器</span><br><span class="line">Note right of Proxy:通过构造器生成实例时传入处理器</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h3><blockquote>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充</p>
<p>通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择</p>
<p>git地址：<a href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a></p>
<p>cglib-nodep-xxx.jar:使用nodep包不需要关联asm的jar包,jar包内部包含asm的类.<br>cglib-xxx.jar:使用此jar包需要关联asm的jar包,否则运行时报错.</p>
</blockquote>
<h5 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_1</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_2</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_3</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handler handler = (Handler) Enhancer.create(Handler.class, <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        <span class="comment">// methodProxy 代理类方法代理引用，invokeSuper调用实际逻辑</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">handler.method_1(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h6><blockquote>
<p>作用：可以针对不同的方法调用不同的逻辑，</p>
<p>注意：虽然可以在<code>MethodInterceptor</code>的intercept方法进行区分，但使用过滤器可以有效的减少哈希查找，提高效率</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 什么操作都不做，直接调用实际方法</span></span><br><span class="line">NoOp instance = NoOp.INSTANCE;</span><br><span class="line"><span class="comment">// 锁定方法返回值，不会触发实际方法</span></span><br><span class="line">FixedValue fixedValue = <span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;锁定调用结果&quot;</span>);</span><br><span class="line">        Object result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 拦截操作</span></span><br><span class="line">MethodInterceptor methodInterceptor = <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Handler handler = (Handler) Enhancer.create(Handler.class, <span class="keyword">null</span>, <span class="keyword">new</span> CallbackFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_1&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_2&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Callback[]&#123;instance, fixedValue, methodInterceptor&#125;);</span><br><span class="line">handler.method_1(<span class="string">&quot;method_1&quot;</span>);</span><br><span class="line">handler.method_2(<span class="string">&quot;method_2&quot;</span>);</span><br><span class="line">handler.method_3(<span class="string">&quot;method_3&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延迟加载类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBeam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LazyLoader 只有在代理类调用任意方法时才会初始化数据，只会触发一次loadObject</span></span><br><span class="line">LazyBeam lazyBeam = (LazyBeam) Enhancer.create(LazyBeam.class, <span class="keyword">null</span>, <span class="keyword">new</span> LazyLoader() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载数据&quot;</span>);</span><br><span class="line">        LazyBeam lazyBeam = <span class="keyword">new</span> LazyBeam();</span><br><span class="line">        lazyBeam.setName(<span class="string">&quot;lazyBeam&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> lazyBeam;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(lazyBeam.getName());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatcher 只有在代理类调用任意方法时才会初始化数据,且每次都会触发loadObject</span></span><br><span class="line">LazyBeam lazyBeam = (LazyBeam) Enhancer.create(LazyBeam.class, <span class="keyword">null</span>, <span class="keyword">new</span> Dispatcher() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载数据&quot;</span>);</span><br><span class="line">        LazyBeam lazyBeam = <span class="keyword">new</span> LazyBeam();</span><br><span class="line">        lazyBeam.setName(<span class="string">&quot;lazyBeam&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> lazyBeam;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(lazyBeam.getName());</span><br></pre></td></tr></table></figure>

<h6 id="接口生成："><a href="#接口生成：" class="headerlink" title="接口生成："></a>接口生成：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterfaceMaker maker = <span class="keyword">new</span> InterfaceMaker();</span><br><span class="line">maker.add(Handler.class);</span><br><span class="line">Class&lt;?&gt; aClass = maker.create();</span><br><span class="line"><span class="keyword">for</span> (Method method : aClass.getMethods()) &#123;</span><br><span class="line">    System.out.println(method.getName());</span><br><span class="line">&#125;</span><br><span class="line">Object obj = Enhancer.create(Object.class, <span class="keyword">new</span> Class[]&#123;aClass&#125;, <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_1&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行方法1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;方法1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_2&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行方法2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;方法2&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Method method_1 = aClass.getMethod(<span class="string">&quot;method_1&quot;</span>, String.class);</span><br><span class="line">method_1.invoke(obj,<span class="string">&quot;方法1&quot;</span>);</span><br><span class="line">Method method_2 = aClass.getMethod(<span class="string">&quot;method_2&quot;</span>, String.class);</span><br><span class="line">method_2.invoke(obj,<span class="string">&quot;方法2&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h5><h6 id="表层原理："><a href="#表层原理：" class="headerlink" title="表层原理："></a>表层原理：</h6><p>动态生成代理类的子类，子类重写要代理的类的所有不是final/private的方法。在子类采用方法拦截的技术拦截所有父类方法的调用。</p>
<h6 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h6><p>使用字节码处理框架ASM，来转换字节码并生成新的类。<strong>注：不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</strong></p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>相较与JDK动态代理</p>
<ol>
<li>可以实现接口和类的代理，局限性更小【<strong>注：代理接口调用<code>invokeSuper</code>相当于直接调用未实现的接口方法，会直接报错</strong>】</li>
<li>由于与实际编写继承代码无异，采用的是动态用生成子类方式，方法执行效率要高</li>
<li>有丰富的操作策略以适应不同的业务</li>
</ol>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>由于采用继承的关系，对私有方法和final方法无法代理</p>
<h6 id="包说明："><a href="#包说明：" class="headerlink" title="包说明："></a>包说明：</h6><p><code>net.sf.cglib.core</code>:底层字节码处理类，他们大部分与ASM有关系。<br><code>net.sf.cglib.transform</code>:编译期或运行期类和类文件的转换<br><code>net.sf.cglib.proxy</code>:实现创建代理和方法拦截器的类<br><code>net.sf.cglib.reflect</code>:实现快速反射和C#风格代理的类<br><code>net.sf.cglib.util</code>:集合排序等工具类<br><code>net.sf.cglib.beans</code>:JavaBean相关的工具类</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类说明</title>
    <url>/2020/11/11/Java/%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="内部类说明"><a href="#内部类说明" class="headerlink" title="内部类说明"></a>内部类说明</h1><blockquote>
<p>jdk版本：</p>
<p>java version “1.8.0_261”<br>Java(TM) SE Runtime Environment (build 1.8.0_261-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</p>
</blockquote>
<p>编译文件说明</p>
<ol>
<li>内部类实际会被编译成【外部类名$内部类名.class】的字节码文件，并自动在内部类中生成一个持有外部类的【final 外部类名 this$0】的变量，由构造函数进行赋值</li>
<li>内部接口生成的字节码文件与第一点同理，并对接口函数进行【public abstract】声明</li>
<li>匿名内部类则会将类名赋予数字的形式处理，如【外部类名$1.class】，构造函数与第一点相同，如果有调用外部函数变量，则还会在构造函数增加该函数变量参数，并复制给【final 类型 val$别名】的变量上</li>
<li>如果内部类有调用外部类变量，则会在外部类生成一个静态函数【static 该外部类变量 access$000(外部类实例)】供内部类在调用外部类的地方使用</li>
</ol>
<p>注：以上提到的美元符号的名命【this$0 access$000 val$name】在不同的编译器和调用情况会有所不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler.java</span></span><br><span class="line"><span class="comment">// 源文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String name)</span> </span>&#123;<span class="comment">// 匿名内部类有调用该参数，编译时会被声明为final</span></span><br><span class="line">        mName = name;</span><br><span class="line">        <span class="keyword">new</span> RealHandler().handle();</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> IntHandler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(name); <span class="comment">// 匿名内部类调用外部函数变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(mName); <span class="comment">// 内部类调用外部变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntHandler</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler.class</span></span><br><span class="line"><span class="comment">// 反编译文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mName = var1;</span><br><span class="line">        (<span class="keyword">new</span> Handler.RealHandler()).handle();</span><br><span class="line">        Handler.IntHandler var10001 = <span class="keyword">new</span> Handler.IntHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RealHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Handler.<span class="keyword">this</span>.mName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// javap 命令文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> java.lang.String access$<span class="number">000</span>(Handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler$1.class</span></span><br><span class="line"><span class="comment">// 反编译文件</span></span><br><span class="line"><span class="keyword">import</span> Handler.IntHandler;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>$1 <span class="keyword">implements</span> <span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">    Handler$<span class="number">1</span>(Handler var1, String var2) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.val$name = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.val$name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// javap 命令文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>$1 <span class="keyword">implements</span> <span class="title">Handler</span>$<span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> java.lang.String val$name;</span><br><span class="line">  <span class="keyword">final</span> Handler <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">  Handler$<span class="number">1</span>(Handler, java.lang.String);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内部接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler$IntHandler</span></span><br><span class="line"><span class="comment">// 反编译文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span>$<span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// javap 命令文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span>$<span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler$RealHandler.class</span></span><br><span class="line"><span class="comment">// 反编译文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span>$<span class="title">RealHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler$RealHandler(Handler var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Handler.access$<span class="number">000</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// javap 命令文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span>$<span class="title">RealHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Handler <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> Handler$RealHandler(Handler);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-语法</title>
    <url>/2020/09/20/Kotlin/%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ol>
<li><p>中缀表达式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that : <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt;</span><br><span class="line"><span class="comment">// 使用： A 中缀方法 B</span></span><br><span class="line"><span class="number">1</span> to <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>可变参数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// varargs，类似于java的 ... ，但是位置没有限制</span></span><br><span class="line"><span class="comment">// 可以使用 * 来传入外部的变量作为可变参数的变量</span></span><br><span class="line"><span class="keyword">val</span> letters = arrayof(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">printLetters(*letters)</span><br></pre></td></tr></table></figure></li>
<li><p>原生字符串</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    123</span></span><br><span class="line"><span class="string">    abc</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>判断</p>
<ul>
<li>结构相等：== ，判断内容是否相等</li>
<li>引用相等：=== ， 判断引用是否一样</li>
</ul>
</li>
<li><p>区间</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间[IntRange]</span></span><br><span class="line"><span class="number">1</span> .. <span class="number">10</span> <span class="comment">// [1,...,10]</span></span><br><span class="line"><span class="number">1</span> until <span class="number">10</span> <span class="comment">// [1,...,9)</span></span><br><span class="line"><span class="number">10</span> downTo <span class="number">1</span> <span class="comment">// [10,9...1]</span></span><br><span class="line"><span class="number">1</span> .. <span class="number">10</span> step <span class="number">2</span> <span class="comment">// [1,3,5...]</span></span><br></pre></td></tr></table></figure></li>
<li><p>遍历</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array) &#123;&#125;</span><br><span class="line"><span class="comment">// 获取索引</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>延迟初始化：<code>by lazy</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认线程安全</span></span><br><span class="line"><span class="keyword">val</span> str <span class="keyword">by</span> lazy &#123; <span class="string">&quot;str&quot;</span> &#125;</span><br><span class="line"><span class="comment">// 并行模式</span></span><br><span class="line"><span class="keyword">val</span> str <span class="keyword">by</span> lazy(LazyThreadSafetyMode.PUBLICATION) &#123; <span class="string">&quot;str&quot;</span> &#125;</span><br><span class="line"><span class="comment">// 不做任何线程安全保证，也不会有任何线程开销</span></span><br><span class="line"><span class="keyword">val</span> str <span class="keyword">by</span> lazy(LazyThreadSafetyMode.NONE) &#123; <span class="string">&quot;str&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>变量必须是不可以变的：<code>val</code></li>
<li>在首次调用时才会初始化</li>
<li><code>lazy</code>属性会默认加入同步锁，在同一时刻只允许一个线程堆lazy属性进行初始化</li>
</ul>
</li>
<li><p>函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambda 表达式</span></span><br><span class="line"><span class="keyword">val</span> foo = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y&#125; <span class="comment">// foo.invoke(1, 2) 或 foo(1, 2)</span></span><br><span class="line"><span class="comment">// lambda 表达式函数体</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span> = &#123;y: <span class="built_in">Int</span> -&gt; x + y&#125; <span class="comment">// foo(1).invoke(2) 或 foo(1)(2)</span></span><br></pre></td></tr></table></figure></li>
<li><p>匿名内部类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambda 表达式</span></span><br><span class="line"><span class="keyword">val</span> runnable = Runnable&#123;&#125;</span><br><span class="line"><span class="comment">// 匿名实现类</span></span><br><span class="line"><span class="keyword">val</span> runnable = <span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或匿名内部类</span></span><br><span class="line">executor.submit(<span class="keyword">object</span>:Runnable&#123;...&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="10">
<li><p>密封类：<code>sealed</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuccessStatus</span>:<span class="type">Status</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorStatus</span>:<span class="type">Status</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>要继承必须将子类定义在同一个文件中</li>
</ul>
</li>
<li><p>内联类</p>
<blockquote>
<p>类似于包装类型，在编译时会把实际值替换到调用处<br>由于 <code>Kotlin</code> 不能使用<code>IntDef</code>模拟枚举的调用，可以考虑内联类来模拟枚举</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">val</span> ordinal:<span class="built_in">Int</span>)</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">		<span class="comment">// 模拟枚举</span></span><br><span class="line">		<span class="keyword">val</span> Idle = State(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">val</span> Busy = State(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可见性修饰符</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">含义</th>
<th align="center">与Java比较</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center"><code>Kotlin</code>中默认修饰符，全局可见</td>
<td align="center">与Java中public效果相同</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">受保护修饰符，类及子类可见</td>
<td align="center">含义一致，作用域除了类和子类，包内也可见</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">私有修饰符，类内修饰只有本类可见，类外修饰文件内可见</td>
<td align="center">私有修饰符，只有类内可见</td>
</tr>
<tr>
<td align="center">internal</td>
<td align="center">模块内可见</td>
<td align="center">无</td>
</tr>
</tbody></table>
</li>
<li><p>内部类和静态内部类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">StaticClass</span></span>&#123;&#125; <span class="comment">// 静态内部类</span></span><br><span class="line">	<span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125; <span class="comment">// 内部类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>委托代替接口实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span> : <span class="type">CanFly &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(flyer: Flyer) : CanFly <span class="keyword">by</span> flyer</span><br></pre></td></tr></table></figure></li>
<li><p>解构</p>
<blockquote>
<p>普通类想要使用结构方式可以手动写component1 component2一一对应的结构函数</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据类最多支持五个参数的解构</span></span><br><span class="line"><span class="keyword">val</span> pair = Pair(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> triple = Triple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> (n1, n2) = pair</span><br><span class="line"><span class="keyword">val</span> (a, b, c) = triple</span><br></pre></td></tr></table></figure></li>
<li><p>伴生类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123;</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123; <span class="comment">//相对于饿汉式静态内部类，全局只有一个实例</span></span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">testFun</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>object</code> 单例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Child</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Child INSTANCE;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      INSTANCE = <span class="keyword">new</span> Child();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>操作符</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj:TestData? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> result = obj?.value ?: -<span class="number">1</span> <span class="comment">// 如果 obj 为空，则返回 1</span></span><br><span class="line"><span class="keyword">val</span> result = obj!!.value <span class="comment">// 明确知道obj不为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> stu: Student? = getStu() <span class="keyword">as</span> Student <span class="comment">// 强制转换，如果为空会报错</span></span><br><span class="line"><span class="keyword">val</span> stu: Student? = getStu() <span class="keyword">as</span>? Student <span class="comment">// 强制转换，如果 getStu 返回空，则转换为空</span></span><br></pre></td></tr></table></figure></li>
<li><p>泛型内联特化</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">method</span><span class="params">(t:<span class="type">T</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> ts = Array&lt;T&gt;(<span class="number">3</span>)&#123;&#125;</span><br><span class="line">	<span class="keyword">val</span> jclass = T::<span class="keyword">class</span>.java</span><br><span class="line">	<span class="keyword">val</span> list = ArrayList&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a1 = arrayOf(o1, o2, o3) <span class="comment">// 普通数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a2 = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 基本数据类型数组：longArrayOf、floatArrayOf、doubleArrayOf....</span></span><br></pre></td></tr></table></figure></li>
<li><p>泛型多继承</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ground</span></span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Water</span>: <span class="type">Fruit</span></span>(),Ground</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cut</span><span class="params">(t: <span class="type">T</span>)</span></span> <span class="keyword">where</span> T : Fruit, T : Ground &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>作用域操作符</p>
<ul>
<li>如果需要返回自身的：apply{this} 或 also{it}</li>
<li>不需要返回自身的：run{this}或let{it}</li>
<li>满足条件才执行：<code>data.takeIf &#123; it.age &gt;= 18 &#125;.let &#123;...&#125;</code></li>
<li>不满足条件才执行：<code>data.takeUnless &#123; it.age &gt;= 18 &#125;.let &#123;...&#125;</code></li>
</ul>
</li>
<li><p><code>with</code> 和 <code>apply</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T</span><br></pre></td></tr></table></figure></li>
<li><p>惰性求值：序列</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该操作会产生两个临时集合来记录元素，如果元素非常多时，就会有效率问题</span></span><br><span class="line">list.filter &#123;it &gt; <span class="number">2</span>&#125;.map &#123;it * <span class="number">2</span>&#125;                                                                                             </span><br><span class="line"><span class="comment">// 通过惰性求值减少临时集合的情况</span></span><br><span class="line">list.asSequence().filter &#123;it &gt; <span class="number">2</span>&#125;.map &#123;it * <span class="number">2</span>&#125;.toList()</span><br></pre></td></tr></table></figure></li>
<li><p>无限序列</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> naturalNumList = generateSequence(<span class="number">0</span>) &#123;it + <span class="number">1</span>&#125;</span><br><span class="line">naturalNumList.takeWhile &#123;it &lt;= <span class="number">9</span>&#125;.toList()</span><br></pre></td></tr></table></figure></li>
<li><p>内联函数</p>
<blockquote>
<p>内联函数能将函数内容编译到调用处，减少函数调用</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(block:() -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// crossinline 禁止传递的block函数调用 r eturn 方法</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(<span class="keyword">crossinline</span> block:() -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// noinline 该函数参数不做内联</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(<span class="keyword">noinline</span> block:() -&gt; <span class="type">Unit</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>内联函数注意事项</p>
<ul>
<li>由于JVM对普通函数有内联优化，所以普通函数比一定要采用内联函数，这样只会增加复杂性</li>
<li>尽量避免有大量函数体的函数进行内联，这样会增加字节码数量</li>
<li>内联函数无法使用闭包成员【闭包：内部函数持有外部函数变量】</li>
</ul>
</li>
<li><p>运算符重载</p>
<p>参考：<a href="https://kotlinlang.org/docs/reference/operator-overloading.html">https://kotlinlang.org/docs/reference/operator-overloading.html</a><br>operator fun 类名.重载符号(一个参数):返回值 {}</p>
</li>
<li><p>扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 为Person类增加名为ext的扩展方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">ext</span><span class="params">(s:<span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩展属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> Data.extValue:boolean</span><br><span class="line">	<span class="keyword">get</span>() = <span class="keyword">this</span>.otherValue % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> age = <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Son.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;age = <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样就可以不创建类的情况下直接调用</span></span><br><span class="line">Son.foo()</span><br></pre></td></tr></table></figure></li>
<li><p>代理观察者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.observable(<span class="number">0</span>, &#123; property, oldValue, newValue -&gt;</span><br><span class="line">		<span class="comment">// 当price的值变更时触发该函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = Data()</span><br><span class="line"><span class="keyword">data</span>.price = <span class="number">100</span></span><br></pre></td></tr></table></figure></li>
<li><p>代理限制</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.vetoable(<span class="number">0</span>, &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        newValue &gt; <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = Data()</span><br><span class="line"><span class="keyword">data</span>.price = <span class="number">100</span></span><br><span class="line"><span class="keyword">data</span>.price = -<span class="number">100</span> <span class="comment">// 该值不会设置成功</span></span><br></pre></td></tr></table></figure></li>
<li><p>原始方式创建协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line">    <span class="comment">// coroutine heandle!</span></span><br><span class="line">&#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = Dispatchers.Default</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Coroutine end!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).resume(<span class="built_in">Unit</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>顶层协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure></li>
<li><p>会阻塞当前线程直到协程作用域内的代码全部执行完</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runBlocking &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建子协程，必须在协程作用域内使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch&#123;&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure></li>
<li><p>挂起函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没法使用launch函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过coroutineScope生成带协程作用域的挂起函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span>=coroutineScope&#123;</span><br><span class="line">	launch&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：coroutineScope也会阻塞当前协程，必须得里面的子协程执行完了才行</span></span><br><span class="line">runBlocking &#123;</span><br><span class="line">	coroutineScope &#123;</span><br><span class="line">		launch &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得等coroutineScope执行完了才会走到这</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得等runBlocking执行完了才会走到这</span></span><br></pre></td></tr></table></figure></li>
<li><p>协程统一取消</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = Job()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">scope.launch&#123;</span><br><span class="line">	<span class="comment">// 协程域</span></span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure></li>
<li><p>超时协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">withTimeout(<span class="number">100</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回结果的协程域</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> r1 = async&#123;</span><br><span class="line">	<span class="comment">// 返回deferred时协程就已经开始跑了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> r2 = async&#123;</span><br><span class="line">	<span class="comment">// 返回deferred时协程就已经开始跑了</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;r1.await()&#125;</span> - <span class="subst">$&#123;r2.await()&#125;</span>&quot;</span>)<span class="comment">// 阻塞返回结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// async简化版</span></span><br><span class="line"><span class="keyword">val</span> result = withContext(Dispatchers.Dafault) &#123;&#125; <span class="comment">// 阻塞返回结果，其中Dispatchers.Dafault为低并发策略</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>suspendCoroutine</code>结合回调函数，需要在协程域和挂起函数中使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(address:<span class="type">String</span>)</span></span>:String &#123;</span><br><span class="line">	<span class="keyword">return</span> suspendCoroutine &#123;continuation -&gt;    </span><br><span class="line">		new Thread(&#123;</span><br><span class="line">				continuation.resume(结果)<span class="comment">// 成功</span></span><br><span class="line">				continuation.resumeWithException(结果)<span class="comment">// 失败</span></span><br><span class="line">		&#125;).start()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步代码块和同步代码函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">method2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="function"><span class="keyword">fun</span> <span class="title">method1</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>volatile</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>ReentrantLock</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> lock = ReentrantLock()</span><br><span class="line">lock.withLock &#123; method() &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>反射</p>
<blockquote>
<p>首次使用会比java的慢</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Kotlin <span class="class"><span class="keyword">class</span>：<span class="title">String</span>:<span class="type">:class 	String::class.java.kotlin</span></span></span><br><span class="line">Java <span class="class"><span class="keyword">class</span>: <span class="type">String::class.java</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>注解变更java调用命名</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;name&quot;</span>)<span class="comment">//作用于文件名</span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;name&quot;</span>)<span class="comment">//作用于变量get函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带默认参数函数适配java调用</span></span><br><span class="line"><span class="meta">@JvmOverloads</span><span class="comment">//这样就会生成重载方法来适配默认参数</span></span><br><span class="line"></span><br><span class="line">inernal <span class="comment">// 声明的对象不想被java访问到，可以使用@JvmName(&quot;%abc&quot;)等特殊字符声明，这样java就被限制了</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/2020/12/19/Linux/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><h4 id="ps-查看进程常用组合"><a href="#ps-查看进程常用组合" class="headerlink" title="ps 查看进程常用组合"></a><code>ps</code> 查看进程常用组合</h4><ul>
<li><code>ps -ef</code><ul>
<li>e：列出所有进程，与参数 A 效果一致</li>
<li>f：显示 UID、PPIP、C 与 STIME 栏位</li>
</ul>
</li>
<li><code>ps -aux</code><ul>
<li>a：显示所有终端机下执行的程序</li>
<li>u：用户识别码，与参数 U 效果一致</li>
<li>x：显示无控制终端的进程</li>
</ul>
</li>
<li><code>ps -eLf</code><ul>
<li>L：显示线程</li>
</ul>
</li>
<li><code>ps --help &lt;args&gt;</code></li>
</ul>
<h4 id="top-查看进程状态"><a href="#top-查看进程状态" class="headerlink" title="top 查看进程状态"></a>top 查看进程状态</h4><ul>
<li>n：更新的次数，完成后将会退出 top</li>
<li>i：不显示任何闲置 (idle) 或无用 (zombie) 的进程</li>
<li>d：更新速度</li>
<li>H：显示线程</li>
<li>p：指定进程</li>
</ul>
<h4 id="grep-查找文件里符合条件的字符串"><a href="#grep-查找文件里符合条件的字符串" class="headerlink" title="grep 查找文件里符合条件的字符串"></a>grep 查找文件里符合条件的字符串</h4><ul>
<li>i：忽略大小写</li>
<li>E：匹配样式</li>
<li>A：除了匹配行，还会显示之后指定行数</li>
<li>w：只显示全字符符合的列</li>
<li>v：显示不包含匹配文本的所有行</li>
</ul>
<h4 id="tail-查看文件内容"><a href="#tail-查看文件内容" class="headerlink" title="tail 查看文件内容"></a>tail 查看文件内容</h4><ul>
<li>n：显示文件的尾部 n 行内容</li>
<li>f：循环读取</li>
</ul>
<h5 id="cat-查看文件内容"><a href="#cat-查看文件内容" class="headerlink" title="cat 查看文件内容"></a>cat 查看文件内容</h5><ul>
<li>n：显示行数编号</li>
<li>b：和 -n 相似，只不过对于空白行不编号</li>
<li>s：当遇到有连续两行以上的空白行，就代换为一行的空白行</li>
</ul>
<h4 id="wc-统计"><a href="#wc-统计" class="headerlink" title="wc 统计"></a>wc 统计</h4><ul>
<li>c：统计bytes数</li>
<li>w：统计单词数</li>
<li>l：统计行数</li>
</ul>
<h4 id="netstat-查看网络状态"><a href="#netstat-查看网络状态" class="headerlink" title="netstat 查看网络状态"></a>netstat 查看网络状态</h4><ul>
<li>a：显示所有连线中的Socket</li>
<li>c：持续列出网络状态</li>
<li>p：显示正在使用Socket的程序识别码和程序名称</li>
<li>n：直接使用IP地址，而不通过域名服务器</li>
<li>t：显示TCP传输协议的连线状况</li>
<li>u：显示UDP传输协议的连线状况</li>
<li>s：显示网络工作信息统计表</li>
</ul>
<h4 id="watch-监测命令运行结果"><a href="#watch-监测命令运行结果" class="headerlink" title="watch 监测命令运行结果"></a>watch 监测命令运行结果</h4><ul>
<li>d：高亮显示不同</li>
<li>n：时间间隔</li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li><code>lsof</code> 常用命令（列出当前系统打开文件的工具，Linux 中一切皆文件，所以同样可以访问网络连接和硬件）<ul>
<li><code>lsof -i:8100</code> ：查看8100端口运行情况</li>
</ul>
</li>
<li>which：查看环境变量符合条件的变量</li>
</ul>
]]></content>
      <categories>
        <category>ADB</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 学习笔记-解压缩命令详解</title>
    <url>/2020/09/17/Linux/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Linux-学习笔记-解压缩命令详解"><a href="#Linux-学习笔记-解压缩命令详解" class="headerlink" title="Linux 学习笔记-解压缩命令详解"></a>Linux 学习笔记-解压缩命令详解</h1><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><pre><code>独立命令：
    -c: 建立压缩档案
    -x：解压
    -t：查看内容
    -r：向压缩归档文件末尾追加文件
    -u：更新原压缩包中的文件
    注意：这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。

下面的参数是根据需要在压缩或解压档案时可选的。
    -z：有gzip属性的
    -j：有bz2属性的
    -Z：有compress属性的
    -v：显示所有过程
    -O：将文件解开到标准输出

下面的参数-f是必须的
    -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。

tar -cf all.tar *.jpg     // 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。
tar -rf all.tar *.gif     // 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。
tar -uf all.tar logo.gif  // 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。
tar -tf all.tar           // 这条命令是列出all.tar包中所有文件，-t是列出文件的意思
tar -xf all.tar           // 这条命令是解出all.tar包中所有文件，-x是解开的意思
</code></pre>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><pre><code>tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg
tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一  个gzip压缩过的包，命名为jpg.tar.gz
tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2
tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z
rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux
zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux
</code></pre>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><pre><code>tar –xvf file.tar //解压 tar包
tar -xzvf file.tar.gz //解压tar.gz
tar -xjvf file.tar.bz2   //解压 tar.bz2
tar –xZvf file.tar.Z   //解压tar.Z
unrar e file.rar //解压rar
unzip file.zip //解压zip
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>(1) *.tar 用 tar –xvf 解压
(2) *.gz 用 gzip -d或者gunzip 解压
(3) *.tar.gz和*.tgz 用 tar –xzf 解压
(4) *.bz2 用 bzip2 -d或者用bunzip2 解压
(5) *.tar.bz2用tar –xjf 解压
(6) *.Z 用 uncompress 解压
(7) *.tar.Z 用tar –xZf 解压
(8) *.rar 用 unrar e解压
(9) *.zip 用 unzip 解压
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>解压缩命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu环境变量</title>
    <url>/2020/09/16/Linux/Ubuntu%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Ubuntu环境变量"><a href="#Ubuntu环境变量" class="headerlink" title="Ubuntu环境变量"></a>Ubuntu环境变量</h1><h5 id="在Ubuntu中有如下几个文件可以设置环境变量："><a href="#在Ubuntu中有如下几个文件可以设置环境变量：" class="headerlink" title="在Ubuntu中有如下几个文件可以设置环境变量："></a>在Ubuntu中有如下几个文件可以设置环境变量：</h5><ul>
<li><p><code>/etc/profile</code>：在登录时,操作系统定制用户环境时使用的第一个文件,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.</p>
</li>
<li><p><code>/etc/environment</code>：在登录时操作系统使用的第二个文件,系统在读取你自己的 <code>profile</code> 前,设置环境文件的环境变量</p>
</li>
<li><p><code>~/.profile</code>：在登录时用到的第三个文件是 <code>.profile</code> 文件,每个用户都可使用该文件输入专用于自己使用的 <code>shell</code> 信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的 <code>.bashrc</code> 文件.</p>
</li>
<li><p><code>/etc/bashrc</code>：为每一个运行 <code>bash shell</code> 的用户执行此文件。当 <code>bash shell</code> 被打开时,该文件被读取.</p>
</li>
<li><p><code>~/.bashrc</code>：该文件包含专用于你的 <code>bash shell</code> 的 <code>bash</code> 信息,当登录时以及每次打开新的 <code>shell</code> 时,该该文件被读取.</p>
</li>
</ul>
<h5 id="通常设置环境变量有三种方法："><a href="#通常设置环境变量有三种方法：" class="headerlink" title="通常设置环境变量有三种方法："></a>通常设置环境变量有三种方法：</h5><ol>
<li><p>临时设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/home/yan/share/usr/<span class="built_in">local</span>/arm/3.4.1/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li>
<li><p>当前用户的全局设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开 ~/.bashrc，添加行：</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/yan/share/usr/<span class="built_in">local</span>/arm/3.4.1/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 使生效</span></span><br><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>所有用户的全局设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 在里面加入：</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/yan/share/usr/<span class="built_in">local</span>/arm/3.4.1/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 使生效</span></span><br><span class="line"><span class="built_in">source</span> profile</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="JDK-配置"><a href="#JDK-配置" class="headerlink" title="JDK 配置"></a>JDK 配置</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8/</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>



<h5 id="NDK-配置"><a href="#NDK-配置" class="headerlink" title="NDK 配置"></a>NDK 配置</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NDK=/home/benben/AndroidSDK/ndk-bundle</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$NDK</span></span><br></pre></td></tr></table></figure>



<h5 id="shadowsocks-qt5-配置"><a href="#shadowsocks-qt5-配置" class="headerlink" title="shadowsocks-qt5 配置"></a><code>shadowsocks-qt5</code> 配置</h5><p><a href="https://github.com/shadowsocks/shadowsocks-qt5">https://github.com/shadowsocks/shadowsocks-qt5</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 程序后台运行的几种方法</title>
    <url>/2020/09/17/Linux/ubuntu%20%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Ubuntu-程序后台运行的几种方法"><a href="#Ubuntu-程序后台运行的几种方法" class="headerlink" title="Ubuntu 程序后台运行的几种方法"></a>Ubuntu 程序后台运行的几种方法</h1><blockquote>
<p>我们经常会碰到这样的问题，用 <code>telnet/ssh</code> 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。</p>
</blockquote>
<h2 id="nohup-setsid-amp"><a href="#nohup-setsid-amp" class="headerlink" title="nohup/setsid/&amp;"></a><code>nohup/setsid/&amp;</code></h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>我们知道，当用户注销 <code>(logout)</code> 或者网络断开时，终端会收到 <code>HUP(hangup)</code> 信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 <code>HUP</code> 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。</p>
<ol>
<li><p><code>nohup</code><br> <code>nohup</code> 无疑是我们首先想到的办法。顾名思义，<code>nohup</code> 的用途就是让提交的命令忽略 <code>hangup</code> 信号。让我们先来看一下 <code>nohup</code> 的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOHUP(1)                        User Commands                        NOHUP(1)</span><br><span class="line">NAME</span><br><span class="line">       nohup - run a command immune to hangups, with output to a non-tty</span><br><span class="line">SYNOPSIS</span><br><span class="line">       nohup COMMAND [ARG]...</span><br><span class="line">       nohup OPTION</span><br><span class="line">DESCRIPTION</span><br><span class="line">        Run COMMAND, ignoring hangup signals.</span><br><span class="line">       --help display this help and exit</span><br><span class="line">       --version</span><br><span class="line">              output version information and exit</span><br></pre></td></tr></table></figure>
<p> <code>nohup</code> 的使用是十分方便的，只需在要处理的命令前加上 <code>nohup</code> 即可，标准输出和标准错误缺省会被重定向到 <code>nohup.out</code> 文件中。一般我们可在结尾加上”&amp;”来将命令同时放入后台运行，也可用 <code>&gt;filename 2&gt;&amp;1</code> 来更改缺省的重定向文件名。<br> <code>nohup</code> 示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# nohup ping www.ibm.com &amp;</span><br><span class="line">[1] 3059</span><br><span class="line">nohup: appending output to &#39;nohup.out&#39;</span><br><span class="line">[root@pvcent107 ~]# ps -ef |grep 3059</span><br><span class="line">root      3059   984  0 21:06 pts&#x2F;3    00:00:00 ping www.ibm.com</span><br><span class="line">root      3067   984  0 21:06 pts&#x2F;3    00:00:00 grep 3059</span><br><span class="line">[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure></li>
<li><p><code>setsid</code><br> <code>nohup</code> 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 <code>HUP</code> 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。<code>setsid</code> 就能帮助我们做到这一点。让我们先来看一下 <code>setsid</code> 的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SETSID(8)                 Linux Programmer’s Manual                 SETSID(8)</span><br><span class="line">NAME</span><br><span class="line">       setsid - run a program in a new session</span><br><span class="line">SYNOPSIS</span><br><span class="line">       setsid program [ arg ... ]</span><br><span class="line">DESCRIPTION</span><br><span class="line">       setsid runs a program in a new session.</span><br></pre></td></tr></table></figure>
<p> 可见 <code>setsid</code> 的使用也是非常方便的，也只需在要处理的命令前加上 <code>setsid</code> 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# setsid ping www.ibm.com</span><br><span class="line">[root@pvcent107 ~]# ps -ef |grep www.ibm.com</span><br><span class="line">root     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com</span><br><span class="line">root     31102 29217  0 07:29 pts&#x2F;4    00:00:00 grep www.ibm.com</span><br><span class="line">[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure>
<p> 值得注意的是，上例中我们的进程 <code>ID(PID)</code> 为 31094，而它的父 <code>ID(PPID)</code> 为1（即为 <code>init</code> 进程 <code>ID</code>），并不是当前终端的进程 <code>ID</code>。请将此例与 <code>nohup</code> 例中的父 <code>ID</code> 做比较。</p>
</li>
<li><p>&amp;<br>这里还有一个关于 <code>subshell</code> 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 <code>shell</code> 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。<br><br><br>当我们将”&amp;”也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过 <code>jobs</code> 来查看的。让我们来看看为什么这样就能躲过 <code>HUP</code> 信号的影响吧。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# (ping www.ibm.com &amp;)</span><br><span class="line">[root@pvcent107 ~]# ps -ef |grep www.ibm.com</span><br><span class="line">root     16270     1  0 14:13 pts&#x2F;4    00:00:00 ping www.ibm.com</span><br><span class="line">root     16278 15362  0 14:13 pts&#x2F;4    00:00:00 grep www.ibm.com</span><br><span class="line">[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>我们已经知道，如果事先在命令前加上 <code>nohup</code> 或者 <code>setsid</code> 就可以避免 <code>HUP</code> 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 <code>HUP</code> 信号的影响呢？</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>这时想加 <code>nohup</code> 或者 <code>setsid</code> 已经为时已晚，只能通过作业调度和 <code>disown</code> 来解决这个问题了。让我们来看一下 <code>disown</code> 的帮助信息：</p>
<pre><code>disown [-ar] [-h] [jobspec ...]
Without options, each jobspec is  removed  from  the  table  of
active  jobs.   If  the -h option is given, each jobspec is not
removed from the table, but is marked so  that  SIGHUP  is  not
sent  to the job if the shell receives a SIGHUP.  If no jobspec
is present, and neither the -a nor the -r option  is  supplied,
the  current  job  is  used.  If no jobspec is supplied, the -a
option means to remove or mark all jobs; the -r option  without
a  jobspec  argument  restricts operation to running jobs.  The
return value is 0 unless a jobspec does  not  specify  a  valid
job.
</code></pre>
<p>可以看出，我们可以用如下方式来达成我们的目的。</p>
<ul>
<li>用 <code>disown -h jobspec</code> 来使某个作业忽略 <code>HUP</code> 信号。</li>
<li>用 <code>disown -ah</code> 来使所有的作业都忽略 <code>HUP</code> 信号。</li>
<li>用 <code>disown -rh</code> 来使正在运行的作业忽略 <code>HUP</code> 信号。</li>
</ul>
<p>需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用 <code>ps -ef</code> 查找到它。<br><br><br>但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了”&amp;”来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过jobs命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 <code>CTRL-z</code>（按住Ctrl键的同时按住z键）了！<br><code> CTRL-z</code> 的用途就是将当前进程挂起 <code>(Suspend)</code>，然后我们就可以用jobs命令来查询它的作业号，再用 <code>bg jobspec</code> 来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。<br><br><code> disown</code> 示例1（如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用 <code>disown</code> ）</p>
<pre><code>[root@pvcent107 build]# cp -r testLargeFile largeFile &amp;
[1] 4825
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile
root      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile
root      4853   968  0 09:46 pts/4    00:00:00 grep largeFile
[root@pvcent107 build]# logout
</code></pre>
<p><code>disown</code> 示例2（如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 <code>CTRL-z</code> 和 <code>bg</code> 将其放入后台，再使用 <code>disown</code>）</p>
<pre><code>[root@pvcent107 build]# cp -r testLargeFile largeFile2

[1]+  Stopped                 cp -i -r testLargeFile largeFile2
[root@pvcent107 build]# bg %1
[1]+ cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile2
root      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2
root      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2
[root@pvcent107 build]#
</code></pre>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>此时最方便的方法就是 <code>screen</code> 了。简单的说，<code>screen</code> 提供了 <code>ANSI/VT100</code> 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。<code>screen</code> 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 <code>screen</code> 能够避免 <code>HUP</code> 信号的影响。我们先看一下 <code>screen</code> 的帮助信息：</p>
<pre><code>SCREEN(1)                                                           SCREEN(1)
NAME
       screen - screen manager with VT100/ANSI terminal emulation
SYNOPSIS
       screen [ -options ] [ cmd [ args ] ]
       screen -r [[pid.]tty[.host]]
       screen -r sessionowner/[[pid.]tty[.host]]
DESCRIPTION
       Screen  is  a  full-screen  window manager that multiplexes a physical
       terminal between several  processes  (typically  interactive  shells).
       Each  virtual  terminal provides the functions of a DEC VT100 terminal
       and, in addition, several control functions from the  ISO  6429  (ECMA
       48,  ANSI  X3.64)  and ISO 2022 standards (e.g. insert/delete line and
       support for multiple character sets).  There is a  scrollback  history
       buffer  for  each virtual terminal and a copy-and-paste mechanism that
       allows moving text regions between windows.
</code></pre>
<p>使用 <code>screen</code> 很方便，有以下几个常用选项：</p>
<ul>
<li><p>用 <code>screen -dmS session name</code> 来建立一个处于断开模式下的会话（并指定其会话名）。</p>
</li>
<li><p>用 <code>screen -ls</code> 来列出所有会话。</p>
</li>
<li><p>用 <code>screen -r session name</code> 来重新连接指定会话。</p>
</li>
<li><p>用快捷键 <code>CTRL-a d</code> 来暂时断开当前会话。<br><code>screen</code> 示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# screen -dmS Urumchi</span><br><span class="line">[root@pvcent107 ~]# screen -ls</span><br><span class="line">There is a screen on:</span><br><span class="line">        12842.Urumchi   (Detached)</span><br><span class="line">1 Socket in &#x2F;tmp&#x2F;screens&#x2F;S-root.</span><br><span class="line">[root@pvcent107 ~]# screen -r Urumchi</span><br></pre></td></tr></table></figure>
<p>当我们用“-r”连接到 <code>screen</code> 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 <code>HUP</code> 信号会对我们的进程造成影响，也不用给每个命令前都加上 <code>nohup</code> 或者 <code>setsid</code> 了。这是为什么呢？让我来看一下下面两个例子吧。</p>
</li>
</ul>
<ol>
<li>未使用 screen 时新进程的进程树 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# ping www.google.com &amp;</span><br><span class="line">[1] 9499</span><br><span class="line">[root@pvcent107 ~]# pstree -H 9499</span><br><span class="line">init─┬─Xvnc</span><br><span class="line">     ├─acpid</span><br><span class="line">     ├─atd</span><br><span class="line">     ├─2*[sendmail]</span><br><span class="line">     ├─sshd─┬─sshd───bash───pstree</span><br><span class="line">     │       └─sshd───bash───ping</span><br></pre></td></tr></table></figure>
<pre><code> 我们可以看出，未使用 screen 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 ping 进程）。
</code></pre>
</li>
<li>使用了 <code>screen</code> 后新进程的进程树 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# screen -r Urumchi</span><br><span class="line">[root@pvcent107 ~]# ping www.ibm.com &amp;</span><br><span class="line">[1] 9488</span><br><span class="line">[root@pvcent107 ~]# pstree -H 9488</span><br><span class="line">init─┬─Xvnc</span><br><span class="line">     ├─acpid</span><br><span class="line">     ├─atd</span><br><span class="line">     ├─screen───bash───ping</span><br><span class="line">     ├─2*[sendmail]</span><br></pre></td></tr></table></figure>
<pre><code> 而使用了 screen 后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。
</code></pre>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。<code>nohup/setsid</code> 无疑是临时需要时最方便的方法，<code>disown</code> 能帮助我们来事后补救当前已经在运行了的作业，而 <code>screen</code> 则是在大批量操作时不二的选择了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>后台运行</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 能用上的Linux命令</title>
    <url>/2020/12/20/Android/ADB/Android%20%E8%83%BD%E7%94%A8%E4%B8%8A%E7%9A%84Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Android-能用上的Linux命令"><a href="#Android-能用上的Linux命令" class="headerlink" title="Android 能用上的Linux命令"></a>Android 能用上的Linux命令</h1><ul>
<li><p>参考：<a href="/2020/12/19/Linux/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">常用命令</a></p>
</li>
<li><p>获取 CPU 核心数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/possible</span><br></pre></td></tr></table></figure></li>
<li><p>获取第一个 CPU 的最大频率</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq   </span><br></pre></td></tr></table></figure></li>
<li><p>获取第二个CPU的最小频率</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu1/cpufreq/cpuinfo_min_freq</span><br></pre></td></tr></table></figure></li>
<li><p>CPU 瞬时情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">whyred:/ $ cat /proc/stat</span><br><span class="line">cpu  <span class="number">731136</span> <span class="number">50041</span> <span class="number">1038145</span> <span class="number">270823460</span> <span class="number">35086</span> <span class="number">3933864</span> <span class="number">332437</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu0 <span class="number">187090</span> <span class="number">11104</span> <span class="number">314921</span> <span class="number">33420523</span> <span class="number">7263</span> <span class="number">71201</span> <span class="number">58251</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu1 <span class="number">244047</span> <span class="number">13970</span> <span class="number">352376</span> <span class="number">33355729</span> <span class="number">9002</span> <span class="number">58805</span> <span class="number">59312</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu2 <span class="number">130440</span> <span class="number">8604</span> <span class="number">171217</span> <span class="number">33747327</span> <span class="number">8157</span> <span class="number">33540</span> <span class="number">20522</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu3 <span class="number">40515</span> <span class="number">3794</span> <span class="number">104055</span> <span class="number">33956680</span> <span class="number">9009</span> <span class="number">19027</span> <span class="number">16455</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu4 <span class="number">59788</span> <span class="number">4665</span> <span class="number">43842</span> <span class="number">34035844</span> <span class="number">483</span> <span class="number">206098</span> <span class="number">44471</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu5 <span class="number">34608</span> <span class="number">3677</span> <span class="number">25619</span> <span class="number">34081033</span> <span class="number">420</span> <span class="number">159429</span> <span class="number">132489</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu6 <span class="number">30523</span> <span class="number">2268</span> <span class="number">23459</span> <span class="number">34088923</span> <span class="number">348</span> <span class="number">137672</span> <span class="number">739</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu7 <span class="number">4122</span> <span class="number">1954</span> <span class="number">2652</span> <span class="number">34137396</span> <span class="number">399</span> <span class="number">3248088</span> <span class="number">193</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">intr ...</span><br></pre></td></tr></table></figure>

<p>这些数值的单位都是 jiffies，<strong>jiffies 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 Linux 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 Linux 系统内核这个值可能不同，通常在 1ms 到 10ms 之间</strong></p>
<p>对应的各项指标如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU (user, nice, system, idle, iowait, irq, softirq, stealstolen, guest)</span><br></pre></td></tr></table></figure>

<ul>
<li>user：表示从系统启动开始至今处于用户态的运行时间，注意不包含 nice 值为负的进程</li>
<li>nice：表示从系统启动开始至今nice 值为负的进程所占用的 CPU 时间</li>
<li>system：表示从系统启动开始至今处于内核态的运行时间</li>
<li>idle：表示从系统启动开始至今除 IO 等待时间以外的其他等待时间</li>
<li>iowait：表示从系统启动开始至今的IO 等待时间。(从Linux V2.5.41开始)</li>
<li>irq：表示从系统启动开始至今的硬中断时间。(从Linux V2.6.0-test4开始)</li>
<li>softirq：表示从系统启动开始至今的软中断时间。(从Linux V2.6.0-test4开始)</li>
<li>stealstolen：表示当在虚拟化环境中运行时在其他操作系统中所花费的时间。在Android系统下此值为0。(从Linux V2.6.11开始)</li>
<li>guest：表示当在Linux内核的控制下为其它操作系统运行虚拟CPU所花费的时间。在Android系统下此值为0。(从 V2.6.24开始)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ADB</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title>SurfaceFlinger</title>
    <url>/2020/12/20/Android/ADB/SurfaceFlinger/</url>
    <content><![CDATA[<h1 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h1><blockquote>
<p>在Android 4.1以后，系统使用了三级缓冲机制，即此时有三个Graphic Buffer，通过 SurfaceFlinger 查看应用缓冲区信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys SurfaceFlinger</span><br></pre></td></tr></table></figure>

<p>输出的信息非常多，这里只关注三个信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">&#x2F;&#x2F; app 信息</span><br><span class="line">* Layer 0x74dab40d70 (com.benben.viewpractice&#x2F;com.benben.viewpractice.MainActivity#0)</span><br><span class="line">      isSecure&#x3D;false geomUsesSourceCrop&#x3D;true geomBufferUsesDisplayInverseTransform&#x3D;false geomLayerTransform 0x00000000 (ROT_0 ) 0x00 (IDENTITY )</span><br><span class="line">    1.0000  0.0000  0.0000</span><br><span class="line">    0.0000  1.0000  0.0000</span><br><span class="line">    0.0000  0.0000  1.0000</span><br><span class="line"></span><br><span class="line">      geomBufferSize&#x3D;[0 0 1080 2160] geomContentCrop&#x3D;[0 0 1080 2160] geomCrop&#x3D;[0 0 1080 2160] geomBufferTransform&#x3D;0</span><br><span class="line">        Region transparentRegionHint (this&#x3D;0x742ab46c20, count&#x3D;1)</span><br><span class="line">    [  0,   0,   0,   0]</span><br><span class="line">      geomLayerBounds&#x3D;[0.000000 0.000000 1080.000000 2160.000000]       shadowRadius&#x3D;0.000000</span><br><span class="line">      blend&#x3D;NONE (1) alpha&#x3D;1.000000 backgroundBlurRadius&#x3D;0</span><br><span class="line">      type&#x3D;1 appId&#x3D;10165 composition type&#x3D;DEVICE (2)</span><br><span class="line">      buffer: slot&#x3D;0 buffer&#x3D;0x73eab35450</span><br><span class="line">      sideband stream&#x3D;0x0</span><br><span class="line">      color&#x3D;[0.000000 0.000000 0.000000]</span><br><span class="line">      isOpaque&#x3D;true hasProtectedContent&#x3D;false isColorspaceAgnostic&#x3D;false dataspace&#x3D;UNKNOWN (0) hdr metadata types&#x3D;0 colorTransform&#x3D;[[1.000,0.000,0.000,0.000][0.000,1.000,0.000,0.000][0.000,0.000,1.000,0.000][</span><br><span class="line">0.000,0.000,0.000,1.000]]</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Slots:</span><br><span class="line">  &#x2F;&#x2F; 需要            &#x2F;&#x2F; 表明是否使用的状态 &#x2F;&#x2F; 对象地址 &#x2F;&#x2F; 当前负责第几帧 &#x2F;&#x2F; 屏幕分辨率</span><br><span class="line"> &gt;[01:0x73eab519b0] state&#x3D;ACQUIRED 0x73aab35bd0 frame&#x3D;3094 [1080x2160:1088,  1]</span><br><span class="line">  [00:0x73eab4eb90] state&#x3D;FREE     0x73aab46d30 frame&#x3D;3093 [1080x2160:1088,  1]</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#x2F;&#x2F; 地址       &#x2F;&#x2F; 缓冲区大小</span><br><span class="line">0x73aab31f10:    0.25 KiB |    1 (  64) x    1 |    1 |        1 | 0x300 | placeholder</span><br><span class="line">0x73aab35bd0: 9180.00 KiB | 1080 (1088) x 2160 |    1 |        1 | 0x1a00 | FramebufferSurface</span><br><span class="line">0x73aab41180: 9720.00 KiB | 1148 (1152) x 2160 |    1 |        2 | 0x10000900 | com.android.systemui.ImageWallpaper#0</span><br><span class="line">0x73aab44ed0:  280.50 KiB | 1080 (1088) x   66 |    1 |        1 | 0x10000900 | StatusBar#0</span><br><span class="line">0x73aab45bc0:  280.50 KiB | 1080 (1088) x   66 |    1 |        1 | 0x10000900 | StatusBar#0</span><br><span class="line">0x73aab46310: 9180.00 KiB | 1080 (1088) x 2160 |    1 |        1 | 0x10000900 | com.benben.viewpractice&#x2F;com.benben.viewpractice.MainActivity#0</span><br><span class="line">0x73aab46d30: 9180.00 KiB | 1080 (1088) x 2160 |    1 |        1 | 0x1a00 | FramebufferSurface</span><br><span class="line">0x73aab48560:  280.50 KiB | 1080 (1088) x   66 |    1 |        1 | 0x10000900 | StatusBar#0</span><br><span class="line">0x73aab49520:  561.00 KiB | 1080 (1088) x  132 |    1 |        1 | 0x10000900 | NavigationBar0#0</span><br><span class="line">0x73aab497f0:  561.00 KiB | 1080 (1088) x  132 |    1 |        1 | 0x10000900 | NavigationBar0#0</span><br><span class="line">0x73aab4a7b0:   20.50 KiB |   27 (  64) x   82 |    1 |        1 | 0x203 | RegionSamplingThread</span><br><span class="line">0x73aab4d8a0: 9180.00 KiB | 1080 (1088) x 2160 |    1 |        1 | 0x10000900 | com.benben.viewpractice&#x2F;com.benben.viewpractice.MainActivity#0</span><br><span class="line">0x73aab4ddb0: 9180.00 KiB | 1080 (1088) x 2160 |    1 |        1 | 0x10000900 | com.benben.viewpractice&#x2F;com.benben.viewpractice.MainActivity#0</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>com.benben.viewpractice</code> 的所有 Buffer 都没有使用，所以内存占用并没有统计进 app，如果有使用到，会在退后台，灭屏等场景进行部分回收与释放</p>
<p>可以看到，一个缓冲 Buffer 占用内存 9M 多，分辨率越大单个 Buffer 占用越大，如果有使用其它 Surface，如 <code>SurfaceView</code> 或 <code>TextureView</code> 则会更大</p>
]]></content>
      <categories>
        <category>ADB</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ADB</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>gfxinfo 测试UI性能</title>
    <url>/2020/12/20/Android/ADB/gfxinfo%20%E6%B5%8B%E8%AF%95UI%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="gfxinfo-测试UI性能"><a href="#gfxinfo-测试UI性能" class="headerlink" title="gfxinfo 测试UI性能"></a>gfxinfo 测试UI性能</h1><blockquote>
<p>参考：<a href="https://developer.android.com/training/testing/performance">https://developer.android.com/training/testing/performance</a></p>
</blockquote>
<p><code>gfxinfo</code> 整个进程生命周期中收集的帧数据的聚合分析输出到 logcat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys gfxinfo &lt;PackageName&gt;</span><br></pre></td></tr></table></figure>

<p>测试用例输出的信息如下（不同系统版本和不同品牌输出的信息会有出入）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whyred:&#x2F; $ dumpsys gfxinfo com.benben.viewpractice</span><br><span class="line">Applications Graphics Acceleration Info:</span><br><span class="line">Uptime: 333026982 Realtime: 333026982</span><br><span class="line"></span><br><span class="line">** Graphics info for pid 7200 [com.benben.viewpractice] **</span><br><span class="line"></span><br><span class="line">Stats since: 332992087287593ns</span><br><span class="line">Total frames rendered: 55</span><br><span class="line">Janky frames: 9 (16.36%)</span><br><span class="line">50th percentile: 6ms</span><br><span class="line">90th percentile: 34ms</span><br><span class="line">95th percentile: 117ms</span><br><span class="line">99th percentile: 150ms</span><br><span class="line">Number Missed Vsync: 2</span><br><span class="line">Number High input latency: 10</span><br><span class="line">Number Slow UI thread: 5</span><br><span class="line">Number Slow bitmap uploads: 1</span><br><span class="line">Number Slow issue draw commands: 0</span><br><span class="line">Number Frame deadline missed: 5</span><br><span class="line">HISTOGRAM: 5ms&#x3D;1 6ms&#x3D;31 7ms&#x3D;6 8ms&#x3D;5 9ms&#x3D;1 10ms&#x3D;1 11ms&#x3D;0 12ms&#x3D;0 13ms&#x3D;0 14ms&#x3D;1 15ms&#x3D;0 16ms&#x3D;0 17ms&#x3D;0 18ms&#x3D;0 19ms&#x3D;1 20ms&#x3D;1 21ms&#x3D;0 22ms&#x3D;0 23ms&#x3D;0 24ms&#x3D;0 25ms&#x3D;0 26ms&#x3D;0 27ms&#x3D;0 28ms&#x3D;0 29ms&#x3D;0 30ms&#x3D;0 31ms&#x3D;0 32ms&#x3D;1 34ms&#x3D;</span><br><span class="line">1 36ms&#x3D;0 38ms&#x3D;0 40ms&#x3D;0 42ms&#x3D;0 44ms&#x3D;0 46ms&#x3D;0 48ms&#x3D;0 53ms&#x3D;2 57ms&#x3D;0 61ms&#x3D;0 65ms&#x3D;0 69ms&#x3D;0 73ms&#x3D;0 77ms&#x3D;0 81ms&#x3D;0 85ms&#x3D;0 89ms&#x3D;0 93ms&#x3D;0 97ms&#x3D;0 101ms&#x3D;0 105ms&#x3D;0 109ms&#x3D;0 113ms&#x3D;0 117ms&#x3D;1 121ms&#x3D;0 125ms&#x3D;0 129ms&#x3D;0 133ms&#x3D;0 1</span><br><span class="line">50ms&#x3D;2 200ms&#x3D;0 250ms&#x3D;0 300ms&#x3D;0 350ms&#x3D;0 400ms&#x3D;0 450ms&#x3D;0 500ms&#x3D;0 550ms&#x3D;0 600ms&#x3D;0 650ms&#x3D;0 700ms&#x3D;0 750ms&#x3D;0 800ms&#x3D;0 850ms&#x3D;0 900ms&#x3D;0 950ms&#x3D;0 1000ms&#x3D;0 1050ms&#x3D;0 1100ms&#x3D;0 1150ms&#x3D;0 1200ms&#x3D;0 1250ms&#x3D;0 1300ms&#x3D;0 1350ms&#x3D;0 1</span><br><span class="line">400ms&#x3D;0 1450ms&#x3D;0 1500ms&#x3D;0 1550ms&#x3D;0 1600ms&#x3D;0 1650ms&#x3D;0 1700ms&#x3D;0 1750ms&#x3D;0 1800ms&#x3D;0 1850ms&#x3D;0 1900ms&#x3D;0 1950ms&#x3D;0 2000ms&#x3D;0 2050ms&#x3D;0 2100ms&#x3D;0 2150ms&#x3D;0 2200ms&#x3D;0 2250ms&#x3D;0 2300ms&#x3D;0 2350ms&#x3D;0 2400ms&#x3D;0 2450ms&#x3D;0 2500ms&#x3D;0 25</span><br><span class="line">50ms&#x3D;0 2600ms&#x3D;0 2650ms&#x3D;0 2700ms&#x3D;0 2750ms&#x3D;0 2800ms&#x3D;0 2850ms&#x3D;0 2900ms&#x3D;0 2950ms&#x3D;0 3000ms&#x3D;0 3050ms&#x3D;0 3100ms&#x3D;0 3150ms&#x3D;0 3200ms&#x3D;0 3250ms&#x3D;0 3300ms&#x3D;0 3350ms&#x3D;0 3400ms&#x3D;0 3450ms&#x3D;0 3500ms&#x3D;0 3550ms&#x3D;0 3600ms&#x3D;0 3650ms&#x3D;0 370</span><br><span class="line">0ms&#x3D;0 3750ms&#x3D;0 3800ms&#x3D;0 3850ms&#x3D;0 3900ms&#x3D;0 3950ms&#x3D;0 4000ms&#x3D;0 4050ms&#x3D;0 4100ms&#x3D;0 4150ms&#x3D;0 4200ms&#x3D;0 4250ms&#x3D;0 4300ms&#x3D;0 4350ms&#x3D;0 4400ms&#x3D;0 4450ms&#x3D;0 4500ms&#x3D;0 4550ms&#x3D;0 4600ms&#x3D;0 4650ms&#x3D;0 4700ms&#x3D;0 4750ms&#x3D;0 4800ms&#x3D;0 4850</span><br><span class="line">ms&#x3D;0 4900ms&#x3D;0 4950ms&#x3D;0</span><br><span class="line">50th gpu percentile: 4ms</span><br><span class="line">90th gpu percentile: 13ms</span><br><span class="line">95th gpu percentile: 14ms</span><br><span class="line">99th gpu percentile: 14ms</span><br><span class="line">GPU HISTOGRAM: 1ms&#x3D;0 2ms&#x3D;0 3ms&#x3D;6 4ms&#x3D;28 5ms&#x3D;0 6ms&#x3D;1 7ms&#x3D;0 8ms&#x3D;1 9ms&#x3D;0 10ms&#x3D;0 11ms&#x3D;0 12ms&#x3D;0 13ms&#x3D;2 14ms&#x3D;4 15ms&#x3D;0 16ms&#x3D;0 17ms&#x3D;0 18ms&#x3D;0 19ms&#x3D;0 20ms&#x3D;0 21ms&#x3D;0 22ms&#x3D;0 23ms&#x3D;0 24ms&#x3D;0 25ms&#x3D;0 4950ms&#x3D;0</span><br><span class="line">Font Cache (CPU):</span><br><span class="line">  Size: 15.01 kB</span><br><span class="line">  Glyph Count: 5</span><br><span class="line">CPU Caches:</span><br><span class="line">GPU Caches:</span><br><span class="line">  Other:</span><br><span class="line">    Other: 5.55 KB (1 entry)</span><br><span class="line">  Shadow Gaussian Falloff:</span><br><span class="line">    Texture: 128.00 bytes (1 entry)</span><br><span class="line">  SW Path Mask:</span><br><span class="line">    Texture: 579.89 KB (1 entry)</span><br><span class="line">  Image:</span><br><span class="line">    Texture: 6.82 MB (9 entries)</span><br><span class="line">  Scratch:</span><br><span class="line">    RenderTarget: 1.00 MB (1 entry)</span><br><span class="line">    Buffer Object: 78.00 KB (2 entries)</span><br><span class="line">    Texture: 5.00 MB (2 entries)</span><br><span class="line">Other Caches:</span><br><span class="line">                         Current &#x2F; Maximum</span><br><span class="line">  Layers Total           0.00 KB (numLayers &#x3D; 0)</span><br><span class="line">Total GPU memory usage:</span><br><span class="line">  14124124 bytes, 13.47 MB (9.39 MB is purgeable)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pipeline&#x3D;Skia (OpenGL)</span><br><span class="line">Profile data in ms:</span><br><span class="line"></span><br><span class="line">        com.benben.viewpractice&#x2F;com.benben.viewpractice.MainActivity&#x2F;android.view.ViewRootImpl@472c8b4 (visibility&#x3D;0)</span><br><span class="line">View hierarchy:</span><br><span class="line"></span><br><span class="line">  com.benben.viewpractice&#x2F;com.benben.viewpractice.MainActivity&#x2F;android.view.ViewRootImpl@472c8b4</span><br><span class="line">  18 views, 32.11 kB of render nodes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total ViewRootImpl   : 1</span><br><span class="line">Total attached Views : 18</span><br><span class="line">Total RenderNode     : 32.11 kB (used) &#x2F; 110.07 kB (capacity)</span><br></pre></td></tr></table></figure>

<p>开始一栏是统计所有帧的聚合数据，主要作用是查看渲染性能以及帧的稳定性</p>
<ul>
<li><code>Graphics info for pid 7200 [com.benben.viewpractice]</code>：包名和 <code>pid</code></li>
<li><code>Total frames rendered: 55</code>：共收集了55帧</li>
<li><code>Janky frames: 9 (16.36%)</code>：55帧中有9帧发生了 Janky，即单帧耗时超过了 16ms，卡顿考为 16.36%</li>
<li><code>50th percentile: 6ms</code>：所有帧耗时排序后，其中前50%最大的耗时帧的耗时为6ms</li>
<li><code>90th percentile: 34ms</code>：同上，依次类推</li>
<li><code>95th percentile: 117ms</code>：同上，依次类推</li>
<li><code>99th percentile: 150ms</code>：同上，依次类推</li>
<li><code>Number Missed Vsync: 2</code>：垂直同步失败的帧数为2</li>
<li><code>Number High input latency: 10</code>：处理input耗时的帧数为10</li>
<li><code>Number Slow UI thread: 5</code>：因UI线程的工作而导致耗时的帧数为5</li>
<li><code>Number Slow bitmap uploads: 1</code>： 因bitmap加载导致耗时的帧数为1</li>
<li><code>Number Slow issue draw commands: 0</code>：因绘制问题导致耗时的帧数为0</li>
<li><code>HISTOGRAM: 5ms=1 6ms=31 7ms=6 8ms=5 9ms=1 10ms=1 ...</code>：直方图列表，说明耗时 5ms 帧数为 1，6ms 帧数为 31</li>
</ul>
<p>剩余的是一写内存信息和视图信息</p>
<h4 id="Framestats-数据"><a href="#Framestats-数据" class="headerlink" title="Framestats 数据"></a><code>Framestats</code> 数据</h4><p>该命令会从应用生成的最近 120 个帧中输出带有纳秒时间戳的帧时间信息。【有的系统无效，有的只会输出10帧等等】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt; framestats</span><br></pre></td></tr></table></figure>

<p>测试用例输出的信息如下，重点关注PROFILEDATA信息，数据块是 CVS 格式输出，具体含义参考：<a href="https://developer.android.com/training/testing/performance#aggregate">https://developer.android.com/training/testing/performance#aggregate</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBuffe</span><br><span class="line">rDuration,QueueBufferDuration,GpuCompleted,</span><br><span class="line">2,333378148003383,333378148003383,0,0,333378148003383,333378148003383,333378148003383,333378148003383,333378152421573,333378152423083,333378152547614,333378153769021,333378154564906,172656,282032,333378157419</span><br><span class="line">907</span><br><span class="line">---PROFILEDATA---</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/20/Android/ADB/gfxinfo%20%E6%B5%8B%E8%AF%95UI%E6%80%A7%E8%83%BD/gfxinfo_Framestats.png"></p>
<p>运行 <code>gfxinfo</code>、复制输出、将其粘贴到电子表格应用并将数据绘制成堆积条形图的结果</p>
<h3 id="控制统计信息收集的时段"><a href="#控制统计信息收集的时段" class="headerlink" title="控制统计信息收集的时段"></a>控制统计信息收集的时段</h3><p><code>Framestats</code> 和简单的帧时间均可在极短的时间内（相当于约 2 秒渲染）收集数据。要精确控制此时间范围（例如，将数据限制于特定动画），您可以重置所有计数器并汇总收集的统计信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt; reset</span><br></pre></td></tr></table></figure>

<p>这也可以与转储命令结合使用来定期进行收集和重置，从而持续捕获时间范围不到 2 秒的帧</p>
]]></content>
      <categories>
        <category>ADB</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ADB</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 ADB 命令</title>
    <url>/2020/12/20/Android/ADB/%E5%B8%B8%E7%94%A8%20ADB%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常用-ADB-命令"><a href="#常用-ADB-命令" class="headerlink" title="常用 ADB 命令"></a>常用 ADB 命令</h1><ul>
<li><p>当前显示的activity</p>
<p><code>dumpsys window | grep mCurrentFocus</code></p>
</li>
<li><p>显示cpu状态</p>
<p><code>dumpsys cpuinfo</code></p>
</li>
<li><p>查看内存信息</p>
<p><code>dumpsys meminfo &lt;PackageName or Pid&gt;</code></p>
</li>
<li><p>查看内存详细信息</p>
<p><code>showmap -p pid</code></p>
</li>
<li><p>优化dex</p>
<p><code>cmd package bg-dexopt-job</code></p>
</li>
<li><p>dump 内存</p>
<p><code>am dumpheap 16634 /data/local/tmp/health.hprof</code></p>
</li>
<li><p>启动 <code>Activity</code></p>
<p><code>am start -n &lt;PackageName&gt;/&lt;Activity_Reference&gt;</code></p>
</li>
<li><p>查看分辨率和密度</p>
<p><code>wm size</code></p>
<p><code>wm density</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>ADB</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title>Navigation</title>
    <url>/2020/12/10/Android/Jetpack/Navigation/</url>
    <content><![CDATA[<h1 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h1><blockquote>
<p>使用：<a href="https://developer.android.com/guide/navigation">https://developer.android.com/guide/navigation</a></p>
</blockquote>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><blockquote>
<p>以 Android studio demo 示例为例</p>
</blockquote>
<p>默认的 <code>NavController</code> 在构造函数只添加了两个导航器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NavController</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    mNavigatorProvider.addNavigator(<span class="keyword">new</span> NavGraphNavigator(mNavigatorProvider));</span><br><span class="line">    mNavigatorProvider.addNavigator(<span class="keyword">new</span> ActivityNavigator(mContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>NavHostFragment</code> 中增加了对 <code>Fragment</code> 和 <code>Dialog</code> 导航的兼容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreateNavController</span><span class="params">(<span class="meta">@NonNull</span> NavController navController)</span> </span>&#123;</span><br><span class="line">    navController.getNavigatorProvider().addNavigator(</span><br><span class="line">            <span class="keyword">new</span> DialogFragmentNavigator(requireContext(), getChildFragmentManager()));</span><br><span class="line">    navController.getNavigatorProvider().addNavigator(createFragmentNavigator()); <span class="comment">// FragmentNavigator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul>
<li><p>路由中所有的路由节点都需要在 <code>mobile_navigation</code> 声明，在中大型多团队的项目并不友好，具有严重的耦合</p>
<ul>
<li><p>解决方式：</p>
<p>可以通过注解处理器进行解决，将 <code>mobile_navigation</code> 里的参数全部挪到注解中，然后通过在对应的 <code>Activity</code> <code>Fragment</code> <code>Dialog</code> 中进行注解声明，然后注解处理器将注解内容解析成对应的配置文件存放在 <code>assets</code> 目录中，在应用启动时读取该 <code>json</code> 进行手动配置，参考：</p>
<p><code>androidx.navigation.NavInflater#inflate(android.content.res.Resources, android.content.res.XmlResourceParser, android.util.AttributeSet, int)</code></p>
</li>
</ul>
</li>
<li><p>在 <code>FragmentNavigator</code> 中导航使用的是 <code>replace</code>，造成 <code>Fragment</code> 走完整的生命周期，这也是不可接受的</p>
<ul>
<li><p>解决方式：</p>
<p>参考 <code>FragmentNavigator</code> 重新编写一份添加到 <code>NavigatorProvider</code> 中，对 <code>replace</code> 逻辑进行重新编排</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>启动优化</title>
    <url>/2020/12/27/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E4%B8%80%E3%80%81%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h1><h4 id="app启动流程"><a href="#app启动流程" class="headerlink" title="app启动流程"></a>app启动流程</h4><p><code>Click Event -&gt; IP -&gt; Process.start -&gt; ActivityThread -&gt; bindApplication -&gt; LifeCycle -&gt; ViewRootImpl</code></p>
<p>相关任务：</p>
<ul>
<li>冷启动之前<ol>
<li>启动<code>app</code></li>
<li>加载空白<code>Window</code></li>
<li>创建进程</li>
</ol>
</li>
<li>随后任务<ol>
<li>创建<code>Application</code></li>
<li>创建主线程</li>
<li>创建<code>MainActivity</code></li>
</ol>
</li>
<li>绘制任务<ol>
<li>加载布局</li>
<li>布置屏幕</li>
<li>首帧绘制</li>
</ol>
</li>
</ul>
<h4 id="相关工具的使用"><a href="#相关工具的使用" class="headerlink" title="相关工具的使用"></a>相关工具的使用</h4><p><a href="/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/TraceView/">参考：TraceView</a></p>
<p><a href="/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Systrace/">参考：Systrace</a></p>
<h4 id="启动时间测量方式"><a href="#启动时间测量方式" class="headerlink" title="启动时间测量方式"></a>启动时间测量方式</h4><p><a href="/2020/12/25/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E6%B5%8B%E9%87%8F%E6%96%B9%E5%BC%8F/">参考：启动时间测量方式</a></p>
<h4 id="获取方法耗时"><a href="#获取方法耗时" class="headerlink" title="获取方法耗时"></a>获取方法耗时</h4><p><a href="/2020/12/25/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E8%80%97%E6%97%B6/">参考：获取方法耗时</a></p>
<h4 id="启动优化核心思想"><a href="#启动优化核心思想" class="headerlink" title="启动优化核心思想"></a>启动优化核心思想</h4><ul>
<li>子线程分担主线程任务，并行减少时间</li>
<li>异步、延迟、懒加载</li>
</ul>
<h4 id="启动优化常规方案"><a href="#启动优化常规方案" class="headerlink" title="启动优化常规方案"></a>启动优化常规方案</h4><h5 id="一、优化小技巧"><a href="#一、优化小技巧" class="headerlink" title="一、优化小技巧"></a>一、优化小技巧</h5><p>注意一：<code>Theme</code> 切换只是感觉上的快，实际启动时间并没有改变</p>
<p>注意二：会延长低版本（7.0或6.0以下）手机闪屏时间，需要综合考量是否需要在低版本使用 <code>Theme</code></p>
<p><a href="/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8Theme/">参考设置启动Theme</a></p>
<h5 id="二、采用启动器实现并发初始化"><a href="#二、采用启动器实现并发初始化" class="headerlink" title="二、采用启动器实现并发初始化"></a>二、采用启动器实现并发初始化</h5><ol>
<li><p><a href="https://github.com/alibaba/alpha">阿里开源 <code>alpha</code> 启动器</a></p>
<p>alpha 定位为异步启动框架。<strong>在执行启动任务时判断其是否是主线程执行，如果是则通过 handler#post 发送出去排队处理, 否则交给线程池处理。</strong></p>
</li>
<li><p><a href="https://github.com/YummyLau/Anchors">更复杂图例启动器，适合负责场景</a></p>
</li>
</ol>
<h5 id="三、延迟初始化"><a href="#三、延迟初始化" class="headerlink" title="三、延迟初始化"></a>三、延迟初始化</h5><p>在界面的真实数据展示里的UI显示后对可延迟初始化的任务进行初始化,如列表的第一条数据、可交互控件的显示等</p>
<ul>
<li><p><code>android 6.0</code> 之前：</p>
<p><strong>发送延迟消息对任务进行初始化</strong></p>
<p>缺点：无法确定延时的时长</p>
</li>
<li><p><code>android 6.0（含6.0）</code> 使用 <code>IdleHandler</code> 在app闲置时初始化，可有效利用闲置时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayInitDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Task&gt; mDelayTasks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DelayInitDispatcher <span class="title">addTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">        mDelayTasks.add(task);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mDelayTasks.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    Task task = mDelayTasks.poll();</span><br><span class="line">                    <span class="comment">// 执行 task</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> !mDelayTasks.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="四、懒加载"><a href="#四、懒加载" class="headerlink" title="四、懒加载"></a>四、懒加载</h5><p>在需要用到的时候再进行加载</p>
<h4 id="其它优化方案"><a href="#其它优化方案" class="headerlink" title="其它优化方案"></a>其它优化方案</h4><h5 id="一、Multidex-阶段提前加载-SharedPreference"><a href="#一、Multidex-阶段提前加载-SharedPreference" class="headerlink" title="一、Multidex 阶段提前加载 SharedPreference"></a>一、<code>Multidex</code> 阶段提前加载 <code>SharedPreference</code></h5><p><a href="https://developer.android.com/studio/build/multidex">Multidex官方文档</a></p>
<p>在 <code>Multidex</code> 加载阶段，由于此阶段更多是在 <code>io</code> 操作，所以可以充分利用此阶段的 <code>CPU</code> 加载 <code>SP</code></p>
<p><code>Multidex</code> 优化参考项目：<a href="https://github.com/lanshifu/MultiDexTest">MultiDex优化源码</a></p>
<p>注意：该方法只在低版本（Android 5.0 之前的平台，即 Dalvik 虚拟机）有效</p>
<h5 id="二、启动阶段不启动子进程"><a href="#二、启动阶段不启动子进程" class="headerlink" title="二、启动阶段不启动子进程"></a>二、启动阶段不启动子进程</h5><ul>
<li>子进程会共享 <code>CPU</code> 资源，导致主进程 <code>CPU</code> 紧张</li>
<li>注意：<code>Application</code> 的 <code>onCreate</code> 之前会启动 <code>ContentProvider</code></li>
</ul>
<h5 id="三、提前异步加载类字节码"><a href="#三、提前异步加载类字节码" class="headerlink" title="三、提前异步加载类字节码"></a>三、提前异步加载类字节码</h5><p>一个类的加载本身可能会涉及上千个其它类，可以提前异步加载类字节码</p>
<p>监控哪些类需要提前加载：可以替换掉系统的<code>ClassLoader</code> 用自己的 <code>ClassLoader</code> 来记录加载时间，按需选取需要异步加载的类</p>
<ul>
<li>Class.forName() 只加载类本身及其静态变量的引用类</li>
<li>new 类实例 可以额外加载类成员变量的引用类</li>
</ul>
<h5 id="四、启动阶段抑制-GC"><a href="#四、启动阶段抑制-GC" class="headerlink" title="四、启动阶段抑制 GC"></a>四、启动阶段抑制 GC</h5><p><a href="/2020/12/27/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E7%9B%91%E6%8E%A7GC/">监控GC</a></p>
<p><a href="https://developer.aliyun.com/article/672750">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></p>
<h5 id="五、更优的-CPU-资源调度"><a href="#五、更优的-CPU-资源调度" class="headerlink" title="五、更优的 CPU 资源调度"></a>五、更优的 CPU 资源调度</h5><p><a href="https://github.com/Tencent/Hardcoder">Hardcoder 让 App 充分调度系统资源</a></p>
<h5 id="六、数据重排"><a href="#六、数据重排" class="headerlink" title="六、数据重排"></a>六、数据重排</h5><p><a href="https://developer.aliyun.com/article/680526">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></p>
<p><a href="https://github.com/facebook/redex">Facebook Redex字节码优化工具</a></p>
<h4 id="后期维护"><a href="#后期维护" class="headerlink" title="后期维护"></a>后期维护</h4><ul>
<li>收敛修改涉及启动相关代码的权限：结合 CI 修改启动代码需要 Review 代码并测试通过才可合入</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><a href="https://juejin.cn/post/6844903958113157128">面试官：今日头条启动很快，你觉得可能是做了哪些优化？</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>布局优化</title>
    <url>/2021/01/05/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E4%B8%89%E3%80%81%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h1><blockquote>
<p>相关参考：<a href="https://androidperformance.com/2019/07/27/Android-Hardware-Layer/">https://androidperformance.com/2019/07/27/Android-Hardware-Layer/</a></p>
</blockquote>
<h4 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h4><ul>
<li><a href="(%E5%B7%A5%E5%85%B7/Systrace.md)"><code>Systrace</code></a>：<ul>
<li> 关注 <code>Frames</code> 行：正常绿色，丢帧黄色或红色</li>
<li>关注 <code>Alerts</code> 栏：自动分析性能问题的一些条目</li>
</ul>
</li>
<li><code>Layout Inspector</code>：<ul>
<li><code>Android Studio</code> 自带工具，查看视图层次结构</li>
</ul>
</li>
<li><code>Choreographer</code>：<ul>
<li>系统 <code>api</code> 监控帧率：<a href="/2021/01/05/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E5%B8%A7%E7%8E%87/#more">获取帧率</a></li>
</ul>
</li>
<li><code>uiautomatorviewer</code>：<ul>
<li>SDK 自带布局查看工具：<code>&lt;SDK&gt;/tools/bin/uiautomatorviewer.bat</code></li>
</ul>
</li>
<li><code>adb</code> 命令测试：<ul>
<li><a href="/2020/12/20/Android/ADB/gfxinfo%20%E6%B5%8B%E8%AF%95UI%E6%80%A7%E8%83%BD/"><code>adb shell dumpsys gfxinfo com.**.** </code></a></li>
</ul>
</li>
</ul>
<h4 id="Android-布局加载原理"><a href="#Android-布局加载原理" class="headerlink" title="Android 布局加载原理"></a>Android 布局加载原理</h4><ol>
<li><code>setContentView</code>：调用 <code>LayoutInflater.inflate</code></li>
<li><code>Resources.getLayout</code>：解析 <code>xml</code> IO 耗时</li>
<li><code>LayoutInflater.createViewFromTag</code>：通过 <code>Factory2</code> 、 <code>Factory</code> 和 反射创建 <code>View</code> 【备注：<code>mPrivateFactory</code> 为创建 <code>Fragment</code> 用的】</li>
</ol>
<p>从上述流程可知两个耗时点：<strong>加载 <code>xml</code> 的 IO 耗时，反射创建 <code>View</code> 耗时</strong></p>
<p><strong>【说明】</strong><code>Factory2</code> 在 <code>AppCompatActivity.onCraete</code> 中设置，用于将 <code>TextView</code> 转换成 <code>AppCompatTextView</code> 等适配</p>
<p><strong>【注意】</strong>如果要手动设置 <code>Factory2</code> 要参考 <code>AppCompatViewInflater</code> 的兼容实现</p>
<h4 id="获取界面布局耗时"><a href="#获取界面布局耗时" class="headerlink" title="获取界面布局耗时"></a>获取界面布局耗时</h4><p><a href="/2021/01/05/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E7%95%8C%E9%9D%A2%E5%B8%83%E5%B1%80%E8%80%97%E6%97%B6/">参考：获取界面布局耗时</a></p>
<h4 id="布局加载优化"><a href="#布局加载优化" class="headerlink" title="布局加载优化"></a>布局加载优化</h4><h5 id="一、异步创建布局：AsyncLayoutInflater"><a href="#一、异步创建布局：AsyncLayoutInflater" class="headerlink" title="一、异步创建布局：AsyncLayoutInflater"></a>一、异步创建布局：<code>AsyncLayoutInflater</code></h5><p>原理：内部开了单独一个线程专门用于异步创建 <code>View</code>，采用 <code>ArrayBlockingQueue</code> 队列做无限循环取数据，对于消息类还做了 <code>SynchronizedPool</code> 对象池，在子线程装载 <code>View</code> 失败还会在主线程再次装载一次</p>
<p><strong>【注意一】</strong>由于采用系统自身的 <code>Inflater</code> 装载 <code>View</code>，会失去 <code>AppCompat</code> 的兼容效果，可以将源码拷贝出来修改成兼容将 <code>TextView</code> 转换成 <code>AppCompatTextView</code> 等适配</p>
<p><strong>【注意二】</strong>由于是在子线程进行装载，待装载的 <code>View</code> 内部不能有依赖主线程的操作</p>
<h5 id="二、Java-代码写布局"><a href="#二、Java-代码写布局" class="headerlink" title="二、Java 代码写布局"></a>二、Java 代码写布局</h5><p>通过 <code>xml</code> 的方式编写布局，会有 <code>IO</code> 和反射耗时，可通过 <code>Java</code> 代码的方式从本质上解决性能问题。</p>
<p>该方式会引入新问题：不便于开发、可维护性差</p>
<h5 id="三、X2C-方案"><a href="#三、X2C-方案" class="headerlink" title="三、X2C 方案"></a>三、X2C 方案</h5><p>项目地址：<a href="https://github.com/iReaderAndroid/X2C">https://github.com/iReaderAndroid/X2C</a></p>
<p>原理：通过 <code>APT</code> 编译期将 <code>xml</code> 文件翻译为 <code>Java</code> 布局文件</p>
<p>该方案保留了 <code>xml</code> 的优点，同时从根本上解决性能问题</p>
<p><strong>【注意】</strong>该方案存在兼容性问题，部分属性 <code>Java</code> 代码时不支持的，同时也失去了 <code>AppCompat</code> 的兼容效果</p>
<h4 id="进阶布局优化"><a href="#进阶布局优化" class="headerlink" title="进阶布局优化"></a>进阶布局优化</h4><h5 id="一、异步布局框架-Litho"><a href="#一、异步布局框架-Litho" class="headerlink" title="一、异步布局框架 Litho"></a>一、异步布局框架 <code>Litho</code></h5><p><a href="https://github.com/facebook/litho"><code>Litho</code></a> 是 Facebook 开源的一款在Android上高效建立UI的声明式框架</p>
<p>PS：这里没有研究，自行参考官方文档实现方式</p>
<h5 id="二、条件允许可以使用-Flutter"><a href="#二、条件允许可以使用-Flutter" class="headerlink" title="二、条件允许可以使用 Flutter"></a>二、条件允许可以使用 Flutter</h5><h4 id="视图绘制优化"><a href="#视图绘制优化" class="headerlink" title="视图绘制优化"></a>视图绘制优化</h4><p>布局流程：测量 -&gt; 布局 -&gt; 绘制</p>
<ul>
<li><p>减少每个布局流程的耗时</p>
</li>
<li><p>减少布局层级和复杂度：有的布局会多次测量，如果产生嵌套，就会呈几何上升的进行测量，推荐使用 <code>ConstraintLayout</code> 约束布局</p>
</li>
<li><p>不嵌套使用 <code>RelativeLayout</code>，会对子 <code>View</code> 做两次测量</p>
</li>
<li><p>不在嵌套 <code>LinearLayout</code> 中使用 <code>weight</code>，会对子 <code>View</code> 做两次测量</p>
</li>
<li><p><code>merge</code> 标签：可以减少一个层级，用于根 <code>View</code></p>
</li>
<li><p><code>ViewStub</code>：可以在真正需要使用时才加载布局</p>
</li>
<li><p>避免过度绘制：<a href="https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering">官方文档</a></p>
<ul>
<li>减少多余背景色，减少复杂的 <code>Shape</code> 的使用</li>
<li>避层级叠加</li>
<li>当在 <code>onDraw</code> 中绘制的内容前后有产生覆盖的，需要使用 <code>clipRect</code> 来屏蔽被覆盖的区域，如果需要绘制的对象不在剪裁范围内，需要直接返回，减少<code>CPU</code> 和 <code>GPU</code> 的计算工作，如前后绘制了两个有重叠的<code>Bitmap</code></li>
</ul>
</li>
<li><p>避免在 <code>onDraw</code> 中创建对象和执行耗时操作</p>
</li>
<li><p>在 <code>Android 5.0</code> 以下的自定义 <code>View</code> 触发刷新需要考虑刷新的范围 <code>invalidate(int l, int t, int r, int b)</code>，5.0 以上的直接 <code>invalidate()</code> 即可</p>
</li>
<li><p><code>canvas</code> 在使用离屏缓存时很耗资源，范围设置为所需范围即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val count = canvas.saveLayer(<span class="number">100f</span>, <span class="number">100f</span>, <span class="number">200f</span>, <span class="number">200f</span>, paint)</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">canvas.restoreToCount(count)</span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>Systrace</code> 发现每一帧都在 <code>buildDrawingCache/SW</code> （主线程） 或 <code>buildLayer</code> （渲染线程），那么需要检查代码的逻辑，尝试调整 <code>LayerType</code> 查看情况是否改良</p>
<ul>
<li>如果只是单纯的做动画，不动态修改 View 的内容，那么性能表现为 ：Hardware Layer &gt;= Software Layer &gt; Normal Layer</li>
<li>如果做动画同时动态修改 View 的内容，那么性能表现为 ：Normal Layer &gt; Software Layer = Hardware Layer</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>内存优化</title>
    <url>/2020/12/31/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><blockquote>
<p>意义：减少因为频繁GC导致的卡顿，减少因为内存占用应用存活率降低</p>
</blockquote>
<h4 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h4><ul>
<li>内存抖动：表现为内存锯齿状，频繁GC，导致卡顿</li>
<li>内存泄露：可用内存减少，频繁GC</li>
<li>内存溢出：OOM、程序异常</li>
</ul>
<h4 id="相关工具的使用"><a href="#相关工具的使用" class="headerlink" title="相关工具的使用"></a>相关工具的使用</h4><p><a href="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Profiler/">参考：Memory Profiler</a></p>
<p><a href="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/">参考：Memory Analyzer</a></p>
<p><a href="/2020/12/29/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Leakcanary/">参考：Leak Canary</a></p>
<h4 id="Dalvik-与-Art-的区别"><a href="#Dalvik-与-Art-的区别" class="headerlink" title="Dalvik 与 Art 的区别"></a><code>Dalvik</code> 与 <code>Art</code> 的区别</h4><ul>
<li><code>Dalvik</code> 仅固定一种回收算法</li>
<li><code>Art</code> 回收算法可运行期切换，具备内存整理能力，减少内存空洞</li>
</ul>
<h4 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h4><ul>
<li>进程分类（优先级从高到低）：前台进程、可见进程、服务进程、后台进程、空进程</li>
<li>回收收益：系统会考虑回收收益执行回收力度</li>
</ul>
<h4 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h4><blockquote>
<p>内存频繁分配和回收导致内存不稳定，频繁 <code>GC</code> ，易导致卡顿和 <code>OOM</code></p>
</blockquote>
<p>频繁创建对象、释放对象，导致内存碎片化严重</p>
<p>不连续的内存片无法被分配，导致 <code>OOM</code></p>
<p><strong>解决技巧：</strong>通过 <code>Memory Profiler</code> 找对象，重点寻找循环或者频繁调用的地方</p>
<p><strong>【注意】</strong>内存泄漏造成内存减少，也会出现频繁回收对象而出现内存抖动</p>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p><code>dump</code>  出的内存文件通过 <code>Memory Analyzer</code> 工具进行分析</p>
<p><a href="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/">参考：Memory Analyzer</a></p>
<p><a href="/2020/12/30/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/dump%20%E5%86%85%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">参考：dump 内存的几种方式</a></p>
<h4 id="大图监控"><a href="#大图监控" class="headerlink" title="大图监控"></a>大图监控</h4><p>由于图片是占用内存的大头，所以必须对其严格控制，可以使用 <code>AOP</code> 或 <code>ART</code> 方式获取相应控件的大小和 <code>Bitmap</code> 的大小，提前警告</p>
<p><a href="/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/ART-Hook/">参考：ART-Hook</a></p>
<p><a href="/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/AOP-Aspectjx/">参考：Aspectjx</a></p>
<h4 id="线上内存监控"><a href="#线上内存监控" class="headerlink" title="线上内存监控"></a>线上内存监控</h4><ul>
<li>常规方案：超过最大内存80%，<code>Dump</code> 内存，待到 <code>wifi</code> 环境下回传文件分析<ul>
<li><code>Dump</code> 文件太大，和对象数正相关，可剪裁</li>
<li>文件较大上传失败率高，分析困难</li>
<li>效果有限</li>
</ul>
</li>
<li><a href="/2020/12/29/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Leakcanary/"><code>LeakCanary</code></a> 线上监控，预设怀疑点，发现泄漏回传<ul>
<li>不适合所有场景，需要预设坏一点</li>
<li>该库分析比较耗时，容易OOM</li>
<li>建议定制 <code>LeakCanary</code></li>
</ul>
</li>
</ul>
<h4 id="线上监控完整方案"><a href="#线上监控完整方案" class="headerlink" title="线上监控完整方案"></a>线上监控完整方案</h4><ul>
<li>待机内存、重点模块内存、OOM率</li>
<li>整体及重点模块GC次数、GC时间</li>
<li>增强 <code>LeakCanary</code> 自动化内存泄漏分析</li>
</ul>
<h4 id="优化大方向"><a href="#优化大方向" class="headerlink" title="优化大方向"></a>优化大方向</h4><ul>
<li>内存泄漏</li>
<li>内存抖动</li>
<li>Bitmap</li>
</ul>
<h4 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h4><ul>
<li><p>设置 <code>LargeHeap</code> 属性，向系统申请更多内存</p>
</li>
<li><p>系统回调 <code>onTrimMemory</code> 根据回调级别做适当的资源释放，当系统回调严重级别时可以将所有界面关闭强制重启主界面的操作</p>
</li>
<li><p>使用优化过的集合：<code>SparseArray</code> 、<code>ArrayMap</code>，性能虽不及 <code>HashMap</code>，但在数据量较少的情况下是可以接受的</p>
</li>
<li><p>谨慎使用 <code>SharedPreference</code>，首次加载时会将涉及的文件所有数据加载到内存里，如果单个文件过大造成内存占用过多</p>
</li>
<li><p>可以考虑使用 <code>IntDef</code> <code>StringDef</code> 来减少枚举类型的使用</p>
</li>
<li><p>谨慎使用外部库</p>
</li>
<li><p>尽可能使用静态内部类减少外部引用</p>
</li>
<li><p>图片优化</p>
<ul>
<li>对图片质量要求不高的可以适当降低图片质量，如 ARGB_4444 或 RGB_565</li>
<li><a href="/2020/11/27/Android/Bitmap/">适当对图片进行缩小加载</a></li>
<li><a href="/2020/11/27/Android/Bitmap/">重用 Bitmap 内存</a></li>
<li>类似 Glide 图片加载库，默认兼容 gif 和 webp，但是执行效率和内存使用率并不高，可以接入 giflib 和 libwebp 进行优化</li>
<li>Item 被回收不可见时释放图片的引用<ul>
<li><code>ListView</code>：条目被回收后都会重新绑定数据，只需要在 <code>ImageView.onDetachFromWindow()</code> 时释放图片引用</li>
<li><code>RecycleView</code>：当条目不可见时优先放入 <code>mCacheView</code> 缓存中，重新展示并不会触发 <code>bindViewHolder</code> 来绑定数据，只有被收录到 <code>mRecyclePool</code> 中才会拿出来复用并绑定，需要在 <code>Adapter.onViewRecycled()</code> 函数中释放图片引用，该函数会在条目收录到 <code>mRecyclePool</code> 缓存时回调</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>卡顿优化</title>
    <url>/2021/01/07/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%9B%9B%E3%80%81%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h1><blockquote>
<p>相关参考：<a href="https://androidperformance.com/2019/07/27/Android-Hardware-Layer/">https://androidperformance.com/2019/07/27/Android-Hardware-Layer/</a></p>
</blockquote>
<p>用户对于内存占用过高、网络消耗过大等可能不易察觉，但是app卡顿会很直观的体现在交互上，需要重点针对</p>
<p>卡顿产生的原因很多，代码质量不好、可用内存过低、绘制复杂、IO占用等都会导致卡顿，且线上用户发生的卡顿线下不易复现，与使用场景强相关</p>
<h4 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h4><ul>
<li><a href="/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/TraceView/">CPU Profile</a></li>
<li><a href="/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Systrace/"><code>Systrace</code></a></li>
<li><a href="/2021/01/06/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/StrictMode/"><code>StrictMode</code></a></li>
</ul>
<h4 id="自动化检测卡顿方案"><a href="#自动化检测卡顿方案" class="headerlink" title="自动化检测卡顿方案"></a>自动化检测卡顿方案</h4><blockquote>
<p>由于卡顿与场景强相关，线下工具复现并不好实现，需要线上自动化监控</p>
</blockquote>
<p><strong>方案原理</strong></p>
<p><code>Android</code> 的消息处理机制，一个线程只有一个 <code>Looper</code>，<code>mLogging</code> 对象再每个message处理前后都会调用，主线程发生卡顿，说明 <code>dispatchMessage</code> 在执行耗时操作。当匹配到 <code> &gt;&gt;&gt;&gt;&gt; Dispatching</code> 我们可以在子线程（<code>HanderThread</code>）中执行一个任务，当达到我们设定的阈值时获取主线程的堆栈来定位耗时函数，当匹配到 <code>&lt;&lt;&lt;&lt;&lt; Finished</code> 时将任务取消掉。</p>
<p><code>Looper</code> 代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Looper.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">	<span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">		logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	msg.target.dispatchMessage(msg);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">		logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关三方库 <code>BlockCanary </code>：<a href="https://github.com/markzhai/AndroidPerformanceMonitor">https://github.com/markzhai/AndroidPerformanceMonitor</a></p>
<p>该库优点：非侵入式，简单方便的定位到代码的某一行</p>
<p>该库缺点：捕获到的卡顿堆栈可能不准确，并不是真正的卡顿点</p>
<p>修改方案：采用高频采集堆栈的形式，如卡顿阈值设置500ms，每100ms采集一次堆栈信息，当真的操作500ms阈值，将其中采集的堆栈信息保存起来在合适的时机上报</p>
<p>再优化：由于上述高频采集会产生很多无效堆栈，且上报数据量过大会造成服务端压力过大，对问题分析也并不友好。由于一个卡顿下多个堆栈大概率重复，找出重复的堆栈进行保存和上传即可</p>
<h4 id="ANR异常"><a href="#ANR异常" class="headerlink" title="ANR异常"></a>ANR异常</h4><h5 id="场景（ActivityManagerService）"><a href="#场景（ActivityManagerService）" class="headerlink" title="场景（ActivityManagerService）"></a>场景（<code>ActivityManagerService</code>）</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">TimeOut</th>
<th align="center">是否弹框提示</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Activity</td>
<td align="center">10</td>
<td align="center">提示</td>
<td align="center">Activity切换时会设置TimeOut</td>
</tr>
<tr>
<td align="center">BroadCast</td>
<td align="center">10，60</td>
<td align="center">无感知场景不会有提示</td>
<td align="center">系统默认前后台广播，厂商会额外定制广播</td>
</tr>
<tr>
<td align="center">Service</td>
<td align="center">10</td>
<td align="center">无感知场景不会有提示</td>
<td align="center">创建Servier时会设置TimeOut</td>
</tr>
<tr>
<td align="center">Provider</td>
<td align="center">10</td>
<td align="center">无感知场景不会有提示</td>
<td align="center">创建Provider时会设置TimeOut</td>
</tr>
<tr>
<td align="center">Input</td>
<td align="center">5</td>
<td align="center">提示</td>
<td align="center">厂商或平台会调整此阈值，MTK调整至8秒</td>
</tr>
<tr>
<td align="center">Finalizer</td>
<td align="center">10</td>
<td align="center">Crash</td>
<td align="center">默认10S，厂商调整至20S~120S</td>
</tr>
</tbody></table>
<h5 id="ANR触发原理"><a href="#ANR触发原理" class="headerlink" title="ANR触发原理"></a>ANR触发原理</h5><p>简单来说就是埋炸弹，如在启动服务时，会发送一条延迟消息，这里称为定时炸弹消息，当服务能够正常启动会把这条炸弹消息移除，如果时间到了还没有移除，说明服务没有在指定的时间内正常启动，执行该定时炸弹消息，最终会执行到 <code>AppErrors#appNotResponding</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">appNotResponding</span><span class="params">(ProcessRecord app, ActivityRecord activity,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord parent, <span class="keyword">boolean</span> aboveSystem, <span class="keyword">final</span> String annotation)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">//1、写入event log</span></span><br><span class="line">      EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid,</span><br><span class="line">                app.processName, app.info.flags, annotation);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      	<span class="comment">// 2、收集需要的log，anr、cpu等，StringBuilder凭借</span></span><br><span class="line">        StringBuilder info = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        info.setLength(<span class="number">0</span>);</span><br><span class="line">        info.append(<span class="string">&quot;ANR in &quot;</span>).append(app.processName);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span> &amp;&amp; activity.shortComponentName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.append(<span class="string">&quot; (&quot;</span>).append(activity.shortComponentName).append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        info.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        info.append(<span class="string">&quot;PID: &quot;</span>).append(app.pid).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.append(<span class="string">&quot;Reason: &quot;</span>).append(annotation).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span> &amp;&amp; parent != activity) &#123;</span><br><span class="line">            info.append(<span class="string">&quot;Parent: &quot;</span>).append(parent.shortComponentName).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessCpuTracker processCpuTracker = <span class="keyword">new</span> ProcessCpuTracker(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 3、dump堆栈信息，包括java堆栈和native堆栈，保存到文件中</span></span><br><span class="line">    File tracesFile = ActivityManagerService.dumpStackTraces(</span><br><span class="line">            <span class="keyword">true</span>, firstPids,</span><br><span class="line">            (isSilentANR) ? <span class="keyword">null</span> : processCpuTracker,</span><br><span class="line">            (isSilentANR) ? <span class="keyword">null</span> : lastPids,</span><br><span class="line">            nativePids);</span><br><span class="line">    String cpuInfo = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 4、输出ANR 日志</span></span><br><span class="line">    Slog.e(TAG, info.toString());</span><br><span class="line">    <span class="keyword">if</span> (tracesFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 5、没有抓到tracesFile，发一个SIGNAL_QUIT信号</span></span><br><span class="line">        Process.sendSignal(app.pid, Process.SIGNAL_QUIT);</span><br><span class="line">    &#125;</span><br><span class="line">    StatsLog.write(StatsLog.ANR_OCCURRED, ...)</span><br><span class="line">    <span class="comment">// 6、输出到drapbox</span></span><br><span class="line">    mService.addErrorToDropBox(<span class="string">&quot;anr&quot;</span>, app, app.processName, activity, parent, annotation, cpuInfo, tracesFile, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        mService.mBatteryStatsService.noteProcessAnr(app.processName, app.uid);</span><br><span class="line">       <span class="comment">//7、后台ANR，直接杀进程</span></span><br><span class="line">        <span class="keyword">if</span> (isSilentANR) &#123;</span><br><span class="line">            app.kill(<span class="string">&quot;bg anr&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、错误报告</span></span><br><span class="line">        makeAppNotRespondingLocked(app,</span><br><span class="line">                activity != <span class="keyword">null</span> ? activity.shortComponentName : <span class="keyword">null</span>,</span><br><span class="line">                annotation != <span class="keyword">null</span> ? <span class="string">&quot;ANR &quot;</span> + annotation : <span class="string">&quot;ANR&quot;</span>,</span><br><span class="line">                info.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9、弹出ANR dialog，会调用handleShowAnrUi方法</span></span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">        msg.obj = <span class="keyword">new</span> AppNotRespondingDialog.Data(app, activity, aboveSystem);</span><br><span class="line"></span><br><span class="line">        mService.mUiHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】input的超时检测机制有点不同，需要等到下一次input事件，才会检测上一次的input事件是否超时，相当于需要主动扫雷</p>
<h5 id="线下解决套路"><a href="#线下解决套路" class="headerlink" title="线下解决套路"></a>线下解决套路</h5><p>导出系统默认 <code>anr</code> 记录信息，<code>adb pull data/anr/traces.txt C:\Users\benbe\Desktop\anr.txt</code></p>
<h5 id="线上ANR监控"><a href="#线上ANR监控" class="headerlink" title="线上ANR监控"></a>线上ANR监控</h5><ul>
<li><p>通过 <code>FileOberver</code> 监控 <code>traces</code> 文件变化【注：高版本中有权限问题，监控不到该文件变化】</p>
</li>
<li><p>通过 <a href="https://github.com/SalomonBrys/ANR-WatchDog"><code>WatchDog</code></a> 监控 <code>ANR </code></p>
<p>原理：开启一个子线程无限循环，将一个变量值变更后往主线程发送一个还原消息，睡眠一定的间隔后检测这个变量值是否被还原，如果没有被还原说明发送了<code>ANR</code></p>
<p>问题：会有漏检的情况，主线程卡顿1秒后才开启新一轮的监控，如果主线程到达卡顿阈值就不卡了，此时这个变量值已被还原，<code>WatchDog</code> 就以非卡顿的场景进行处理了，需要针对这个问题进行优化，优化：假设原本卡顿阈值为5秒，那么我们可以将检测间隔设定为1秒，当累计卡顿5秒才触发监控ANR的流程，这样就能让误差降低到1s内</p>
</li>
</ul>
<h5 id="BlockCanary-和-WatchDog-的区别"><a href="#BlockCanary-和-WatchDog-的区别" class="headerlink" title="BlockCanary  和 WatchDog  的区别"></a><code>BlockCanary </code> 和 <code>WatchDog</code>  的区别</h5><ul>
<li><code>BlockCanary</code>：监控的是每条 <code>Msg</code> 的执行耗时</li>
<li><code>WatchDog</code>： 开启子线程看最终结果，如果值没被还原则认为有问题</li>
<li>前者适合监控卡顿，后者适合补充 <code>ANR</code> 监控</li>
</ul>
<h5 id="死锁监控"><a href="#死锁监控" class="headerlink" title="死锁监控"></a>死锁监控</h5><blockquote>
<p>死锁引起的 ANR ，如何找出死锁原因？</p>
</blockquote>
<p>参考：<a href="/2021/01/06/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E9%94%81%E8%B0%83%E7%94%A8%E9%93%BE/">获取锁调用链</a></p>
<h4 id="单点卡顿问题检测"><a href="#单点卡顿问题检测" class="headerlink" title="单点卡顿问题检测"></a>单点卡顿问题检测</h4><blockquote>
<p>上诉提到了卡顿和ANR的解决方案，但是还是不够，例如，此时有很多消息在执行，但是又没有达到卡顿和ANR的阈值，但是你自己的消息就是执行不到，造成交互不流畅。</p>
<p>卡顿点：主线程IPC、DB</p>
</blockquote>
<p>下面以 IPC 检测为例，其它的如DB、IO、Looper 消息过多和 View 绘制等也是类似处理</p>
<h5 id="检测指标"><a href="#检测指标" class="headerlink" title="检测指标"></a>检测指标</h5><ul>
<li>IPC 调用类型</li>
<li>调用耗时、次数</li>
<li>调用堆栈、发生线程</li>
</ul>
<h5 id="检测方案"><a href="#检测方案" class="headerlink" title="检测方案"></a>检测方案</h5><ul>
<li><p>IPC 操作前后加埋点</p>
</li>
<li><p><code>adb</code> 命令检测</p>
<ol>
<li>开启监控：<code>adb shell am trace-ipc start</code></li>
<li>停止监控并保存到指定文件：<code>adb shell am trace-ipc stop --dump-file /data/local/tmp/ipc-trace.txt</code></li>
<li>导出监控文件：<code>adb pull /data/local/tmp/tmp/ipc-trace.txt  C:\Users\benbe\Desktop\ipc-trace.txt</code></li>
</ol>
</li>
<li><p>通过 <a href="/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/ART-Hook/"><code>ART-Hook</code></a> 方式 hook 常用 IPC 方法</p>
<ol>
<li>通过 <code>PackageManager</code> 获取进程名</li>
<li>获取 <code>DeviceID</code> 信息</li>
<li><code>AMS</code> 相关</li>
<li><code>View.getWindowVisibleDisplayFrame()</code></li>
</ol>
<p>上诉无论那种操作，最终都会调用到 <code>BinderProxy</code> 类里的 <code>transact</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    DexposedBridge.findAndHookMethod(Class.forName(<span class="string">&quot;android.os.BinderProxy&quot;</span>), <span class="string">&quot;transact&quot;</span>,</span><br><span class="line">            <span class="keyword">int</span>.class, Parcel.class, Parcel.class, <span class="keyword">int</span>.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    LogUtils.i( <span class="string">&quot;BinderProxy beforeHookedMethod &quot;</span> + param.thisObject.getClass().getSimpleName()</span><br><span class="line">                            + <span class="string">&quot;\n&quot;</span> + Log.getStackTraceString(<span class="keyword">new</span> Throwable()));</span><br><span class="line">                    <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="界面秒开实现"><a href="#界面秒开实现" class="headerlink" title="界面秒开实现"></a>界面秒开实现</h4><p>更多参考启动优化和布局优化</p>
<ul>
<li>通过 <code>SysTrace</code> 获取布局初始化的执行情况</li>
<li>异步 <code>Inflate</code>、X2C 、绘制优化</li>
<li>提前获取页面数据</li>
<li>监控界面打开耗时：通过在 <code>onCreate</code> 里手动埋点，在UI可交互式统计界面耗时，也可使用 <code>AOP</code> 的方式 Hook 对于相应方法进行实现</li>
</ul>
<h4 id="监控耗时盲区"><a href="#监控耗时盲区" class="headerlink" title="监控耗时盲区"></a>监控耗时盲区</h4><ol>
<li><p><strong>耗时盲区监控难点</strong></p>
<ul>
<li>只知道在主线程做了耗时操作，但并不知道具体在做什么</li>
<li>线上盲区无从追查</li>
</ul>
</li>
<li><p><strong>线下耗时盲区监控</strong></p>
<ul>
<li><code>TraceView</code> or <code>Systrace</code><ul>
<li>特别适合一段时间内的盲区监控</li>
<li>线程具体做了什么，一目了然</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线上监控</strong></p>
<ul>
<li><p><strong>参考方案：</strong>监听消息 <code>mLogging</code> 方案</p>
<p><strong>【缺点】</strong>有所有方法的 <code>Msg</code>，但是没有 <code>Msg</code> 具体堆栈，并不知道 <code>Msg</code> 是被谁抛出来的</p>
</li>
<li><p><strong>参考方案：</strong>通过 <code>AOP</code> 切 <code>Handler</code> 方法</p>
<p><strong>【缺点】</strong>可以知道发送 <code>Msg</code> 的堆栈，但是这种方案不清楚 <code>Msg</code> 的具体执行时间</p>
</li>
<li><p><strong>推荐方案：</strong>使用统一的 <code>Handler</code>,定制 <code>sendMessageAtTime</code> 和 <code>dispatchMessage</code> 方法，同时可以定制 <code>gradle</code> 插件，编译时动态替换所有 <code>Handler</code>的父类，这样就能让所有 <code>Handler</code>  发送和执行的调用栈执行时间都能捕捉到，<a href="/2021/01/06/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E7%9B%91%E6%8E%A7%E6%89%80%E6%9C%89%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81%E6%A0%88%E5%92%8C%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4/">参考：监控所有消息的发送栈和执行时间</a></p>
</li>
</ul>
</li>
</ol>
<h4 id="卡顿优化总结"><a href="#卡顿优化总结" class="headerlink" title="卡顿优化总结"></a>卡顿优化总结</h4><ul>
<li>耗时操作：异步、延迟</li>
<li>布局优化：异步 <code>Inflate</code>、<code>X2C</code>、重绘解决</li>
<li>内存：降低内存占用，减少 <code>GC</code> 时间</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>java技巧-获取当前系统的换行符</title>
    <url>/2020/09/14/Java/%E5%B0%8F%E6%8A%80%E5%B7%A7/java%E6%8A%80%E5%B7%A7-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="java技巧-获取当前系统的换行符"><a href="#java技巧-获取当前系统的换行符" class="headerlink" title="java技巧-获取当前系统的换行符"></a>java技巧-获取当前系统的换行符</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 换行符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String NEW_LINE = System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>java技巧-获取支持的算法和算法支持的模式</title>
    <url>/2020/09/14/Java/%E5%B0%8F%E6%8A%80%E5%B7%A7/java%E6%8A%80%E5%B7%A7-%E8%8E%B7%E5%8F%96%E6%94%AF%E6%8C%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E6%94%AF%E6%8C%81%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="java技巧-获取支持的算法和算法支持的模式"><a href="#java技巧-获取支持的算法和算法支持的模式" class="headerlink" title="java技巧-获取支持的算法和算法支持的模式"></a>java技巧-获取支持的算法和算法支持的模式</h1><ol>
<li><p>获得所有支持的算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Provider provider : Security.getProviders())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Provider: &quot;</span> + provider.getName());</span><br><span class="line">    <span class="keyword">for</span> (Provider.Service service : provider.getServices())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  Algorithm: &quot;</span> + service.getAlgorithm());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获得算法支持的模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Provider provider : Security.getProviders()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Provider: &quot;</span> + provider.getName());</span><br><span class="line">    <span class="keyword">for</span> (Provider.Service service : provider.getServices()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  Algorithm  Pattern: &quot;</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2020/11/12/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><img src="/2020/11/12/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B/extend.png"></p>
<blockquote>
<p>继承关系如上，其中Container为泛型容器</p>
</blockquote>
<h3 id="泛型参数命名约定"><a href="#泛型参数命名约定" class="headerlink" title="泛型参数命名约定"></a>泛型参数命名约定</h3><p>类型参数一般使用一个大写的字母表示，经常使用的类型参数的名称有</p>
<ul>
<li>E: Element（广泛的用于Java Collection中）</li>
<li>K: Key</li>
<li>V: Value</li>
<li>N: Number</li>
<li>T: Type</li>
<li>S,U,V: 第2, 3, 4个类型参数</li>
</ul>
<h3 id="泛型擦除的具体事实"><a href="#泛型擦除的具体事实" class="headerlink" title="泛型擦除的具体事实"></a>泛型擦除的具体事实</h3><ul>
<li>虚拟机没有泛型，只有普通的类和方法</li>
<li>所有类型参数都用他们的限定类型替换</li>
<li>桥方法被合成来保持多态</li>
<li>为保证类型安全性，必要时插入强制类型转换</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>由于泛型擦除的原因，相较于真泛型的语言（C#、C++）来说，方法区只需要加载较少字节码，内存负担较少</li>
<li>由于java1.5才开始支持泛型，相对于其它语言对旧版本代码兼容性更好</li>
</ol>
<p>缺点：</p>
<ol>
<li>基本类型无法作为泛型实参，会有装箱拆箱的额外消耗</li>
<li>泛型无法当作真实存在的类型进行处理，如数组<code>new T[]</code>、新建泛型对象<code>new T()</code>、方法重载等【注：C#的List<String>和List<Int>是不同的类型】</Int></String></li>
<li>在实际使用中需要类型强转，有运行时的开销，字节码：CHECKCAST ….</li>
<li>泛型信息是通过字节码注释实现的，混淆时不做keep的话会被清除掉</li>
</ol>
<h3 id="字节码是如何记录泛型信息的"><a href="#字节码是如何记录泛型信息的" class="headerlink" title="字节码是如何记录泛型信息的"></a>字节码是如何记录泛型信息的</h3><p>在编译字节码时会在字节码上打上<code>signature</code>注释和<code>declaration</code>注释</p>
<p><img src="/2020/11/12/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E4%BF%9D%E7%95%99%E4%BF%A1%E6%81%AF.png"></p>
<p>可以通过相关的反射代码进行获取</p>
<p><strong>注意：混淆时会把这些注释给清除，代码上需要用到这些信息时需要在混淆文件中keep住：-keepattributes Signature</strong></p>
<blockquote>
<p>在Retrofit这个库中有使用到</p>
</blockquote>
<h3 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h3><h5 id="构建泛型数组"><a href="#构建泛型数组" class="headerlink" title="构建泛型数组"></a>构建泛型数组</h5><p>直接通过new数组的方式是不允许的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] ts = <span class="keyword">new</span> T[<span class="number">10</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>一种简单实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] minmax(T... t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">String[] minmax = minmax(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// 这是允许的</span></span><br></pre></td></tr></table></figure>

<p>java8起的一种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] minmax(IntFunction&lt;T[]&gt; constr, T... t) &#123;</span><br><span class="line">    T[] ts = constr.apply(t.length);</span><br><span class="line">    System.arraycopy(t, <span class="number">0</span>, ts, <span class="number">0</span>, t.length);</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line">String[] minmax = minmax(String[]::<span class="keyword">new</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// 这是允许的</span></span><br></pre></td></tr></table></figure>

<p>java8之前的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] minmax(T... t) &#123;</span><br><span class="line">    T[] ts = (T[]) Array.newInstance(t.getClass().getComponentType(), t.length);</span><br><span class="line">    System.arraycopy(t, <span class="number">0</span>, ts, <span class="number">0</span>, t.length);</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line">String[] minmax = minmax(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// 这是允许的</span></span><br></pre></td></tr></table></figure>

<p>这也是内置方法<code>Arrays.copyOf()</code>实现的一种方式</p>
<h5 id="消除对受查异常的检查"><a href="#消除对受查异常的检查" class="headerlink" title="消除对受查异常的检查"></a>消除对受查异常的检查</h5><p>如果一个方法抛出受查异常，外部调用这个方法需要try或者继续向外出，如下test方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过泛型中间方法， 这样外部调用test方法时不用检查该异常，即不用try</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中间方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span>(T) e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    throwAs(<span class="keyword">new</span> FileNotFoundException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java和Kotlin中泛型的协变、逆变和不变"><a href="#Java和Kotlin中泛型的协变、逆变和不变" class="headerlink" title="Java和Kotlin中泛型的协变、逆变和不变"></a>Java和Kotlin中泛型的协变、逆变和不变</h3><h5 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h5><ul>
<li>什么是泛型的型变（协变、逆变、不型变）</li>
<li>为什么需要泛型的型变</li>
<li>Java和Kotlin分别是如何处理泛型型变的</li>
</ul>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><blockquote>
<p>型变是指我们是否允许对参数类型进行子类型转换</p>
</blockquote>
<p>假设Apple类是Fruit类的子类，Container<T> 是一个泛型类，那么，Container<Apple> 是 Container<Fruit> 的子类型吗？答案是No。对于Java而言，两者没有关系。对于Kotlin而言，Container<Apple>可能是Container<Fruit>的子类型，或者其超类型，或者两者没有关系，这取决于Container<T>中的 T 在类Container中是如何使用的。简单来说，型变就是指 Container<Apple> 和 Container<Fruit> 是什么关系这个问题，对于不同的答案，有如下几个术语。</Fruit></Apple></T></Fruit></Apple></Fruit></Apple></T></p>
<ul>
<li><strong>invariance（不型变）：</strong>也就是说，Container<Apple> 和 Container<Fruit> 之间没有关系</Fruit></Apple></li>
<li><strong>covariance（协变）：</strong>也就是说，Container<Apple> 是 Container<Fruit> 的子类型</Fruit></Apple></li>
<li><strong>contravariance（逆变）：</strong>也就是说，Container<Fruit> 是 Container<Apple> 的子类型</Apple></Fruit></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>上面在解释协变、逆变概念时的说法只是为了帮助理解，这种说法对于Java而言并不准确。在Java中，Container<Apple> 和 Container<Fruit> 永远没有关系，对于协变应该这么说， Container<Apple> 是 Container&lt;? extends Fruit&gt; 的子类型，逆变则是，Container<Fruit> 是 Container&lt;? super Apple&gt; 的子类型。</Fruit></Apple></Fruit></Apple></li>
<li><strong>子类（subclass）</strong> 和 <strong>子类型（subtype）</strong>不是一个概念，子类一定是子类型，子类型不一定是子类，例如，Container<Apple> 是 Container&lt;? extends Fruit&gt; 的子类型，但是Container<Apple> 并不是 Container&lt;? extends Fruit&gt; 的子类。</Apple></Apple></li>
</ul>
<h5 id="Java的默认做法"><a href="#Java的默认做法" class="headerlink" title="Java的默认做法"></a>Java的默认做法</h5><p>Java中的泛型类在正常使用时是不型变的，要想型变必须在使用处通过通配符进行（称为使用处型变）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Container&lt;Apple&gt; apple = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">Container&lt;Fruit&gt; fruit = apple; <span class="comment">// java默认禁止此类操作</span></span><br></pre></td></tr></table></figure>

<p>禁止这么做主要目的是为了保证运行时的类型安全。</p>
<h5 id="Java的协变做法"><a href="#Java的协变做法" class="headerlink" title="Java的协变做法"></a>Java的协变做法</h5><p>采用<strong>上界</strong>通配符extends，允许Container<Apple>向上转型成为Container<Fruit>的子类型，允许正常使用生产者方法如getT，但消费者方法是不允许的如setT</Fruit></Apple></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Container&lt;Apple&gt; apple = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">Container&lt;? extends Fruit&gt; fruit = apple; <span class="comment">// 这是允许的</span></span><br><span class="line">Fruit t = fruit.getT(); <span class="comment">// 取也是允许的</span></span><br><span class="line">fruit.setT(<span class="keyword">new</span> Apple());<span class="comment">// 存是不允许的</span></span><br></pre></td></tr></table></figure>

<p>之所以允许调用生产者方法，是因为能够明确知道返回的是Fruit类型，但是消费者方法编译器并不知道它的具体类型是什么，有可能是Apple转型得到的，也有可能是Orange转型得到的，为了保证类型安全，编译器拒绝任何消费者方法。<strong>使得像&lt;? extends Fruit&gt;成为单纯的“生产者”</strong></p>
<p>但是这里产生了一个<strong>问题</strong>，类似于ListArray的contains方法，我们能明确知道内部的逻辑不会修改List中的对象，但是编译器还是拒绝了该方法的正常使用，所以只能写成<code>boolean contains(Object o)</code>的形式。<strong>不过没关系，Kotlin能很好的解决。</strong></p>
<h5 id="Java的逆变做法"><a href="#Java的逆变做法" class="headerlink" title="Java的逆变做法"></a>Java的逆变做法</h5><p>采用<strong>下界</strong>通配符super，允许Container<Food>向下转型成为Container<Fruit>的子类型，允许正常使用消费者方法，但是生产者方法只能返回Object类型</Fruit></Food></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Container&lt;Object&gt; obj = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">Container&lt;? <span class="keyword">super</span> Fruit&gt; fruit = obj; <span class="comment">// 这是允许的</span></span><br><span class="line">Container&lt;Plant&gt; plant = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">fruit = plant; <span class="comment">// 这是允许的</span></span><br><span class="line">Container&lt;Food&gt; food = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">fruit = food; <span class="comment">// 这也是允许的</span></span><br><span class="line">fruit.setT(<span class="keyword">new</span> Apple());</span><br><span class="line">fruit.setT(<span class="keyword">new</span> Orange());</span><br><span class="line">fruit.setT(<span class="keyword">new</span> Fruit());</span><br><span class="line">Object t = fruit.getT();</span><br></pre></td></tr></table></figure>

<p>允许向消费者方法传入Fruit及其子类，是因为编译器知道，Fruit及其子类一定属于Fruit或者Fruit的父类，与协变相反的是，由于编译器不知道是Plant类型转型得到的，还是Food转型得到的，甚至是Object转型得到的，所以调用生产者方法只能返回Object类型。<strong>使得像&lt;? super Fruit&gt;成为单纯的“消费者”</strong></p>
<h5 id="Java型变总结"><a href="#Java型变总结" class="headerlink" title="Java型变总结"></a>Java型变总结</h5><blockquote>
<p>extends限定了通配符类型的上界，所以我们可以安全地从其中读取；而super限定了通配符类型的下界，所以我们可以安全地向其中写入。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collections copy方法的泛型使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Kotlin的做法"><a href="#Kotlin的做法" class="headerlink" title="Kotlin的做法"></a>Kotlin的做法</h5><p>Kotlin处理型变的做法概括起来是：Kotlin中的泛型类在定义时即可标明型变类型（协变或逆变，当然也可以不标明，那就是不型变的），在使用处可以直接型变（称为<strong>声明处型变</strong>）。因为Kotlin与Java是100%兼容的，你自己在Kotlin中定义的泛型类当然可以享受声明处型变的方便，但是，如果引入Java库呢？又或者你自己在Kotlin中定义的泛型类恰好是不型变的，然而你又想像Java那样在<strong>使用处型变</strong>，该这么办呢？Kotlin使用一种称为 <strong>类型投影（type projections</strong>） 的方式来处理这种型变。这种方式其实跟Java处理型变的方式类似，只是换了一种说法，还是使用处型变。</p>
<h5 id="Kotlin的协变"><a href="#Kotlin的协变" class="headerlink" title="Kotlin的协变"></a>Kotlin的协变</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(oranges: <span class="type">Source</span>&lt;<span class="type">Orange</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fruits: Source&lt;Fruit&gt; = oranges <span class="comment">// 没问题，因为 T 是一个 out-参数，Source&lt;T&gt;是协变的</span></span><br><span class="line">    <span class="keyword">val</span> oneFruit: Fruit = fruits.nextT() <span class="comment">//可以安全读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用out修饰符，表明类型参数 T 在泛型类中仅作为方法的返回值，不作为方法的参数，因此，这个泛型类是个协变的。回报是，使用时Source<Orange>可以作为Source<Fruit>的子类型。</Fruit></Orange></p>
<p>上面有提到，Java的协变中，向不会修改内容的方法<strong>contains</strong>声明参数为泛型T会无法使用。在Kotlin中能够通过<strong>注解</strong>声明的方式解决</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="type">out E</span>&gt; : <span class="type">Iterable</span>&lt;<span class="type">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用注解 <code>@UnsafeVariance</code> 可以让编译器放我们一马，它是在告诉编译器，我保证这个方法不会向泛型类写入数据，你放心。</p>
<h5 id="Kotlin中的逆变"><a href="#Kotlin中的逆变" class="headerlink" title="Kotlin中的逆变"></a>Kotlin中的逆变</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Comparable</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Comparable</span>&lt;<span class="type">Number</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> y: Comparable&lt;<span class="built_in">Double</span>&gt; = x <span class="comment">// OK！逆变，Comparable&lt;Number&gt;可以作为Comparable&lt;Double&gt;的子类型</span></span><br><span class="line">    y.compareTo(<span class="number">1.0</span>) <span class="comment">//1.0 拥有类型 Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用in修饰符，表明类型参数 T 在泛型类中仅作为方法的参数，不作为方法的返回值，因此，这个泛型类是个逆变的。回报是，使用时Comparable<Number>可以作为Comparable<Double>的子类型。</Double></Number></p>
<p><strong>注意：</strong>以上所说的in/out修饰符对于类型参数 T 的限制，仅适用于非private（public, protected, internal）函数，对于private函数，类型参数 T 可以存在于任意位置，毕竟private函数仅用于内部调用，不会对泛型类的协变、逆变性产生影响。还有一点例外就是，如果类型参数 T 标记为out，我们仍可以在构造函数的参数中使用它，因为构造函数仅用于实例化，之后不能被调用，所以也不会破坏泛型类的协变性。</p>
<h3 id="扩展-堆污染"><a href="#扩展-堆污染" class="headerlink" title="扩展-堆污染"></a>扩展-堆污染</h3><blockquote>
<p>Heap pollution(堆污染), 指的是当把一个不带泛型的对象赋值给一个带泛型的变量时, 就有可能发生堆污染。</p>
<p>由于定义带泛型变量时并不强制指定泛型类型, 因此如果借此发生狸猫换太子的操作的话, 那么就会导致堆污染. 堆污染在编译时并不会报错, 只会在编译时提示有可能导致堆污染的警告. 在运行时,如果发生了堆污染, 那么就会抛出类型转换异常。</p>
</blockquote>
<h5 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义时未指定泛型类型</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将无泛型对象复制给指定类型变量，此处已经发生堆污染</span></span><br><span class="line">List&lt;String&gt; strList = list;</span><br><span class="line">String s = strList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h5 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h5><blockquote>
<p>java语言不允许创建泛型数组，所以当可变参数为带泛型的可变数组时，方法内只能用不带泛型的数组接收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class="line">    Object[] array = stringLists;</span><br><span class="line">    List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 此处发生堆污染</span></span><br><span class="line">    array[<span class="number">0</span>] = tmpList;</span><br><span class="line">    String s = stringLists[<span class="number">0</span>].get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="忽略堆污染警告"><a href="#忽略堆污染警告" class="headerlink" title="忽略堆污染警告"></a>忽略堆污染警告</h5><p>在方法上进行注解声明，让编译器不提示警告</p>
<ul>
<li><code>@SuppressWarnings(&quot;unchecked&quot;)</code>：取消所有警告</li>
<li><code>@SafeVarargs</code>：Java7 专门用来抑制堆污染(Heap pollution)警告提供的注解</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2020/11/08/Java/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="java知识点-注解"><a href="#java知识点-注解" class="headerlink" title="java知识点-注解"></a>java知识点-注解</h1><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><pre><code>元注解
public @interface 注解名称&#123;
    属性列表;
&#125;
</code></pre>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote>
<p>注解本质上就是一个接口，该接口默认继承Annotation接口<br>public interface TestAnnotation extends java.lang.annotation.Annotation {}<br>可通过<br>编译：javac 类全路径<br>反编译：javap class文件<br>得到确认</p>
</blockquote>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>要求：
    1.属性返回值类型有一下要求
        * 基本数据类型
        * String
        * 枚举
        * 注解
        * 以上类型的数组
        例：
            import java.util.concurrent.TimeUnit;
            public @interface TestAnnotation &#123;
                int value();
                String value2();
                TimeUnit value3();
                Override value4();
                int[] value5();
                String[] value6();
                TimeUnit[] value7();
                Override[] value8();
            &#125;

    2.定义属性，在使用时需要给属性赋值(属性名 = 返回值)
        例：
            public @interface TestAnnotation&#123;
                int value();
            &#125;
            使用
            @TestAnnotation(value = 1)
            public class TestClass&#123;
            &#125;

        1.如果只有一个属性需要赋值，并且属性名称为value，则value可以省略，直接定义值即可
            @TestAnnotation(1)
            public class TestClass&#123;
            &#125;

        2.如果定义属性时，用default关键字给属性默认初始化值，在使用时可不赋值
        例：
            public @interface TestAnnotation&#123;
                int value() default 0;
            &#125;
            使用
            @TestAnnotation()
            public class TestClass&#123;
            &#125;
        3.数组赋值时，使用&#123;&#125;包裹，如果数组只有一个值，则可以省略
        例：
            public @interface TestAnnotation&#123;
                int[] value();
                String[] value2();
            &#125;
            使用
            @TestAnnotation(value = 1, value2=&#123;&quot;0&quot;, &quot;1&quot;&#125;)
            public class TestClass&#123;
            &#125;
        4.无属性可以直接使用
        例：
            public @interface TestAnnotation&#123;
            &#125;
            使用
            @TestAnnotation()
            public class TestClass&#123;
            &#125;
</code></pre>
<h3 id="元注解，有四种类型"><a href="#元注解，有四种类型" class="headerlink" title="元注解，有四种类型"></a>元注解，有四种类型</h3><pre><code>* @Target：描述注解能够作用的位置
    * ElementType取值：
        * TYPE：可以作用于类、接口、enum上
        * METHOD：可以作用于方法上
        * FIELD：可以作用于成员变量上
        * CONSTRUCTOR：构造器
        * LOCAL_VARIABLE：局部变量声明
        * PACKAGE：包声明
        * PARAMETER：参数声明

* @Repeatable：表示注解在同一位置可以出现多次   

* @Retention：描述注解被保留的阶段
    * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
    * @Retention(RetentionPolicy.CLASS)：当前被描述的注解，会保留到class字节码文件中，JVM无法读取到
    * @Retention(RetentionPolicy.SOURCE)：当前被描述的注解，仅存在源码中

* @Documented：描述注解是否被抽取到api文档中

* @Inherited：描述在父类描述注解子类能否被继承，仅针对类，接口上声明并不会生效
</code></pre>
<h3 id="提取注解"><a href="#提取注解" class="headerlink" title="提取注解"></a>提取注解</h3><pre><code>需要实现java.lang.reflect.AnnotatedElement接口才可提取

已知实现类
Class
Constructor
Field
Method
Package

获取方法
getAnnotation:返回指定类型的注解，不存在返回null
getAnnotations:返回存在的所有注解
isAnnotationPresent:判断是否包含指定类型的注解
getDeclaredAnnotations:返回直接存在于此元素上的所有注解
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2020/11/10/Java/%E7%BA%BF%E7%A8%8B/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><blockquote>
<p>每个线程单独存储自己的数据，具有线程隔离的效果</p>
</blockquote>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>每一个Thread维护一个<code>ThreadLocalMap</code>，通过<code>ThreadLocal</code>这个载体，在使用时变量为空则先创建<code>ThreadLocalMap</code>并赋值给线程再使用；<code>ThreadLocalMap</code>内部维护<code>table</code>数组，所有的数据都存在这里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<span class="comment">// 这里有内存泄漏的风险</span></span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以对应的关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程与ThreadLocal:一对多</span><br><span class="line">线程与ThreadLocalMap：一对一</span><br></pre></td></tr></table></figure>

<p>值得注意的是，每次<code>new ThreadLocal</code>时，都会对散列code自增一个固定值，来使算出的结果更为分布</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();<span class="comment">// 每new一个都会自增一个固定值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解决哈希冲突的方式"><a href="#解决哈希冲突的方式" class="headerlink" title="解决哈希冲突的方式"></a>解决哈希冲突的方式</h5><p>使用<strong>开放地址法</strong>解决哈希冲突</p>
<p><strong>哈希冲突解决方式：</strong></p>
<ol>
<li><strong>开放地址法：</strong>即假设索引15已经存在值且key不同，则会查看索引16为空则设置进去，否则继续下一个索引</li>
<li><strong>链表法：</strong>在冲突的地方以链表的形式存储：<code>HashMap</code></li>
<li><strong>再哈希法：</strong>使用不同的哈希函数再次哈希直到不再冲突为止，缺点是增加了计算哈希的时间</li>
<li><strong>建立公共溢出区：</strong>当发生冲突时，将冲突的数据统一放到溢出区</li>
</ol>
<h5 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h5><p>如果一个<code>ThreadLocal</code>不存在外部<strong>强引用</strong>，则key会被GC回收，这样会导致<code>ThreadLocalMap</code>中的<code>tables</code>数组里key为null，而value为强引用；除非线程退出或者调用<code>get()/set()/remove()</code>等方法触发清除，才会断开对value的强引用。</p>
<p>总结就是因为<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，没有手动删除数据造成的内存泄漏</p>
<p><strong>解决方式：</strong>每次用完<code>ThreadLocal</code>时都调用<code>remove()</code>方法清除数据集</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>线程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程通用</title>
    <url>/2020/11/10/Java/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/</url>
    <content><![CDATA[<h1 id="线程通用"><a href="#线程通用" class="headerlink" title="线程通用"></a>线程通用</h1><h5 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h5><blockquote>
<p>早期版本中线程提供stop方法来终止线程，但该方法已经被弃用</p>
<p>取而代之的是外部通知该线程应该结束了，但是具体什么时候结束交由线程自己控制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束线程</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 外部通知线程中断</span></span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>

<p>注意一：如果在<code>Thread.sleep()</code>等会抛出<code>InterruptedException</code>受查异常等内置函数后面调用<code>Thread.currentThread().isInterrupted()</code>返回false</p>
<p>注意二：<code>Thread.interrupted()</code>线程静态函数会将中断状态清空，与<code>Thread.currentThread().isInterrupted(true)</code>效果一致</p>
<h5 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock mLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 可重入锁对象</span></span><br><span class="line">Condition mCondition = mLock.newCondition(); <span class="comment">// 锁对象创建条件对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLokc.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">//未达到条件) &#123;</span></span><br><span class="line">            mCondition.await(); <span class="comment">// 临时释放锁并进入阻塞状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do somethind</span></span><br><span class="line">        mCondition.signalAll(); <span class="comment">//通知释放阻塞状态的地方允许重新获得锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一：ReentrantLock 可多次调用lock()函数，但必须与unlock()函数成对出现</p>
<p>注意二：条件对象await必须是已经获得锁后调用，不然会爆出IllegalMonitorStateException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">//未达到条件) &#123;</span></span><br><span class="line">            wait(); <span class="comment">// 临时释放锁并进入阻塞状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do somethind</span></span><br><span class="line">        notifyAll(); <span class="comment">// 通知释放阻塞状态的地方允许重新获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方式与锁对象方式一模一样</p>
<p>值得注意的是，条件对象调用的是**await()<strong>方法，同步方法调用的是</strong>wait()**方法，别用错了</p>
<h5 id="volatile域"><a href="#volatile域" class="headerlink" title="volatile域"></a>volatile域</h5><p>作用：内存可见性、禁止指令重排序</p>
<p>JVM要求实现volatile必须要实现内存屏障，最终调用汇编指令为：<code>lock addl</code>，由于<code>lock</code>指令后面必须跟一条指令，但是Intel限制了<code>lock</code>指令不能跟<code>nop(空指令)</code>，所以后面添加了一个<code>addl(加0指令)</code></p>
<blockquote>
<p>LOCK 用于多处理器中执行指令时对共享内存的独占使用</p>
<p>他的作用时能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器缓存失效</p>
<p><strong>另外还提供了有序的指令无法越过内存屏障的作用，即lock指令前面的指令都无法越过这条指令</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (os::<span class="built_in">is_mp</span>()) &#123;<span class="comment">// 是否是多核cpu，可见volatile在单核cpu里并没有使用lock指令</span></span><br><span class="line">	<span class="comment">// 使用lock指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存屏障（JVM层面）</strong></p>
<p>写：<code>StoreStore</code> - <code>volatile写</code> - <code>StoreLoad</code></p>
<p>读：<code>volatile读</code> - <code>LoadStore</code> - <code>LoadLoad</code></p>
<h5 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h5><p>除了使用锁或<code>volatitle</code>修饰符，还有一种情况可以安全地访问一个共享域，即将该域声明为final：</p>
<p><code>final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</code></p>
<p>其它线程会在构造函数完成构造后才看到这个map变量</p>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>Unsafe内部最终调用汇编语句：多核：<code>lock cmpxchg</code> 单核：<code>cmpxchg</code></p>
<p><code>cmpxchg</code>：比较并交换操作数</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><blockquote>
<p><code>java.util.concurrent.atomic</code>包中有很多类使用高效的机器级指令来保证操作的原子性。</p>
<p>如：<code>AtomicInteger</code>的<code>getAndIncrement</code>和<code>incrementAndGet</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger integer = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">integer.set(Math.max(integer.get(), number));<span class="comment">//该操作不具有原子性，无法保证值的正常更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    oldValue = integer.get();</span><br><span class="line">    newValue = Math.max(oldValue, number)</span><br><span class="line">&#125; <span class="keyword">while</span>(!integer.compareAndSet(oldValue, newValue)); <span class="comment">// 需要通过比对再设值的方式保证原子性，CAS</span></span><br><span class="line"><span class="comment">// java8 可以通过内置函数免写以上循环操作，如updateAndGet、accumulateAndGet等函数</span></span><br></pre></td></tr></table></figure>

<p>注意一：如果大量线程要访问相同的类名开头为Atomic的原子值，性能会大幅下降，因为采用CAS乐观更新需要太多的循环重试操作。可通过类<code>LongAddr</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>和<code>DoubleAccumulator</code>来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原理：采用多个变量（加数），其总和为当前值。可以有多个线程同时更新不同的加数，线程增加会自动提供新的加数。</span></span><br><span class="line"><span class="comment">// 只有当所有工作都完成之后才需要总和的值，这个情况下该类操作会相当高效</span></span><br><span class="line">LongAdder adder</span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    adder.increment();<span class="comment">// 不会返回值，这样做回消除求和分解到多个加数所带来的性能提升</span></span><br><span class="line">	<span class="comment">// long total = adder.sum();// 不推荐这么操作，会失去性能的提升，如必须该操作，则使用Atomic会更好</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> total = adder.sum();</span><br></pre></td></tr></table></figure>

<p>注意二：上述提到CAS操作更新会存在ABA的异常，可通过<code>AtomicStampedReference</code>带版本号的原子类进行修复</p>
<p>让自己的类具有原子性：<code>AtomicReference</code>和<code>AtomicReferenceFieldUpdater</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicReference</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用AtomicReference对字符串进行封装</span></span><br><span class="line">    AtomicReference&lt;String&gt; atomicValue = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;HelloAtomic&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAtomicClass holder = <span class="keyword">new</span> MyAtomicClass();</span><br><span class="line">    holder.atomicValue.compareAndSet(<span class="string">&quot;HelloAtomic&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">	System.out.println(holder.atomicValue.get());</span><br><span class="line">	String value = holder.atomicValue.updateAndGet(<span class="keyword">new</span> UnaryOperator&lt;String&gt;() &#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;);</span><br><span class="line">  	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicReferenceFieldUpdater</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为value字段添加原子操作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;SimpleValueHolder, String&gt; valueUpdater</span><br><span class="line">        =  AtomicReferenceFieldUpdater.newUpdater(SimpleValueHolder.class, String.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用volatile声明</span></span><br><span class="line">	<span class="keyword">volatile</span> String value = <span class="string">&quot;HelloAtomic&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAtomicClass holder = <span class="keyword">new</span> MyAtomicClass();</span><br><span class="line">    holder.valueUpdater.compareAndSet(holder, <span class="string">&quot;HelloAtomic&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    System.out.println(holder.valueUpdater.get(holder));</span><br><span class="line">    String value = holder.valueUpdater.updateAndGet(holder, <span class="keyword">new</span> UnaryOperator&lt;String&gt;() &#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;);</span><br><span class="line">  	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AtomicReference</strong>与<strong>AtomicReferenceFieldUpdater</strong>的区别：</p>
<blockquote>
<p>两者的作用差不多，<code>AtomicReference</code>对字段进行包裹，<code>AtomicReferenceFieldUpdater</code>则为静态扩展字段功能</p>
<p><code>AtomicReference</code>和<code>AtomicReferenceFIeldUpdater</code>比起来，要多创建一个对象<br>对于 32 位的机器，这个对象的头占 12 个字节，它的成员占 4 个字节，也就是多出来 16 个字节<br>对于 64 位的机器，如果启动了指针压缩，那这个对象占用的也是 16 个字节<br>对于 64 位的机器，如果没启动指针压缩，那么这个对象就会占 24 个字节，其中对象头占 16 个字节，成员占 8 个字节</p>
<p>当要使用<code>AtomicReference</code>创建成千上万个对象时，这个开销就会变得很大</p>
<p>因为开销的原因，一般在实例较少的情况下如单例才会选择<code>AtomicReference</code>，不然推荐使用<code>AtomicReferenceFieldUpdater</code></p>
</blockquote>
<h5 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h5><p>线程间共享变量存在不同步异常问题，有些情况并不推荐使用共享变量，如：<code>SimpleDateFormat</code>类不是线程安全的。</p>
<p>假设有静态变量：</p>
<p><code>public static final SimpleDateFormat dateFormat = new SimpleDateForniat(&quot;yyyy-MM-dd&quot;)；</code></p>
<p>如果有两个线程同时执行以下操作</p>
<p><code>String dateStamp = dateFormat.format(new DateO);</code></p>
<p>结果可能会混乱，因为<code>dateFormat</code>内部数据可能会被并发的访问所破会。当然可以在该函数使用同步锁，但开销会很大，或者再使用时构造一个局部<code>SimpleDateForniat</code>对象，不过会有点浪费。</p>
<p>推荐为每个线程构造实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; initial = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>));<span class="comment">// 在使用时才会初始化SimpleDateFormat</span></span><br><span class="line">SimpleDateFormat simpleDateFormat = initial.get();</span><br></pre></td></tr></table></figure>

<p>在多个线程中生成随机数也存在类似的问题。Random类是线程安全的，但是如果多个线程需要等待一个共享的随机数生成器会很低效。</p>
<p>可以通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalRandom.current().nextInt()</span><br></pre></td></tr></table></figure>

<p>来解决此问题</p>
<h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><p>如果得不到锁可以执行其它逻辑，可以通过<strong>tryLock</strong>的方式获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mlock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可为<strong>tryLock</strong>添加超时逻辑,<code>mlock.tryLock(100,TimeUnit.MILLISECONDS)</code></p>
<p><code>lockInterruptibly</code>相当于无限时长的<code>tryLock</code></p>
<p>同样锁条件也可在等待时添加超时，<code>condition.await(100,TimeUnit.MILLISECONDS)</code></p>
<p><code>awaitUninterruptibly</code>相当于无限时长的<code>await</code>，但是不会抛出异常</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>在频繁读取少变更的情况下，可以使用读写锁来提高性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> data)</span> </span>&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><ol>
<li><p>通过<code>Executors</code>生成线程池</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程，空闲线程会被保留60 秒</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>该池包含固定数量的线程，空闲线程会一直被保留</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>只有一个线程的“ 池”， 该线程顺序执行每一个提交的任务</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>用于预定执行而构建的固定线程池</td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td>用于预定执行而构建的单线程“ 池”</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li><p>相关<code>Scheduled</code>线程池的用法:<br> <code>schedule</code>：预定在指定的时间之后执行任务<br> <code>scheduleAtFixedRate</code>：预定在初始的延迟结束后， 周期性地运行给定的任务， 周期长度是period<br> <code>scheduleWithFixedDelay</code>：预定在初始的延迟结束后周期性地运行给定的任务， 在一次调用完成和下一次调用开<br> 始之间有长度为delay 的延迟</p>
</li>
<li><p>控制任务组</p>
<p>  并行处理任务</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ....;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; futures = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span>(Future&lt;T&gt; result:results) &#123;</span><br><span class="line">	result.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以上方法有个缺点，必要要所有任务执行完毕了，<code>get</code>才会开始真正执行</p>
<p>  可通过<code>ExecutorCompletionService</code>类解决,使先完成的先返回</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorCompletionService&lt;T&gt; service = <span class="keyword">new</span> ExecutorCompletionService(executor);</span><br><span class="line"><span class="keyword">for</span> (Callable&lt;T&gt; task : tasks)</span><br><span class="line">    service,submit(task);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.sizeO；i ++)</span><br><span class="line">	processFurther(service.take().get())；</span><br></pre></td></tr></table></figure></li>
<li><p>Fork-Join框架</p>
<p>  在未满足最小计算单位时拆分成更多小的任务进行并行操作，以提高效率</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Task&lt;T&gt; extends RecursiveTask&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> to;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (from + to)/<span class="number">2</span>;</span><br><span class="line">            Task first = <span class="keyword">new</span> Task(from, mid);</span><br><span class="line">            Task second = <span class="keyword">new</span> Task(mid,to);</span><br><span class="line">            invokeAll(first, second);</span><br><span class="line">            <span class="keyword">return</span> first.join() + second.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task task = <span class="keyword">new</span> Task(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">pool.invoke(task)</span><br><span class="line">task.join();</span><br></pre></td></tr></table></figure></li>
<li><p>可完成Future【CompletableFuture】</p>
<p>  由于单纯使用Future会造成线程阻塞，java8引用了<code>CompletableFuture</code>来对<code>Future</code>进行改进，实现异步调用的逻辑</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">    CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">    <span class="comment">// 如果执行成功:</span></span><br><span class="line">    cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 如果执行异常:</span></span><br><span class="line">    cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error: &quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步器</p>
<table>
<thead>
<tr>
<th>类</th>
<th>能做什么</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CyclicBarrier</td>
<td>允许线程集等待直至其中预定数目的线程到达一个公共障栅（ barrier)，然后可以选择执行一个处理障栅的动作</td>
<td>当大量的线程需要在它们的结果可用之前完成时</td>
</tr>
<tr>
<td>Phaser</td>
<td>类似于循环障栅， 不过有一个可变的计数</td>
<td>Java SE 7 中引人</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>允许线程集等待直到计数器减为0</td>
<td>当一个或多个线程需要等待直到指定数目的事件发生</td>
</tr>
<tr>
<td>Exchanger</td>
<td>允许两个线程在要交换的对象准备好时交换对象</td>
<td>当两个线程工作在同一数据结构的两个实例上的时候， 一个向实例添加数据而另一个从实例清除数据</td>
</tr>
<tr>
<td>Samaphore</td>
<td>允许线程集等待直到被允许继续运行为止</td>
<td>限制访问资源的线程总数。如果许可数是1，常常阻塞线程直到另一个线程给出许可为止</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>允许一个线程把对象交给另一个线程</td>
<td>在没有显式同步的情况下， 当两个线程准备好将一个对象从一个线程传递到另一个时</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>BitSet</title>
    <url>/2020/09/14/Java/%E9%9B%86%E5%90%88/BitSet-md/</url>
    <content><![CDATA[<h1 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h1><blockquote>
<p>Java平台上存放位序列的集合。<br>如果需要高效的存储位序列（例如：标志）就可以使用位集。<br>由于位集将位包装在字节里，所以使用位集比使用Boolean对象的ArrayList更加高效。</p>
</blockquote>
<h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>	 		<span class="comment">// 返回最高位为1的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bit)</span>	<span class="comment">// 获得一个位，返回true则为开</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bit)</span>		<span class="comment">// 设置一个位为开</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> bit)</span>		<span class="comment">// 设置一个位为关</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>			<span class="comment">// 将所有设置为关</span></span></span><br></pre></td></tr></table></figure>

<h5 id="计算素数个数"><a href="#计算素数个数" class="headerlink" title="计算素数个数"></a>计算素数个数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算2~2000000之间的所有素数</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">200_0000</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">BitSet bit = <span class="keyword">new</span> BitSet(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    bit.set(i);</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">while</span> (i * i &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bit.get(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        k = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= n) &#123;</span><br><span class="line">            bit.clear(k);</span><br><span class="line">            k += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bit.get(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;count: &quot;</span> + count); <span class="comment">// count: 148933</span></span><br><span class="line">System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><blockquote>
<p> 参考：<a href="https://blog.csdn.net/wildwolf_001/article/details/107186226">https://blog.csdn.net/wildwolf_001/article/details/107186226</a></p>
</blockquote>
<h5 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h5><ol>
<li><p>数据结构？</p>
<p>答：数组加链表法</p>
</li>
<li><p>怎么插入数据？</p>
<p>答：链表头插法，即：链表中最新的数据插在链表头</p>
</li>
<li><p>哈希冲突怎么预防？</p>
<p>答：二次哈希 or 扰动函数</p>
</li>
<li><p>怎么解决哈希冲突？</p>
<p>答：链表法，其它方案：再哈希、开放寻址、公共溢出区</p>
</li>
<li><p>默认容量多少？</p>
<p>答：16</p>
</li>
<li><p>扩容后存储位置的计算方式？</p>
<p>答：重新计算哈希和索引</p>
</li>
<li><p>内部数组是什么时候创建的？</p>
<p>答：第一次put的时候创建</p>
</li>
</ol>
<h5 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h5><ol>
<li><p>1.7 和 1.8 数据结构有什么不同？</p>
<p>答：引入红黑树</p>
</li>
<li><p>1.7 和 1.8 往链表上插数据的方式有什么不同？<br>答：从头插法改为尾部插入</p>
</li>
<li><p>扩容后存储位置的计算方式？</p>
<p>答：对老数组进行与运算，判断值是否等于0，等于0在低位，否则在高位</p>
</li>
<li><p>HashMap 什么时候会把链表转化为红黑树？</p>
<p>答：在链表大于等于8时会转换为红黑树，如果数组大小小于64会优先扩容</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全的集合</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h1><h5 id="常用集合描述"><a href="#常用集合描述" class="headerlink" title="常用集合描述"></a>常用集合描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ConcurrentHashMap</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentSkipListMap</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentSkipListSet</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentLinkedQueue</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CopyOnWriteArrayList</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CopyOnWriteArraySet</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>通用集合</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/%E9%80%9A%E7%94%A8%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="通用集合"><a href="#通用集合" class="headerlink" title="通用集合"></a>通用集合</h1><h5 id="常用集合描述"><a href="#常用集合描述" class="headerlink" title="常用集合描述"></a>常用集合描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ArrayList</td>
<td align="left">一种可以动态增长和缩减的索引序列</td>
</tr>
<tr>
<td align="left">LinkedList</td>
<td align="left">一种可以在任何位置进行高效地插人和删除操作的有序序列</td>
</tr>
<tr>
<td align="left">ArrayDeque</td>
<td align="left">一种用循环数组实现的双端队列</td>
</tr>
<tr>
<td align="left">HashSet</td>
<td align="left">一种没有重复元素的无序集合</td>
</tr>
<tr>
<td align="left">TreeSet</td>
<td align="left">一种有序集</td>
</tr>
<tr>
<td align="left">EnumSet</td>
<td align="left">一种包含枚举类型值的集</td>
</tr>
<tr>
<td align="left">LinkedHashSet</td>
<td align="left">一种可以记住元素插人次序的集</td>
</tr>
<tr>
<td align="left">PriorityQueue</td>
<td align="left">一种允许高效删除最小元素的集合</td>
</tr>
<tr>
<td align="left">HashMap</td>
<td align="left">一种存储键值关联的数据结构</td>
</tr>
<tr>
<td align="left">TreeMap</td>
<td align="left">一种键值有序排列的映射表</td>
</tr>
<tr>
<td align="left">EnumMap</td>
<td align="left">一种键值属于枚举类型的映射表</td>
</tr>
<tr>
<td align="left">LinkedHashMap</td>
<td align="left">一种存储键/ 值关联的数据结构—种键值有序排列的映射表</td>
</tr>
<tr>
<td align="left">WeakHashMap</td>
<td align="left">一种其值无用武之地后可以被垃圾回收器回收的映射表</td>
</tr>
<tr>
<td align="left">IdentityHashMap</td>
<td align="left">一种用==而不是用equals 比较键值的映射表</td>
</tr>
</tbody></table>
<h5 id="旧集合"><a href="#旧集合" class="headerlink" title="旧集合"></a>旧集合</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Vector</td>
<td align="left">与ArrayList相似，但所有方法都是同步的</td>
</tr>
<tr>
<td align="left">HashTable</td>
<td align="left">与HashMap相似，但所有方法都是同步的</td>
</tr>
<tr>
<td align="left">Properties</td>
<td align="left">属性映射</td>
</tr>
</tbody></table>
<h5 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collections.empty…</td>
<td align="left">生成一个不可添加数据的空集合实例</td>
</tr>
<tr>
<td align="left">Collections.singleton…</td>
<td align="left">生成一个不可修改的含单一数据的集合实例</td>
</tr>
<tr>
<td align="left">Collections.unmodifiable…</td>
<td align="left">生成一个包装集合的不可添加数据的包装集合实例</td>
</tr>
<tr>
<td align="left">Collections.synchronized…</td>
<td align="left">生成一个包装集合的同步操作包装集合实例</td>
</tr>
<tr>
<td align="left">Collections.checked…</td>
<td align="left">生成一个包装集合的受查操作的集合实例</td>
</tr>
</tbody></table>
<h5 id="LinkedHashMap实现LRU算法（最近最少使用算法）"><a href="#LinkedHashMap实现LRU算法（最近最少使用算法）" class="headerlink" title="LinkedHashMap实现LRU算法（最近最少使用算法）"></a>LinkedHashMap实现LRU算法（最近最少使用算法）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> capacity = <span class="number">4</span>;</span><br><span class="line">LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(capacity, <span class="number">0.75f</span>,<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;String, String&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; <span class="comment">// 当返回true则删除最少使用的的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="小知识："><a href="#小知识：" class="headerlink" title="小知识："></a>小知识：</h5><ol>
<li>“for each”循环可以与任何实现了<strong>Iterable接口</strong>的对象一起工作</li>
<li>集合<strong>迭代器Iterator</strong>的remove与next/previous具有依赖性，调用remove之前没有调用next是不合法的，必须先调用next越过将要删除的元素</li>
<li>Java 1.4针对集合引入了一个<strong>标记接口RandomAccess</strong>，用于标记该集合是否支持高效的随机访问，如：ArrayList(实现)和LinkedList(未实现)</li>
<li>Collection集合类内部维护了一个计数器modCount，负责跟踪列表的<strong>结构性修改</strong>，如添加元素、删除元素等。在新建迭代器的同时会缓存此时的计数器，在改写操作时判断缓存的计数器值与集合类的计数器值是否一致，不一致则抛出<strong>ConcurrentModificastionException</strong>异常。注意：集合的set方法不被<strong>视为结构性修改</strong>，这会造成多个迭代器遍历出的结果不一定一致</li>
<li>以<strong>链表</strong>为模型的集合，多次使用get获取某个位置的元素效率极低，可以使用<strong>列表迭代器ListIterator</strong>的nextIndex、next、previousIndex、previous等方法优化该操作，<strong>备注：</strong>ListIterator的add和set方法也是插入操作的一个优化点</li>
<li>原本**for(Map.Entry&lt;&gt; entry : map.entrySet())**的map遍历操作最高效，在Java 1.8后直接通过map.forEach方法直接操作node更加高效</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列</title>
    <url>/2020/11/08/Java/%E9%9B%86%E5%90%88/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h5 id="队列描述描述"><a href="#队列描述描述" class="headerlink" title="队列描述描述"></a>队列描述描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LinkedBlockingQueue</td>
<td align="left">一种容量没有上边界的阻塞队列，亦可指定最大容量</td>
</tr>
<tr>
<td align="left">LinkedBlockingDeque</td>
<td align="left">一种双端队列版本</td>
</tr>
<tr>
<td align="left">ArrayBlockingQueue</td>
<td align="left">一种在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性</td>
</tr>
<tr>
<td align="left">PriorityBlockingQueue</td>
<td align="left">一种带优先级的队列</td>
</tr>
<tr>
<td align="left">DelayQueue</td>
<td align="left">一种延迟阻塞队列【可实现如下单后三十分钟内没有付款就自动取消订单的操作】</td>
</tr>
<tr>
<td align="left">TransferQueue</td>
<td align="left">一种等待消费者准备就绪才可接收的阻塞队列，如果调用<code>transfer</code>那么会阻塞，直到另一个线程将其取出</td>
</tr>
</tbody></table>
<h5 id="阻塞队列通用方法"><a href="#阻塞队列通用方法" class="headerlink" title="阻塞队列通用方法"></a>阻塞队列通用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>动作</th>
<th>特殊情况</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>添加一个元素</td>
<td>如果队列满， 则抛出IllegalStateException 异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队列头元素</td>
<td>如果队列空，抛出NoSuchElementException 异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回true</td>
<td>如果队列满， 返回false</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列头元素</td>
<td>如果队列空， 则返回null</td>
</tr>
<tr>
<td>poll</td>
<td>移除并返回队列的头元素</td>
<td>如果队列空， 则返回null</td>
</tr>
<tr>
<td>put</td>
<td>添加一个元素</td>
<td>如果队列满， 则阻塞</td>
</tr>
<tr>
<td>remove</td>
<td>移出并返回头元素</td>
<td>如果队列空， 则抛出NoSuchElementException 异常</td>
</tr>
<tr>
<td>take</td>
<td>移出并返回头元素</td>
<td>如果队列空， 则阻塞</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP-Aspectjx</title>
    <url>/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/AOP-Aspectjx/</url>
    <content><![CDATA[<h1 id="AOP-Aspectjx"><a href="#AOP-Aspectjx" class="headerlink" title="AOP-Aspectjx"></a>AOP-Aspectjx</h1><blockquote>
<p>通过预编译和运行期动态代理实现程序功能统一维护的一种技术<br>具有无侵入性和修改方便的特点</p>
<p><a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx">https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx</a></p>
<p>注意：高版本gradle可能无法编译通过</p>
<p>目前编译通过的版本：com.android.tools.build:gradle:3.5.2</p>
<p>注意：有存在兼容性问题的风险，谨慎带到线上环境</p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>类名上声明 <code>@Aspect</code> ，使该类具有切面功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;call(* com.benben.starttest.MainActivity.**(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* android.app.Activity.on**(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After(&quot;call(* android.app.Activity.on**(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;execution(* android.app.Activity.on**(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个*代表匹配任意的方法返回值，后面的语法代码匹配所有Activity中on开头的方法，两个 <code>..</code> 代表任意参数</p>
<ul>
<li>插入类型<ul>
<li>call：出入在函数体里面</li>
<li>execution：插入在函数体外面</li>
</ul>
</li>
<li>执行点<ul>
<li><code>@Before</code>：切入点前面执行</li>
<li><code>@After</code>：切入点后面执行</li>
<li><code>@Around</code>：切入点之前、之后</li>
</ul>
</li>
<li>插入点<ul>
<li>当 <code>Action</code> 为 <code>Before</code>、<code>After</code> 时，方法参数为 <code>JoinPoint</code></li>
<li>当 <code>Action</code> 为 <code>Around</code> 时，方法参数为 <code>ProceedingJoinPoint</code></li>
</ul>
</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>与 <code>ART-Hook</code> 的区别：<code>ART</code> 可以 Hook 系统方法，<code>AspectJ</code> 只能 Hook 非系统方法</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP-Lancet</title>
    <url>/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/AOP-Lancet/</url>
    <content><![CDATA[<h1 id="AOP-Lancet"><a href="#AOP-Lancet" class="headerlink" title="AOP-Lancet"></a>AOP-Lancet</h1><blockquote>
<p>轻量级 Android AOP 框架</p>
<p>具有编译速度快，支持增量编译的特点</p>
<p>API 简单，没有任何多余代码插入 apk，对于包体积优化相当重要</p>
<p>项目地址：<a href="https://github.com/eleme/lancet">https://github.com/eleme/lancet</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">    SELF,	<span class="comment">// 代表仅匹配目标value所指定的一个匹配类</span></span><br><span class="line">    DIRECT, <span class="comment">// 代表匹配value所指定的类的一个直接子类</span></span><br><span class="line">    ALL,	<span class="comment">// 匹配value所指定的类的所有子类</span></span><br><span class="line">    LEAF	<span class="comment">// 匹配 value 指定类的最终子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ART-Hook: Epic</title>
    <url>/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/ART-Hook/</url>
    <content><![CDATA[<h1 id="ART-Hook-Epic"><a href="#ART-Hook-Epic" class="headerlink" title="ART-Hook: Epic"></a>ART-Hook: Epic</h1><blockquote>
<p>将额外代码钩住原有方法，修改执行逻辑</p>
<p>运行时插桩</p>
<p>这里以Epic为例，Epic是一个虚拟机层面、以 Java Method 为粒度的运行时Hook框架</p>
<p>项目地址：<a href="https://github.com/tiann/epic">https://github.com/tiann/epic</a></p>
<p>详细使用方式参考：<a href="https://github.com/tiann/epic/blob/master/README_cn.md">https://github.com/tiann/epic/blob/master/README_cn.md</a></p>
<p>注意：有存在兼容性问题的风险，谨慎带到线上环境</p>
</blockquote>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>与 <code>AspectJ</code> 的区别：<code>ART</code> 可以 Hook 系统方法，<code>AspectJ</code> 只能 Hook 非系统方法</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Leakcanary</title>
    <url>/2020/12/29/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Leakcanary/</url>
    <content><![CDATA[<h1 id="Leakcanary"><a href="#Leakcanary" class="headerlink" title="Leakcanary"></a>Leakcanary</h1><h5 id="如何初始化"><a href="#如何初始化" class="headerlink" title="如何初始化"></a>如何初始化</h5><p>通过ContentProvider自动初始化并注册相应的默认监控类型</p>
<p>默认的监控类型有：</p>
<ol>
<li>Activity：在onDestory时观察</li>
<li>Fragment：在onViewDestory时观察内部View，在onDestory时观察Fragment</li>
<li>RootView：在Detached时观察</li>
<li>Service：在onDestory时观察</li>
</ol>
<h5 id="怎么判断泄漏"><a href="#怎么判断泄漏" class="headerlink" title="怎么判断泄漏"></a>怎么判断泄漏</h5><p>在需要回收的时机里将对象放入到一个弱引用<code>KeyedWeakReference</code>里并传入自己的引用队列<code>ReferenceQueue</code>，然后放到一个观察map中</p>
<p>5秒后通过引用队列移除已经回收的数据，如果对象还存在map中说明没有移除成功</p>
<p>随后开始调用<code>Debug.dumpHprofData()</code>存储内存信息并分析</p>
<p><strong>注意：</strong>新版本不会立马dump内存信息，默认需要达到5个才会dump</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory Analyzer</title>
    <url>/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/</url>
    <content><![CDATA[<h1 id="Memory-Analyzer"><a href="#Memory-Analyzer" class="headerlink" title="Memory Analyzer"></a>Memory Analyzer</h1><blockquote>
<p>俗称MAT，强大的 Java Heap 分析工具，较于 Memory Profiler  更适合查找内存泄漏及内存占用</p>
<p>建议线下深入使用</p>
</blockquote>
<p><a href="https://www.eclipse.org/mat/">工具地址</a></p>
<p><a href="https://help.eclipse.org/2021-03/index.jsp?topic=/org.eclipse.mat.ui.help/tasks/queryingheapobjects.html">官方文档</a></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>获取内存文件：<a href="/2020/12/30/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/dump%20%E5%86%85%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">dump 内存的几种方式</a></p>
<p><code>dump</code> 出来的内存文件 <code>MAT</code> 都无法直接使用，需要通过 <code>hprof-conv</code> 工具对 Dump 文件进行转换</p>
<p>工具目录：<code>&lt;Android_SDK&gt;/platform-tools/</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hprof-conv dump.hprof &lt;输出目录&gt;&#x2F;&lt;文件名&gt;.hprof</span><br></pre></td></tr></table></figure>

<h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><h5 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h5><img src="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/MAT_Histogram.png" style="zoom:80%;">

<ul>
<li>顶部支持过滤</li>
<li>with outgoing references：它强引用了谁</li>
<li>with incoming references：它被谁强引用</li>
</ul>
<img src="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/MAT_Histogram_references.png" style="zoom: 80%;">

<ul>
<li>查看引用链：子选项为需要排除的对象</li>
</ul>
<h5 id="dominator-tree"><a href="#dominator-tree" class="headerlink" title="dominator_tree"></a>dominator_tree</h5><p>与 <code>Histogram</code> 功能类似，但是它会显示出具体对象和对象占用内存的百分比，而 <code>Histogram</code> 只会显示具体数量</p>
<p><img src="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/MAT_dominator_tree.png"></p>
<h5 id="OQL"><a href="#OQL" class="headerlink" title="OQL"></a>OQL</h5><p>对象查询语言，类似于从数据库检索东西。类作为表，object 作为行，field 字段作为列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> com.example.mat.Listener <span class="comment">-- 查询所有Listener</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> toString(l.message), l.message.count <span class="keyword">FROM</span> com.example.mat.Listener l <span class="comment">-- 查询Listener里的message和数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> toString(s), s.count <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> (toString(s) <span class="keyword">NOT</span> <span class="keyword">LIKE</span> &quot;msg*&quot;) <span class="comment">-- 查询不包含msg的字串</span></span><br></pre></td></tr></table></figure>



<p><img src="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/MAT_OQL.png"></p>
<h5 id="thread-overview"><a href="#thread-overview" class="headerlink" title="thread_overview"></a>thread_overview</h5><p>详细展现出线程信息</p>
<p><img src="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/MAT_thread_overview.png"></p>
<h5 id="Top-Consumers"><a href="#Top-Consumers" class="headerlink" title="Top Consumers"></a>Top Consumers</h5><p>通过饼图的形式展示内存占用信息，其中 <code>Biggest Objects</code> 还会展示大对象的占用信息</p>
<p><img src="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/MAT_Top_Consumers.png"></p>
<h5 id="Compare-Basket"><a href="#Compare-Basket" class="headerlink" title="Compare_Basket"></a>Compare_Basket</h5><p>通过这种方式可以将两次dump信息进行比对，这样就可以知道业务前后那些对象增长异常</p>
<p><img src="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/MAT_Compare_Basket.png"></p>
<h5 id="Collection-Fill-Ratio"><a href="#Collection-Fill-Ratio" class="headerlink" title="Collection Fill Ratio"></a>Collection Fill Ratio</h5><p>通过 <code>Collection Fill Ratio</code> 可以查看集合的填充率</p>
<p>如果集合的对象过多且填充率都为0，说明这些集合并没有使用上，可以考虑延迟初始化，在用到的时候再初始化，减少内存占用</p>
<p>【备注一】也可以通过 <code>Array Fill Ratio</code> 来数组分析</p>
<p>【备注二】<code>Map Collision Ratio</code> 哈希碰撞统计，如果哈希碰撞率过多，需要优化相关类的哈希算法</p>
<p><img src="/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Analyzer/MAT_Collection_fill_Ratio.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory Profiler</title>
    <url>/2020/12/28/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Memory%20Profiler/</url>
    <content><![CDATA[<h1 id="Memory-Profiler"><a href="#Memory-Profiler" class="headerlink" title="Memory Profiler"></a>Memory Profiler</h1><blockquote>
<p>实时图表展示应用内存使用量，可以很直观的识别出内存抖动</p>
<p>提供捕获堆存储、强制GC以及跟踪内存分配的能力</p>
</blockquote>
<p><a href="https://developer.android.com/studio/profile/android-profiler">官方地址：Android Profiler</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>StrictMode</title>
    <url>/2021/01/06/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/StrictMode/</url>
    <content><![CDATA[<h1 id="StrictMode"><a href="#StrictMode" class="headerlink" title="StrictMode"></a>StrictMode</h1><blockquote>
<p>严苛模式，Android 提供的一种运行时检测机制</p>
<p>检测两大策略：线程策略，虚拟机策略</p>
<p>官方地址：<a href="https://developer.android.com/reference/android/os/StrictMode">https://developer.android.com/reference/android/os/StrictMode</a></p>
</blockquote>
<p>注意：如需启用严苛模式需尽早启动来使其生效</p>
<h4 id="线程策略"><a href="#线程策略" class="headerlink" title="线程策略"></a>线程策略</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StrictMode.setThreadPolicy(</span><br><span class="line">    ThreadPolicy.Builder()</span><br><span class="line">        .detectCustomSlowCalls()	<span class="comment">// 检测耗时调用</span></span><br><span class="line">        .detectResourceMismatches()	<span class="comment">// 检测定义的资源和getter调用之间的不匹配</span></span><br><span class="line">        .detectUnbufferedIo()	<span class="comment">// 检测无缓冲输入/输出操作</span></span><br><span class="line">        .detectDiskReads()		<span class="comment">// 检测磁盘读取</span></span><br><span class="line">        .detectDiskWrites()		<span class="comment">// 检测磁盘写入</span></span><br><span class="line">        .detectNetwork() 	<span class="comment">// 检测网络操作</span></span><br><span class="line">        .penaltyLog()		<span class="comment">// 当检测相应的内容时通过日志打印出来</span></span><br><span class="line">        .penaltyDeath()		<span class="comment">// 当检测相应的内容时应用崩溃</span></span><br><span class="line">        .penaltyDialog()	<span class="comment">// 当检测相应的内容时弹窗</span></span><br><span class="line">        .build()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="虚拟机策略"><a href="#虚拟机策略" class="headerlink" title="虚拟机策略"></a>虚拟机策略</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StrictMode.setVmPolicy(</span><br><span class="line">    VmPolicy.Builder()</span><br><span class="line">        .setClassInstanceLimit()	<span class="comment">// 指定class允许的实例数量</span></span><br><span class="line">        .detectUntaggedSockets()	<span class="comment">// 检测未加标签的套接字【注：标签用来调查应用内部网络的使用情况】</span></span><br><span class="line">        .detectCleartextNetwork()	<span class="comment">// 检测应用是否有使用明文网络</span></span><br><span class="line">        .detectActivityLeaks()		<span class="comment">// 检测Activity泄漏</span></span><br><span class="line">        .detectContentUriWithoutPermission()	<span class="comment">// 检测content://Uri而没有设置相应权限</span></span><br><span class="line">        .detectCredentialProtectedWhileLocked() <span class="comment">// 检测用户被锁定时访问受凭证保护的存储区域</span></span><br><span class="line">        .detectFileUriExposure()	<span class="comment">// 应用向另一个应用公开文件时检测</span></span><br><span class="line">        .detectImplicitDirectBoot()</span><br><span class="line">        .detectLeakedClosableObjects()			<span class="comment">// 检测Closeable未关闭</span></span><br><span class="line">        .detectLeakedRegistrationObjects()		<span class="comment">// 检测广播监听</span></span><br><span class="line">        .detectLeakedSqlLiteObjects()			<span class="comment">// 检测Sqlite对象泄漏</span></span><br><span class="line">        .detectNonSdkApiUsage()					<span class="comment">// 检测不属于公共Android SDK的api反射用法</span></span><br><span class="line">        .penaltyLog()	<span class="comment">// 当检测相应的内容时通过日志打印出来</span></span><br><span class="line">        .penaltyDeath() <span class="comment">// 当检测相应的内容时应用崩溃</span></span><br><span class="line">        .build()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Systrace</title>
    <url>/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Systrace/</url>
    <content><![CDATA[<h1 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h1><blockquote>
<p>结合Android内核的数据，生成Html报告</p>
<p>API18以上使用，推荐TraceCompat</p>
<p>需要python2的环境</p>
</blockquote>
<p>参考官方网站：<a href="https://developer.android.com/topic/performance/tracing/command-line"><code>https://developer.android.com/topic/performance/tracing/command-line</code></a></p>
<p>在Android 9上还可以使用系统内置的跟踪方法：<code>https://developer.android.com/topic/performance/tracing/on-device</code></p>
<h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始，参数为tag标记</span></span><br><span class="line">TraceCompat.beginSection(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// do something ....</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line">TraceCompat.endSection();</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python [sdk路径]&#x2F;platform-tools&#x2F;systrace&#x2F;systrace.py [option] [categories]</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python systrace.py -o mynewtrace.html sched freq idle am wm gfx view binder_driver hal dalvik camera input res</span><br></pre></td></tr></table></figure>

<p>更多参数含义如下：</p>
<ul>
<li>-t：指定统计时间</li>
<li>shced：cpu调度信息</li>
<li>gfx：图形信息</li>
<li>view：视图</li>
<li>wm：窗口管理</li>
<li>am：活动管理</li>
<li>app：应用信息</li>
<li>webview：webview信息</li>
<li>-a：指定目标应用程序的包名</li>
<li>-o：生成的systrace.html文件</li>
</ul>
<p>生成的文件需要通过<code>Chrome</code>浏览器进行加载</p>
<p>在地址栏输入 <code>chrome://tracing</code> 命令，通过 <code>load</code> 载入</p>
<p><img src="/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/Systrace/Systrace.png"></p>
<h4 id="UI快捷键"><a href="#UI快捷键" class="headerlink" title="UI快捷键"></a>UI快捷键</h4><p>W：放大<br>S：缩小<br>A：左移<br>D：右移<br>M：选定函数的耗时时间范围</p>
<h4 id="cputime与walltime区别"><a href="#cputime与walltime区别" class="headerlink" title="cputime与walltime区别"></a>cputime与walltime区别</h4><ul>
<li>wall time是代码执行时间</li>
<li>cpu time时代码消耗cpu的时间（优化方向，应尽可能跑满cpu）</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>轻量级，开销小</li>
<li>直观反映cpu利用率</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>TraceView</title>
    <url>/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/TraceView/</url>
    <content><![CDATA[<h1 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h1><blockquote>
<p>图形的形式展示执行时间、调用栈等</p>
<p>信息全面，包含所有线程</p>
</blockquote>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始</span></span><br><span class="line">Debug.startMethodTracing(<span class="string">&quot;file_name&quot;</span>);</span><br><span class="line"><span class="comment">// do something ....</span></span><br><span class="line"><span class="comment">// 结束</span></span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure>

<p>生成的文件在<code>sd</code>卡：<code>Android/data/packagename/files</code></p>
<h4 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h4><p>将生成的<code>trace</code>文件导出后，通过<code>Android studio</code>内置的<code>Profile</code>工具进行加载</p>
<p><img src="/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/TraceView/TraceView.png"></p>
<p>快捷键：</p>
<p>W：放大<br>S：缩小<br>A：左移<br>D：右移</p>
<p>说明：</p>
<ul>
<li><p><code>Thread Chart</code>：函数调用图</p>
<ul>
<li>绿色：自身代码</li>
<li>橙色：系统<code>api</code></li>
<li>蓝色：三方<code>api</code>（包括 <code>Java API</code>）</li>
</ul>
</li>
<li><p><code>Flame Chart</code>：火焰图，会把所有相同函数聚合在一起</p>
</li>
<li><p><code>Top Down</code>：函数调用链表</p>
</li>
<li><p><code>Bottom up</code>：谁调用了该函数</p>
</li>
<li><p><code>Wall Clock Time</code>：程序执行时间</p>
</li>
<li><p><code>Thread Time</code>：cpu消耗时间</p>
</li>
</ul>
<h4 id="新方式"><a href="#新方式" class="headerlink" title="新方式"></a>新方式</h4><p>新版本 <code>Android studio</code> 可使用 <code>cpu profiler</code> 捉取信息</p>
<p><img src="/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/TraceView/cpu_profiler.png"></p>
<ul>
<li><code>Sample Java Methods</code><ul>
<li>频繁捕获应用的堆栈信息，对运行时性能开销较小，但有可能记录不准确</li>
</ul>
</li>
<li><code>Trace Java Methods</code><ul>
<li>会记录方法的详细执行时间和CPU信息，对运行时性能开销较大</li>
</ul>
</li>
<li><code>Sample C/C++ Functions</code><ul>
<li>需要 <code>Android 8.0</code> 及以上的设备，内部使用 <code>simpleperf</code> 跟踪应用的 <code>native</code> 代码</li>
</ul>
</li>
<li><code>Trace System Calls</code><ul>
<li>需要 <code>Android 7.0</code> 及以上的设备，捕获非常详细的应用运行和应用与系统资源交互情况</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>TraceView</code></p>
<ul>
<li><p>通过代码进行埋点，可控性更高</p>
</li>
<li><p>运行时开销严重，整体都会变慢，可能会带偏优化方向</p>
</li>
</ul>
<p><code>cpu profiler</code></p>
<ul>
<li>可通过 <code>IDE</code> 随时捕捉线程信息</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>dump 内存的几种方式</title>
    <url>/2020/12/30/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/dump%20%E5%86%85%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="dump-内存的几种方式"><a href="#dump-内存的几种方式" class="headerlink" title="dump 内存的几种方式"></a>dump 内存的几种方式</h1><p>获取内存文件：</p>
<ol>
<li>通过 <code>Memory Profiler </code> Dump 内存</li>
<li>通过 <code>am dumpheap &lt;pid&gt; /data/local/tmp/health.hprof</code> Dump到手机里，然后再导出</li>
<li>通过内置代码 <code>Debug.dumpHprofData()</code> Dump到手机里，注意需要写权限或者私有目录</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>启动时间测量方式</title>
    <url>/2020/12/25/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E6%B5%8B%E9%87%8F%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="启动时间测量方式"><a href="#启动时间测量方式" class="headerlink" title="启动时间测量方式"></a>启动时间测量方式</h1><h3 id="获取启动时间的方式"><a href="#获取启动时间的方式" class="headerlink" title="获取启动时间的方式"></a>获取启动时间的方式</h3><h5 id="方式一：adb-命令"><a href="#方式一：adb-命令" class="headerlink" title="方式一：adb 命令"></a>方式一：<code>adb</code> 命令</h5><p><code>adb shell am start -W  packagename/首屏Activity</code></p>
<ul>
<li><code>ThisTime</code>：最后一个<code>Activity</code>启动耗时</li>
<li><code>TotalTime</code>：所有<code>Activity</code>启动耗时</li>
<li><code>WaitTime</code>：AMS启动<code>Activity</code>的总耗时</li>
</ul>
<p>特点：</p>
<ul>
<li>线下使用方便，不能带到线上</li>
<li>非严谨、精确时间</li>
</ul>
<h5 id="方式二：实验室监控：视频录制"><a href="#方式二：实验室监控：视频录制" class="headerlink" title="方式二：实验室监控：视频录制"></a>方式二：实验室监控：视频录制</h5><p>通过高速摄像头录制app启动过程，然后计算启动消耗帧率</p>
<p>有条件的还可以使用图像识别技术实现自动化</p>
<h5 id="方式三：手动打点"><a href="#方式三：手动打点" class="headerlink" title="方式三：手动打点"></a>方式三：手动打点</h5><p>启动时埋点，启动结束买点，二者差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动打点记录相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchTimer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> sTime;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cost = System.currentTimeMillis() - sTime;</span><br><span class="line">        Log.w(<span class="string">&quot;LaunchTimer&quot;</span>,<span class="string">&quot;cost: &quot;</span> + cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开始打点：</strong>在<code>Application</code>的<code>attachBaseContext</code>方法里打点，这里是app所能收到的最早回调时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Application</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    LaunchTimer.startRecord();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结束打点：</strong></p>
<ul>
<li>误区：在<code>onWindowFocusChanged</code>里打点，这里只是首帧时间，用户未必可以交互</li>
<li>正解：在界面的真实数据展示里的UI进行打点，如列表的第一条数据、可交互控件的显示等</li>
</ul>
<p>要在必要的可交互View中进行结束打点，如下操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">view.getViewTreeObserver().addOnDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        view.getViewTreeObserver().removeOnDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        LaunchTimer.endRecord();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>精确，可带到线上，并能将记录到的时间上传至后台，<strong>推荐使用</strong></li>
</ul>
<h3 id="启动类型监控"><a href="#启动类型监控" class="headerlink" title="启动类型监控"></a>启动类型监控</h3><ul>
<li>首次安装启动（由于有 <code>dex</code>优化的过程，首次安装刚开始可能内存和代码执行效率不是很高）</li>
<li>覆盖安装启动（由于有 <code>dex</code>优化的过程，覆盖安装刚开始可能内存和代码执行效率不是很高）</li>
<li>冷启动（指标）</li>
<li>热启动（可以反映程序的保活能力）</li>
</ul>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><ol>
<li><p>启动结束时机</p>
<p>是否时以用户真正可以操作的时间作为启动结束的时间</p>
</li>
<li><p>启动时间扣除逻辑</p>
<p>闪屏、广告和引导页消耗的时间应该从启动时间里扣除</p>
</li>
<li><p>启动排除逻辑</p>
<p>对于 <code>Broadcast</code>、<code>Server</code> 拉起进程，但是没有启动 <code>Activity</code> 需要排除统计</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>监控 GC</title>
    <url>/2020/12/27/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E7%9B%91%E6%8E%A7GC/</url>
    <content><![CDATA[<h1 id="监控-GC"><a href="#监控-GC" class="headerlink" title="监控 GC"></a>监控 GC</h1><p>参考：<code>com.android.internal.os.BinderInternal</code> 里的监控 GC 操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcWatcherInternal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WeakReference&lt;GcWatcher&gt; sGcWatcher;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Runnable&gt; sGcWatchers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Runnable[] sTmpWatchers = <span class="keyword">new</span> Runnable[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> sLastGcTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GcWatcher</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            sLastGcTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">synchronized</span> (sGcWatchers) &#123;</span><br><span class="line">                sTmpWatchers = sGcWatchers.toArray(sTmpWatchers);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sTmpWatchers.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sTmpWatchers[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sTmpWatchers[i].run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sGcWatcher = <span class="keyword">new</span> WeakReference&lt;GcWatcher&gt;(<span class="keyword">new</span> GcWatcher());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addGcWatcher</span><span class="params">(Runnable watcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sGcWatchers) &#123;</span><br><span class="line">            sGcWatchers.add(watcher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeGcWatcher</span><span class="params">(Runnable watcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sGcWatchers) &#123;</span><br><span class="line">            sGcWatchers.remove(watcher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>获取帧率</title>
    <url>/2021/01/05/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E5%B8%A7%E7%8E%87/</url>
    <content><![CDATA[<h1 id="获取帧率"><a href="#获取帧率" class="headerlink" title="获取帧率"></a>获取帧率</h1><p>参考：<code>android.view.ViewRootImpl#draw</code> 里的 <code>trackFPS</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FpsCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MONITOR_INTERVAL = <span class="number">160L</span>; <span class="comment">//单次计算FPS使用160毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MONITOR_INTERVAL_NANOS = MONITOR_INTERVAL * <span class="number">1000L</span> * <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_INTERVAL = <span class="number">1000L</span>; <span class="comment">//设置计算fps的单位时间间隔1000ms,即fps/s;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mStartFrameTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFrameCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getFPS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mStartFrameTime == <span class="number">0</span>) &#123;</span><br><span class="line">                    mStartFrameTime = frameTimeNanos;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> interval = frameTimeNanos - mStartFrameTime;</span><br><span class="line">                <span class="keyword">if</span> (interval &gt; MONITOR_INTERVAL_NANOS) &#123;</span><br><span class="line">                    <span class="keyword">double</span> fps = (((<span class="keyword">double</span>) (mFrameCount * <span class="number">1000L</span> * <span class="number">1000L</span>)) / interval) * MAX_INTERVAL;</span><br><span class="line">                    mFrameCount = <span class="number">0</span>;</span><br><span class="line">                    mStartFrameTime = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++mFrameCount;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>监控所有消息的发送栈和执行时间</title>
    <url>/2021/01/06/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E7%9B%91%E6%8E%A7%E6%89%80%E6%9C%89%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81%E6%A0%88%E5%92%8C%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="监控所有消息的发送栈和执行时间"><a href="#监控所有消息的发送栈和执行时间" class="headerlink" title="监控所有消息的发送栈和执行时间"></a>监控所有消息的发送栈和执行时间</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mStartTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Looper.myLooper(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperHandler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Looper.myLooper(), callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperHandler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> send = <span class="keyword">super</span>.sendMessageAtTime(msg, uptimeMillis);</span><br><span class="line">        <span class="keyword">if</span> (send) &#123;</span><br><span class="line">            GetDetailHandlerHelper.getMsgDetail().put(msg, Log.getStackTraceString(<span class="keyword">new</span> Throwable()).replace(<span class="string">&quot;java.lang.Throwable&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> send;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        mStartTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">super</span>.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GetDetailHandlerHelper.getMsgDetail().containsKey(msg)</span><br><span class="line">                &amp;&amp; Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jsonObject.put(<span class="string">&quot;Msg_Cost&quot;</span>, System.currentTimeMillis() - mStartTime);</span><br><span class="line">                jsonObject.put(<span class="string">&quot;MsgTrace&quot;</span>, msg.getTarget() + <span class="string">&quot; &quot;</span> + GetDetailHandlerHelper.getMsgDetail().get(msg));</span><br><span class="line"></span><br><span class="line">                Log.i(<span class="string">&quot;MsgDetail &quot;</span> , jsonObject.toString());</span><br><span class="line">                GetDetailHandlerHelper.getMsgDetail().remove(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetDetailHandlerHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Message, String&gt; sMsgDetail = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Message, String&gt; <span class="title">getMsgDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sMsgDetail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>获取方法耗时</title>
    <url>/2020/12/25/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E8%80%97%E6%97%B6/</url>
    <content><![CDATA[<h1 id="获取方法耗时"><a href="#获取方法耗时" class="headerlink" title="获取方法耗时"></a>获取方法耗时</h1><h4 id="手动打点"><a href="#手动打点" class="headerlink" title="手动打点"></a>手动打点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="keyword">long</span> cost = System.currentTimeMillis() - start;</span><br></pre></td></tr></table></figure>

<p>方便但是不够优雅，代码侵入性强且工作量大</p>
<h4 id="AOP-Art-Hook实现"><a href="#AOP-Art-Hook实现" class="headerlink" title="AOP/Art Hook实现"></a>AOP/Art Hook实现</h4><p><a href="/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/AOP-Aspectjx/">参考Aspectjx</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;call(* com.benben.starttest.MainActivity.**(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(<span class="string">&quot;time&quot;</span>,<span class="string">&quot;cost: &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/ART-Hook/">参考ART</a></p>
<p>总结：</p>
<p>无侵入性、推荐使用</p>
<p>注意：</p>
<p>需要将简单函数过滤掉，最好支持黑名单过滤</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>获取界面布局耗时</title>
    <url>/2021/01/05/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E7%95%8C%E9%9D%A2%E5%B8%83%E5%B1%80%E8%80%97%E6%97%B6/</url>
    <content><![CDATA[<h1 id="获取界面布局耗时"><a href="#获取界面布局耗时" class="headerlink" title="获取界面布局耗时"></a>获取界面布局耗时</h1><h4 id="常规方式"><a href="#常规方式" class="headerlink" title="常规方式"></a>常规方式</h4><p>复写方法、手动埋点</p>
<h4 id="AOP-Art-Hook实现"><a href="#AOP-Art-Hook实现" class="headerlink" title="AOP/Art Hook实现"></a>AOP/Art Hook实现</h4><p>通过 <code>hook</code> <code>setContentView</code> 来优雅的实现布局耗时</p>
<p><a href="/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/AOP-Aspectjx/">参考Aspectjx</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* android.app.Activity.setContentView(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSetContentViewTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        String name = signature.toShortString();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(name + <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="/2020/12/24/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E5%B7%A5%E5%85%B7/ART-Hook/">参考ART</a></p>
<p>总结：</p>
<p>无侵入性、推荐使用</p>
<h4 id="扩展：获取每个控件的加载耗时"><a href="#扩展：获取每个控件的加载耗时" class="headerlink" title="扩展：获取每个控件的加载耗时"></a>扩展：获取每个控件的加载耗时</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        LayoutInflater.from(<span class="keyword">this</span>).setFactory2(<span class="keyword">new</span> LayoutInflater.Factory2() &#123;</span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> String name, <span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                View view = getDelegate().createView(parent, name, context, attrs);</span><br><span class="line">                Log.e(<span class="string">&quot;createViewTime&quot;</span>, <span class="string">&quot;cost: &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> String name, <span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> onCreateView(<span class="keyword">null</span>, name, context, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 注意：需要在super前配置</span></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>获取锁调用链</title>
    <url>/2021/01/06/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E9%94%81%E8%B0%83%E7%94%A8%E9%93%BE/</url>
    <content><![CDATA[<blockquote>
<p>在日常开发中，当出现锁被长期持有或者出现死锁，造成流程无法正常执行，甚至产生ANR，这时候就需要获取被阻塞的线程和持有锁的线程，该 demo 展示了如何获取被阻塞的线程和持有锁的线程相关调用链</p>
</blockquote>
<h1 id="获取锁调用链"><a href="#获取锁调用链" class="headerlink" title="获取锁调用链"></a>获取锁调用链</h1><p>需要知道当前线程在等待那个锁，以及这个锁被那个线程持有，然后把发生死锁的线程堆栈信息搜集起来</p>
<p>流程如下：</p>
<ol>
<li>获取当前 <code>blocked</code> 状态的线程</li>
<li>获取该线程想要竞争的锁</li>
<li>获取该锁被那个线程持有</li>
<li>通过关系链，判断死锁的线程，输出堆栈信息</li>
</ol>
<p>在 Java 层并没有相关 API 可以实现死锁监控，可以从 Native 层入手</p>
<h4 id="一、获取当前-blocked-状态的线程"><a href="#一、获取当前-blocked-状态的线程" class="headerlink" title="一、获取当前 blocked 状态的线程"></a>一、获取当前 blocked 状态的线程</h4><p>根据线程状态得到 <code>blocked</code> 的线程，并获取它的内存地址指针 <code>nativePeer</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> allThreads = getAllThreads()</span><br><span class="line"><span class="keyword">for</span> (thread <span class="keyword">in</span> allThreads) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread!!.state == Thread.State.BLOCKED) &#123;</span><br><span class="line">        <span class="keyword">val</span> nativePeer = (ReflectUtil.getField(Thread::<span class="keyword">class</span>.java, thread, <span class="string">&quot;nativePeer&quot;</span>) <span class="keyword">as</span>? <span class="built_in">Long</span>) ?: <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (nativePeer == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 内存地址指针等于0，说明未创建、启动或已销毁</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到 <code>blocked</code> 线程的内存地址指针后，接下来需要寻找第二第三步 Native 层中所需要的函数</p>
<h4 id="二、Native层：获取当前线程想要竞争的锁和获取目标锁被哪个线程持有"><a href="#二、Native层：获取当前线程想要竞争的锁和获取目标锁被哪个线程持有" class="headerlink" title="二、Native层：获取当前线程想要竞争的锁和获取目标锁被哪个线程持有"></a>二、Native层：获取当前线程想要竞争的锁和获取目标锁被哪个线程持有</h4><ul>
<li><p>获取当前线程想要竞争的锁</p>
<p>函数：<code>Monitor::GetContendedMonitor</code></p>
<p>从源码和源码的解释可以看出，这个函数是用来获取当前线程等待的Monitor</p>
<p>源码：<a href="http://aosp.opersys.com/xref/android-11.0.0_r37/xref/art/runtime/monitor.cc">http://aosp.opersys.com/xref/android-11.0.0_r37/xref/art/runtime/monitor.cc</a></p>
<p><img src="/2021/01/06/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E9%94%81%E8%B0%83%E7%94%A8%E9%93%BE/DeadLockMonitor_GetContendedMonitor.png"></p>
</li>
<li><p>获取目标锁被哪个线程持有</p>
<p>函数：<code>Monitor::GetLockOwnerThreadId</code></p>
<p>源码：<a href="http://aosp.opersys.com/xref/android-11.0.0_r37/xref/art/runtime/monitor.cc">http://aosp.opersys.com/xref/android-11.0.0_r37/xref/art/runtime/monitor.cc</a></p>
<p><img src="/2021/01/06/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%8E%B7%E5%8F%96%E9%94%81%E8%B0%83%E7%94%A8%E9%93%BE/DeadLockMonitor_GetLockOwnerThreadId.png"></p>
</li>
</ul>
<p>我们可以通过 <code>dlopen</code> 以指定模式打开指定的动态链接库文件，并返回一个句柄给 <code>dlsym</code> 使用，随后通过 <code>dlclose</code> 关闭。</p>
<p>由于 <code>Android 7.0</code> 开始，系统限制 App 调用 <code>dlopen</code> <code>dlsym</code> <code>dladdr</code> <code>dlclose</code> <code>dlerror</code> 等函数使用系统动态库，这里使用 <a href="https://github.com/Rprop/ndk_dlopen"><code>ndk_dlopen</code></a> 这个库绕开这个限制，用法与原有逻辑一致，只是在调用时需要加上 <code>ndk_</code> 前缀。</p>
<p>参考：<a href="https://www.sunmoonblog.com/2019/06/04/fake-dlopen/?spm=ata.13261165.0.0.bb4d1bc8hQmHlY">Android dlopen 方法的使用限制及解决方案</a></p>
<h4 id="三、打开指定的动态链接库"><a href="#三、打开指定的动态链接库" class="headerlink" title="三、打开指定的动态链接库"></a>三、打开指定的动态链接库</h4><p>涉及的相关 Native 层动态库为 <code>libart.so</code></p>
<p>该库路径：</p>
<p><code>Android 9.0</code> 以前：<code>/system/lib/libart.so</code></p>
<p><code>Android 10.0</code> 起：<code>/system/apex/com.android.adbd/lib/libart.so</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ndk_init</span>(env); <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">void</span> *so_addr = <span class="built_in">ndk_dlopen</span>(<span class="string">&quot;libart.so&quot;</span>, RTLD_NOLOAD); <span class="comment">// 加载libart.so</span></span><br><span class="line"><span class="keyword">if</span> (so_addr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开动态库之后，得到动态库句柄，接下来需要通过 <code>dlsym</code> 函数根据动态库句柄和函数符号返回函数对应的地址，即获取 <code>GetContendedMonitor</code> 和 <code>GetLockOwnerThreadId</code> 函数地址。</p>
<p>【注意】c++ 可以重载，所以它的函数符号比较特殊，需要从 <code>libart.so</code> 中获取，so库可以从上面系统目录中导出，这里提供两个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nm -D libart.so | grep -E &#x27;GetContendedMonitor|GetLockOwnerThreadId&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">objdump -tT libart.so | grep -E &#x27;GetContendedMonitor|GetLockOwnerThreadId&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="四、获取函数符号对应的函数地址"><a href="#四、获取函数符号对应的函数地址" class="headerlink" title="四、获取函数符号对应的函数地址"></a>四、获取函数符号对应的函数地址</h4><ul>
<li><p><code>GetContendedMonitor</code> 函数这里对应的函数符号为 <code>_ZN3art7Monitor19GetContendedMonitorEPNS_6ThreadE</code>，根据函数符号地址获取函数地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">get_contended_monitor = <span class="built_in">ndk_dlsym</span>(so_addr, <span class="string">&quot;_ZN3art7Monitor19GetContendedMonitorEPNS_6ThreadE&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (get_contended_monitor == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>GetLockOwnerThreadId</code> 函数对应的函数符号需要通过系统版本来判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">get_lock_owner_symbol_name</span><span class="params">(jint level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &lt; <span class="number">29</span>) &#123;</span><br><span class="line">        <span class="comment">//android 9.0 之前</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;_ZN3art7Monitor20GetLockOwnerThreadIdEPNS_6mirror6ObjectE&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level &lt;= <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;_ZN3art7Monitor20GetLockOwnerThreadIdENS_6ObjPtrINS_6mirror6ObjectEEE&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据函数符号地址获取函数地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">get_lock_owner_thread_id = <span class="built_in">ndk_dlsym</span>(so_addr, <span class="built_in">get_lock_owner_symbol_name</span>(sdk_version));</span><br><span class="line"><span class="keyword">if</span> (get_lock_owner_thread_id == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="五、获取一直不释放锁的线程"><a href="#五、获取一直不释放锁的线程" class="headerlink" title="五、获取一直不释放锁的线程"></a>五、获取一直不释放锁的线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">extern <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_com_benben_deadlockmonitordemo_DeadLockCheck_getBlockThreadNativeId(JNIEnv *env, jobject thiz,</span><br><span class="line">                                                                         jlong nativePeer) &#123;</span><br><span class="line">    LOGI(<span class="string">&quot;getContentThreadIdArt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> monitor_thread_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (get_contended_monitor != nullptr &amp;&amp; get_lock_owner_thread_id != nullptr) &#123;</span><br><span class="line">        <span class="comment">// 获取监视器</span></span><br><span class="line">        <span class="keyword">int</span> monitorObj = ((<span class="keyword">int</span> (*)(<span class="keyword">long</span>)) get_contended_monitor)(nativePeer);</span><br><span class="line">        <span class="keyword">if</span> (monitorObj != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过监视器获取具有执行权的线程id</span></span><br><span class="line">            monitor_thread_id = ((<span class="keyword">int</span> (*)(<span class="keyword">int</span>)) get_lock_owner_thread_id)(monitorObj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            monitor_thread_id = <span class="number">0</span>;</span><br><span class="line">            LOGE(<span class="string">&quot;get_contended_monitor return 0.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (get_contended_monitor == nullptr) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;get_contended_monitor == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (get_lock_owner_thread_id == nullptr) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;get_lock_owner_thread_id == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> monitor_thread_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个步骤：</p>
<ol>
<li>通过 <code>GetContendedMonitor</code> 函数获取当前线程要竞争的锁监视器</li>
<li>通过 <code>GetLockOwnerThreadId</code> 函数获取监视器的当前具有执行权的线程id</li>
</ol>
<p>通过以上两步，就能得到一直不释放的线程id</p>
<h5 id="六、锁分组并打印调用栈"><a href="#六、锁分组并打印调用栈" class="headerlink" title="六、锁分组并打印调用栈"></a>六、锁分组并打印调用栈</h5><p>我们已经找的阻塞的线程和持有锁的线程，这里涉及到一个关系链：</p>
<ol>
<li>场景一：1 &gt; 2, 2 &gt; 1</li>
<li>场景二：1 &gt; 2, 2 &gt; 3, 3 &gt; 1</li>
<li>场景三：1 &gt; 2, 2 &gt; 3, 3 &gt; 1, other &gt; 1</li>
<li>其它</li>
</ol>
<p>需要通过算法将不同场景的线程进行归纳分组，找出调用栈</p>
<p>弹异常框、Toast、数据上报等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~start~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: waitThread &#x3D; lock2 &gt; lock3</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: blockedThread &#x3D; lock1 &gt; lock2</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: lock1 &gt; lock2 stack.</span><br><span class="line">    com.benben.deadlockmonitordemo.DeadLockUtil$createDeadLock$1.invoke(DeadLockUtil.kt:28)</span><br><span class="line">    com.benben.deadlockmonitordemo.DeadLockUtil$createDeadLock$1.invoke(DeadLockUtil.kt:23)</span><br><span class="line">    kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: waitThread &#x3D; lock3 &gt; lock1</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: blockedThread &#x3D; lock2 &gt; lock3</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: lock2 &gt; lock3 stack.</span><br><span class="line">    com.benben.deadlockmonitordemo.DeadLockUtil$createDeadLock$2.invoke(DeadLockUtil.kt:39)</span><br><span class="line">    com.benben.deadlockmonitordemo.DeadLockUtil$createDeadLock$2.invoke(DeadLockUtil.kt:34)</span><br><span class="line">    kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: waitThread &#x3D; lock1 &gt; lock2</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: blockedThread &#x3D; lock3 &gt; lock1</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: lock3 &gt; lock1 stack.</span><br><span class="line">    com.benben.deadlockmonitordemo.DeadLockUtil$createDeadLock$3.invoke(DeadLockUtil.kt:50)</span><br><span class="line">    com.benben.deadlockmonitordemo.DeadLockUtil$createDeadLock$3.invoke(DeadLockUtil.kt:45)</span><br><span class="line">    kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</span><br><span class="line">18752-18752&#x2F;com.benben.deadlockmonitordemo E&#x2F;DL_DeadLockCheck: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~end~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>

<h5 id="demo-工程"><a href="#demo-工程" class="headerlink" title="demo 工程"></a>demo 工程</h5><p><code>github</code> 地址：<a href="https://github.com/yefawei/DeadLockMonitorDemo">https://github.com/yefawei/DeadLockMonitorDemo</a></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于时通过动态链接的形式获取的线程信息，需要考虑系统兼容性，如鸿蒙系统、各个厂家的系统、不同安卓版本的系统等等，在线上使用可以只针对已经稳定测试过的系统开放</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>设置启动Theme</title>
    <url>/2020/12/26/Android/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/%E6%8A%80%E5%B7%A7/%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8Theme/</url>
    <content><![CDATA[<h1 id="设置启动Theme"><a href="#设置启动Theme" class="headerlink" title="设置启动Theme"></a>设置启动Theme</h1><blockquote>
<p>设置启动Theme可以去除启动白屏的情况，同时从视觉效果上感觉app启动速度加快了</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在app启动时，会先加载一个空白<code>window</code>，然后再启动<code>app</code>进程，<code>Theme</code>就是作用于该空白<code>window</code>上的</p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ol>
<li><p>创建一个<code>drawable</code>。注意：图片宽高最好是比屏幕较大的手机还要大一些，核心内容较为居中，这样能够兼容屏幕较小的手机且图像不会拉伸变形</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--图片最好是能够覆盖屏幕较大的手机--&gt;</span></span><br><span class="line">        &lt;bitmap</span><br><span class="line">            android:src=&quot;@mipmap/img_splash_bg&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;/&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建主题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;LauncherTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowFullscreen&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/launcher<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>为启动<code>Activity</code>设置该主题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.SplashActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/LauncherTheme&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在<code>Activity</code>中的<code>onCreate</code>方法中将主题切换回来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里将主题切换回来</span></span><br><span class="line">    setTheme(R.style.Theme);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2020/09/13/Docker/Docker%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><ol>
<li><p>官方文档</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker.com&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>Docker安装：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装前检查</span><br><span class="line">    1.内核版本</span><br><span class="line">        uname -a</span><br><span class="line">    2.检查Device Mapper</span><br><span class="line">        ls -l &#x2F;sys&#x2F;class&#x2F;misc&#x2F;device-mapper</span><br><span class="line">Ubuntu中安装Docker的方式</span><br><span class="line">    1.安装Ubuntu维护的版本(版本相对官方有可能会低点)</span><br><span class="line">            安装：		sudo apt-get install docker.io</span><br><span class="line">        更新配置：	source &#x2F;etc&#x2F;bash_completion.d&#x2F;docker.io</span><br><span class="line">    2.安装Docker维护的版本(推荐)</span><br><span class="line">        wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</span><br><span class="line">        输入当前用户的密码后，就会下载脚本并且安装Docker及依赖包。</span><br><span class="line">        安装完成后有个提示:</span><br><span class="line">        If you would like to use Docker as a non-root user, you should now consider</span><br><span class="line">        adding your user to the &quot;docker&quot; group with something like:</span><br><span class="line">        sudo usermod -aG docker runoob</span><br><span class="line">        Remember that you will have to log out and back in for this to take effect!</span><br><span class="line"></span><br><span class="line">        意思是:当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker [user] 命令，然后重新登陆，否则会有如下报错</span><br><span class="line"></span><br><span class="line">可以通过直接输入docker命令查看Docker客户端的所有命令选项</span><br><span class="line">可以通过命令 docker command --help 更深入的了解指定的 Docker 命令使用方法。</span><br><span class="line">例如我们要查看 docker stats 指令的具体使用方法：</span><br><span class="line">docker stats --help</span><br><span class="line">    3.测试</span><br><span class="line">        sudo docker run hello-world</span><br><span class="line">    4.非root用户运行docker</span><br><span class="line">        创建一个用户组：			sudo groupadd docker</span><br><span class="line">        将当前用户添加到用户组：	sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class="line">        注销并重新启动docker服务：	sudo service docker restart</span><br></pre></td></tr></table></figure></li>
<li><p>镜像的基本操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 查看版本</span><br><span class="line">    docker version</span><br><span class="line"></span><br><span class="line">2. 查看docker信息</span><br><span class="line">    docker info</span><br><span class="line"></span><br><span class="line">3. 列出镜像</span><br><span class="line">    docker images [OPTSIONS] [REPOSITORY]</span><br><span class="line">    -a --all&#x3D;false      显示所有镜像，包括中间层镜像</span><br><span class="line">    -f --filter&#x3D;[]      显示时的过滤条件</span><br><span class="line">    --no-trunc&#x3D;false    不截断镜像的唯一id</span><br><span class="line">    -q --quiet&#x3D;false    只显示镜像的唯一id</span><br><span class="line"></span><br><span class="line">4. 查看镜像</span><br><span class="line">    docker inspect [OPTSIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class="line"></span><br><span class="line">5. 删除镜像</span><br><span class="line">    docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">    -f --force&#x3D;false    强制删除镜像</span><br><span class="line">    --no-prune&#x3D;false    保留未打标签的父镜像</span><br><span class="line"></span><br><span class="line">6. 查找镜像</span><br><span class="line">    方式一:Docker Hub</span><br><span class="line">        https:&#x2F;&#x2F;registry.hub.docker.com</span><br><span class="line"></span><br><span class="line">    方式二:</span><br><span class="line">    docker search [OPTIONS]</span><br><span class="line">    --automated&#x3D;false   只显示自动化构建的镜像</span><br><span class="line">    --no-trunc&#x3D;false    不截断显示</span><br><span class="line">    -s --stars&#x3D;0        过滤分数需要高于设置的镜像</span><br><span class="line"></span><br><span class="line">7. 拉取镜像</span><br><span class="line">    docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line">    -a --all-tags&#x3D;false 匹配名字的镜像全部下载到本地</span><br><span class="line"></span><br><span class="line">    修改镜像获取地址</span><br><span class="line">        使用--registry-mirror选项</span><br><span class="line">        1.修改：&#x2F;etc&#x2F;default&#x2F;docker</span><br><span class="line">        2.添加：DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;http:&#x2F;&#x2F;MIRROR-ADDR&quot;</span><br><span class="line">    https:&#x2F;&#x2F;www.daocloud.io</span><br><span class="line"></span><br><span class="line">8. 推送镜像</span><br><span class="line">    docker push NAME[:TAG]</span><br><span class="line"></span><br><span class="line">9. 查看镜像构建过程</span><br><span class="line">    docker history IMAGE</span><br><span class="line"></span><br><span class="line">10. 构建镜像</span><br><span class="line">    使用commit构建镜像</span><br><span class="line">        docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">        -a --author&#x3D;&quot;&quot;      指定作者</span><br><span class="line">        -m --message&#x3D;&quot;&quot;     指定信息</span><br><span class="line">        -p --pause&#x3D;true     不暂停容器并提交</span><br><span class="line"></span><br><span class="line">    使用Dockerfile构建镜像</span><br><span class="line">        1. 创建Dockerfile文件</span><br><span class="line">              #First Dockerfile</span><br><span class="line">              FROM ubuntu:14.04             # 源仓库</span><br><span class="line">              MAINTAINER 维护人 &quot;维护人邮箱&quot;</span><br><span class="line">              RUN command1                  # 执行的命令</span><br><span class="line">              RUN command2                  # 执行的命令</span><br><span class="line">              RUN command3                  # 执行的命令</span><br><span class="line">              ...</span><br><span class="line">              EXPOSE 80                     # 暴露的端口</span><br><span class="line">              CMD command4</span><br><span class="line">        2. 使用docker build 命令</span><br><span class="line">            docker build [OPTIONS] PATH|URL|-</span><br><span class="line">            --force-rm&#x3D;false</span><br><span class="line">            --no-cache&#x3D;false    不启用构建缓存</span><br><span class="line">            --pull&#x3D;false</span><br><span class="line">            -q --quiet&#x3D;false    静默操作，不打印日志</span><br><span class="line">            --rm&#x3D;true</span><br><span class="line">            -t --tag&#x3D;&quot;&quot;         指定仓库名字</span><br><span class="line">        3. Dockerfile指令</span><br><span class="line">            1. 注释</span><br><span class="line">                以#开头，单行注释</span><br><span class="line"></span><br><span class="line">            2. 指令</span><br><span class="line">                以大写的指令名开始，后面接着指令参数</span><br><span class="line"></span><br><span class="line">            3. FROM指令：指定基础镜像</span><br><span class="line">                格式：</span><br><span class="line">                    FROM &lt;image&gt;</span><br><span class="line">                    FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">                要求：</span><br><span class="line">                    已经存在的镜像</span><br><span class="line">                    必须是第一条非注释指令</span><br><span class="line"></span><br><span class="line">            4. MAINTAINER指令：指定镜像作者信息，包含镜像所有者和联系信息，相当于commit命令的-a属性</span><br><span class="line">                格式：</span><br><span class="line">                    MAINTAINER &lt;name&gt;</span><br><span class="line"></span><br><span class="line">            5. RUN指令：指定当前镜像中运行的命令,每条RUN指令都会基于上一条RUN指令的新镜像上添加</span><br><span class="line">                格式：</span><br><span class="line">                    RUN &lt;command&gt; (shell模式)</span><br><span class="line">                        例：&#x2F;bin&#x2F;sh -c command 相对于执行了该命令</span><br><span class="line">                            RUN echo hello</span><br><span class="line">                    RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                        例：RUN [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</span><br><span class="line"></span><br><span class="line">            6. EXPOSE指令：指定运行该镜像的容器使用的端口</span><br><span class="line">                格式：</span><br><span class="line">                    EXPOSE &lt;port&gt; [&lt;port&gt;...]   可以指定一个或多个端口，也可使用多个EXPOSE命令</span><br><span class="line">                注意：</span><br><span class="line">                    虽然在构建镜像指定了端口，在容器运行时也需要通过run -p参数指定所使用的端口</span><br><span class="line"></span><br><span class="line">            7. CMD指令：提供容器运行时默认命令，于RUN指令相似，但是RUN指令是在镜像构建过程中执行的，CMD指令是在容器运行时运行的</span><br><span class="line">                格式：</span><br><span class="line">                    CMD &lt;command&gt; (shell模式)</span><br><span class="line">                    CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                    CMD [&quot;param1&quot;,&quot;param2&quot;] (作为ENTRYPOINT指令的默认参数)</span><br><span class="line">                注意：</span><br><span class="line">                    如果docker run指定了运行时的命令，那么CMD命令会被覆盖，也就是说CMD命令指定的时默认命令</span><br><span class="line"></span><br><span class="line">            8. ENTRYPOINT指令：与CMD指令相似，区别在于命令不会被覆盖，run指定的命令并不会执行</span><br><span class="line">                格式：</span><br><span class="line">                    ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                    ENTRYPOINT &lt;command&gt; (shell模式)</span><br><span class="line">                注意：</span><br><span class="line">                    如果需要覆盖，可以使用docker run --entrypoint覆盖</span><br><span class="line">                高级用法：</span><br><span class="line">                    用ENTRYPOINT来指定命令，用CMD来指定命令默认参数</span><br><span class="line">                    ENTRYPOINT [&quot;&#x2F;vsr&#x2F;bin&#x2F;nginx&quot;]</span><br><span class="line">                    CMD [&quot;-h&quot;]</span><br><span class="line"></span><br><span class="line">            9. ADD指令和COPY指令：将本地文件或目录复制到镜像中</span><br><span class="line">                格式：</span><br><span class="line">                    ADD &lt;src&gt;...&lt;dest&gt;</span><br><span class="line">                    ADD [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;](适用于文件路径中有空格的情况)</span><br><span class="line">                    COPY &lt;src&gt;...&lt;dest&gt;</span><br><span class="line">                    COPY [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;](适用于文件路径中有空格的情况)</span><br><span class="line">                    src：可以是本地地址(必须是构建目录中的相对地址)和远程URL(不推荐)</span><br><span class="line">                    dest:镜像中的绝对路径</span><br><span class="line">                区别：</span><br><span class="line">                    ADD vs COPY</span><br><span class="line">                        ADD 包含类似tar的解压功能</span><br><span class="line">                        如果单纯复制文件，Docker推荐使用COPY</span><br><span class="line"></span><br><span class="line">            10. VOLUME指令：向镜像容器添加卷，生成成数据卷容器</span><br><span class="line">                格式：</span><br><span class="line">                    VOLUME [&quot;&#x2F;data&quot;]</span><br><span class="line">                注意：</span><br><span class="line">                    该操作不能指定主机目录，由容器运行时动态生成主机挂载的目录</span><br><span class="line"></span><br><span class="line">            11. WORKDIR指令：在容器内部指定工作目录</span><br><span class="line">                格式：</span><br><span class="line">                    WORKDIR &#x2F;path&#x2F;to&#x2F;workdir    CMD和ENTRYPOINT都会在这个目录下执行</span><br><span class="line"></span><br><span class="line">            12. ENV指令：设置容器环境变量</span><br><span class="line">                格式：</span><br><span class="line">                    ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">                    ENV &lt;key&gt;&#x3D;&lt;value&gt;...</span><br><span class="line"></span><br><span class="line">            13. USER指令：指定镜像会以什么样的用户去运行</span><br><span class="line">                格式：</span><br><span class="line">                    USER daemon     可以使用uid：gid：group</span><br><span class="line">                    USER user       USER uid</span><br><span class="line">                    USER user:group USER uid:gid</span><br><span class="line">                    USER user:gid   USER uid:group</span><br><span class="line"></span><br><span class="line">            14. ONBUILD [INSTRUCTION]：为镜像添加触发器，当一个镜像被其他镜像作为基础镜像时执行，会在构建过程中插入指令</span><br><span class="line">                格式：</span><br><span class="line">                    ONBUILD [INSTRUCTION]</span><br><span class="line">                    例：</span><br><span class="line">                        ONBUILD COPY &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>镜像的导入导出</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 镜像导出</span><br><span class="line">    docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">    -o --output string 输出到文件</span><br><span class="line">    例:</span><br><span class="line">        docker save -o nginx.tar nginx:latest</span><br><span class="line">        或</span><br><span class="line">        docker save &gt; nginx.tar nginx:latest</span><br><span class="line">        其中-o和&gt;表示输出到文件，nginx.tar为目标文件，nginx:latest是源镜像名(name:tag)</span><br><span class="line"></span><br><span class="line">2. 镜像导入</span><br><span class="line">    docker load [OPTIONS]</span><br><span class="line">    -i --input 从文件输入</span><br><span class="line">    例：</span><br><span class="line">        docker load -i nginx.tar</span><br><span class="line">        或</span><br><span class="line">        docker load &lt; nginx.tar</span><br><span class="line">        其中-i和&lt;表示从文件输入。会成功导入镜像及相关元数据，包括tag信息</span><br><span class="line"></span><br><span class="line">3. 容器导出</span><br><span class="line">    docker export [options] container</span><br><span class="line">    -o --output string 输出到文件</span><br><span class="line">    例：</span><br><span class="line">        docker export -o nginx-test.tar nginx-test</span><br><span class="line">        其中-o表示输出到文件，nginx-test.tar为目标文件，nginx-test是源容器名(name)</span><br><span class="line"></span><br><span class="line">4. 容器导入</span><br><span class="line">    docker import [options] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line">    例：</span><br><span class="line">        docker import nginx-test.tar nginx:imp</span><br><span class="line">        或</span><br><span class="line">        cat nginx-test.tar | docker import - nginx:imp</span><br><span class="line"></span><br><span class="line">5. 说明与需要注意的地方</span><br><span class="line">    1. export命令导出的tar文件略小于save命令导出的</span><br><span class="line">    2. export命令是从容器（container）中导出tar文件，而save命令则是从镜像（images）中导出</span><br><span class="line">    3. 基于第二点，export导出的文件再import回去时，无法保留镜像所有历史（即每一层layer信息，不熟悉的可以去看Dockerfil），不能进行回滚操作；而save是依据镜像来的，所以导入时可以完整保留下每一层layer信息。如下图所示，nginx:latest是save导出load导入的，nginx:imp是export导出import导入的</span><br><span class="line"></span><br><span class="line">6. 建议</span><br><span class="line">    若是只想备份images，使用save、load即可</span><br><span class="line">    若是在启动容器后，容器内容有变化，需要备份，则使用export、import</span><br></pre></td></tr></table></figure></li>
<li><p>容器的基本操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 启动容器</span><br><span class="line">    docker run IMAGE [COMMAND] [ARG...]</span><br><span class="line">    run 在新容器中执行命令</span><br><span class="line"></span><br><span class="line">2. 启动交互式容器</span><br><span class="line">    docker run [--name 自定义名字] -i -t IMAGE &#x2F;bin&#x2F;bash</span><br><span class="line">    -i --interactive&#x3D;true | false 默认是false   告诉docker父进程始终打开标准输入</span><br><span class="line">    -t --tty&#x3D;true | false 默认是false           告诉docker父容器提供一个tty终端</span><br><span class="line"></span><br><span class="line">    将交互式容器派遣为守护石形式运行的容器</span><br><span class="line">    Ctrl+P Ctrl+Q</span><br><span class="line"></span><br><span class="line">3. 附加到运行中的容器</span><br><span class="line">    docker attach [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">4. 直接启动守护式容器</span><br><span class="line">    docker run -d IMAGE [COMMAND] [ARG...]</span><br><span class="line">    -d --detach     派遣为守护式容器启动</span><br><span class="line"></span><br><span class="line">5. 查看容器日志</span><br><span class="line">    docker logs [-f] [-t] [--tail SIZE] [CONTAINER ID或NAME]</span><br><span class="line">    -f --follows&#x3D;true | false 默认式false       一直跟踪日志变化并打印出来</span><br><span class="line">    -t --timestamps&#x3D;true | false 默认式false    在日志列加上时间戳</span><br><span class="line">    --tail&#x3D;数量                                返回结尾处多少数量的日志，0则默认最新</span><br><span class="line"></span><br><span class="line">6. 查看容器内进程</span><br><span class="line">    docker top [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">7. 在运行中的容器内启动新进程</span><br><span class="line">    docker exec [-d] [-i] [-t] [CONTAINER ID或NAME] [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">8. 查看创建了那些容器</span><br><span class="line">    docker ps [-a] [-l]</span><br><span class="line">    -a 显示所有容器，包括已经停止的</span><br><span class="line">    -l 显示 最新的容器</span><br><span class="line">    -q 只显示容器id</span><br><span class="line"></span><br><span class="line">    查看容器信息</span><br><span class="line">    docker inspect [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">    高级用法：</span><br><span class="line">        停止所有容器：docker stop $(docker ps -a -q)</span><br><span class="line">        移除所有容器：docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line">9. 重新启动已经停止的容器</span><br><span class="line">    docker start -i [CONTAINER ID或  NAME]</span><br><span class="line"></span><br><span class="line">10. 停止正在运行的容器</span><br><span class="line">    docker stop [CONTAINER ID或NAMES]</span><br><span class="line">    docker kill [CONTAINER ID或NAMES]   强制停止容器</span><br><span class="line"></span><br><span class="line">11. 删除不需要的容器,删除容器时，容器必须是停止状态,否则会报异常</span><br><span class="line">    docker rm [-v] [CONTAINER ID或NAME]</span><br><span class="line">    -v 删除挂载的数据卷</span><br><span class="line">12. 查看端口映射</span><br><span class="line">    docker port [CONTAINER ID或NAMES]</span><br><span class="line"></span><br><span class="line">13. 设置容器端口映射</span><br><span class="line">    run [-P] [-p]</span><br><span class="line">    -P --publish-all&#x3D;true | false 默认式false</span><br><span class="line">        docker run -P -i -t ubuntu &#x2F;bin&#x2F;bash    将容器内部使用的端口映射到主机上</span><br><span class="line">    -p --publish&#x3D;[]</span><br><span class="line">        containerPort</span><br><span class="line">            docker run -p 80 -i -t ubuntu &#x2F;bin&#x2F;bash                 将容器80端口随机映射到主机上</span><br><span class="line">        hostPort:containerPort</span><br><span class="line">            docker run -p 8080:80 -i -t ubuntu &#x2F;bin&#x2F;bash            将容器80端口映射到主机8080端口上</span><br><span class="line">        ip::containerPort</span><br><span class="line">            docker run -p 0.0.0.0:80 -i -t ubuntu &#x2F;bin&#x2F;bash         将容器80端口映射到主机0.0.0.0上</span><br><span class="line">        ip:hostPort:containerPort</span><br><span class="line">            docker run -p 0.0.0.0:8080:80 -i -t ubuntu &#x2F;bin&#x2F;bash    将容器80端口映射到主机0.0.0.0:8080上</span><br><span class="line"></span><br><span class="line">14. 设置容器的数据卷</span><br><span class="line">    run [-v]</span><br><span class="line">    -v --volume 设置容器数据卷[主机目录:容器目录(绝对路径)]，如果主机目录不存在会自动新建</span><br><span class="line">    设置卷只读权限</span><br><span class="line">        docker run -v 主机目录:容器目录:ro IMAGE [COMMAND] [ARG...]</span><br><span class="line">    设置读写权限</span><br><span class="line">        docker run -v 主机目录:容器目录:rw IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的C/S模式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Remote API调用</span><br><span class="line">    https:&#x2F;&#x2F;docs.docker.com&#x2F;develop&#x2F;sdk&#x2F;examples&#x2F;</span><br><span class="line"></span><br><span class="line">2. 连接模式</span><br><span class="line">    模式一: unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">        例：</span><br><span class="line">            本地sock地址 &#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">            curl --unix-socket &#x2F;var&#x2F;run&#x2F;docker.sock http:&#x2F;v1.24&#x2F;images&#x2F;json</span><br><span class="line">    模式二: tcp:&#x2F;&#x2F;host:port 端口port通常为2375</span><br><span class="line">    模式三: fd:&#x2F;&#x2F;socketfd</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的远程访问</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 要求Docker server和Dokcer client版本一致</span><br><span class="line"></span><br><span class="line">2. 修改Docker守护进程启动选项</span><br><span class="line">    -H  tcp:&#x2F;&#x2F;host:port</span><br><span class="line">        unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket</span><br><span class="line">        fd:&#x2F;&#x2F;* or fd:&#x2F;&#x2F;socketfd</span><br><span class="line">    -H指定Docker的通讯方式</span><br><span class="line">    守护进程默认配置</span><br><span class="line">    -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line"></span><br><span class="line">3. 远程连接</span><br><span class="line">    假设服务器A地址为：10.211.55.5</span><br><span class="line">    服务器A Docker启动配置：-H tcp:&#x2F;&#x2F;0.0.0.0:2375</span><br><span class="line"></span><br><span class="line">    服务器B请求远程api：curl 10.211.55.5:2375 http:&#x2F;v1.24&#x2F;images&#x2F;json</span><br><span class="line"></span><br><span class="line">4. 使用本地Docker client操作远程Docker server</span><br><span class="line">    服务器B</span><br><span class="line">    方式一：</span><br><span class="line">        本地Docker启动选项：-H tcp:&#x2F;&#x2F;10.211.55.5:2375   ip地址为远程服务器地址</span><br><span class="line">    方式二：</span><br><span class="line">        使用Docker环境变量配置调用远程Docker server： export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;10.211.55.5:2375&quot;</span><br><span class="line">    配置完成后就可以像使用本机Docker一样使用远程服务</span><br><span class="line"></span><br><span class="line">5. docker配置远程服务后本地服务不能正常调用</span><br><span class="line">    即服务器A设置为远程服务后，相关的docker命令无法调用，如：docker info 会返回异常</span><br><span class="line">    如果想要开发远程服务同时运行本地服务，可同时调用多次-H配置</span><br><span class="line">    服务器A Docker启动配置：-H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>数据卷容器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建数据卷容器</span><br><span class="line">    方式一：docker run -v path IMAGE [COMMAND] [ARG...]</span><br><span class="line">    方式二：构建容器包含VOLUME指令，即容器本身自带数据卷</span><br><span class="line">    例：</span><br><span class="line">       docker run -it -v &#x2F;dbdata --name dbdata ubuntu</span><br><span class="line"></span><br><span class="line">2. 其它容器通过使用--volumes-from来挂载dbdata容器中的数据卷</span><br><span class="line">    docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">    docker run -it --volumes-from dbdata --name db2 ubuntu</span><br><span class="line">    说明：</span><br><span class="line">        此时，容器db1和db2都挂载同一个数据卷到相同的&#x2F;dbdata目录。三个容器任何一方在该目录下的写入，其他容器都可以看到。</span><br><span class="line">        可以多次使用--volumes-from参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷，即多重挂载。</span><br><span class="line">        使用--volumes-from参数所挂载数据卷的容器自身并不需要保持在运行状态。</span><br><span class="line">    注意：        </span><br><span class="line">        如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器。</span><br><span class="line"></span><br><span class="line">3. 数据卷的备份和还原</span><br><span class="line">    备份：</span><br><span class="line">        docker run --volumes-from [container name需要备份的数据卷容器名称] -v $(pwd):&#x2F;backup --name backup ubuntu tar cvf &#x2F;backup&#x2F;backup.tar [container data valume数据卷容器需要备份的数据卷目录]</span><br><span class="line">    说明：</span><br><span class="line">        首先利用ubuntu镜像创建了一个容器backup。使用--volumes-from参数来让backup容器挂载需要备份的数据卷，使用-v  $(pwd):&#x2F;backup参数来挂载本地的当前目录到backup容器的&#x2F;backup目录。backup容器启动后，使用了tar命令压缩需要备份的数据，并存放在&#x2F;backup&#x2F;backup.tar上(实际就是主机的$(pwd)目录);</span><br><span class="line"></span><br><span class="line">    还原：</span><br><span class="line">        docker run --volumes-from [container name] -v $(pwd):&#x2F;backup --name restore ubuntu tar xvf &#x2F;backup&#x2F;backup.tar [container data volume]</span><br><span class="line">    说明：</span><br><span class="line">        跟备份原理相同</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的启动配置选项</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 启动选项</span><br><span class="line">    参考文档：https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;cli&#x2F;</span><br><span class="line">    docker -d [OPTOINS]</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="10">
<li><p>容器的网络连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>容器跨主机的网络连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3 基础</title>
    <url>/2020/09/12/Python3/Python3%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Python3-基础"><a href="#Python3-基础" class="headerlink" title="Python3 基础"></a>Python3 基础</h1><h5 id="已学习的包"><a href="#已学习的包" class="headerlink" title="已学习的包"></a>已学习的包</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable <span class="comment"># 可迭代</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator <span class="comment"># 迭代器</span></span><br><span class="line"><span class="keyword">from</span> types <span class="comment"># 封装了内置类型判断变量</span></span><br><span class="line"><span class="keyword">import</span> functools <span class="comment"># reduce wraps等</span></span><br><span class="line"><span class="keyword">import</span> re <span class="comment"># 文字处理：正则 findall sub search match</span></span><br><span class="line"><span class="keyword">import</span> time <span class="comment"># 日期包</span></span><br><span class="line"><span class="keyword">import</span> datetime <span class="comment"># 日期包</span></span><br><span class="line"><span class="keyword">import</span> math <span class="comment"># 数字工具</span></span><br><span class="line"><span class="keyword">import</span> random <span class="comment"># 随机数工具</span></span><br><span class="line"><span class="keyword">import</span> pathlib <span class="comment"># 文件操作</span></span><br><span class="line"><span class="keyword">import</span> os.path <span class="comment"># 目录访问</span></span><br><span class="line"><span class="keyword">import</span> tarfile <span class="comment"># 数据压缩和归档</span></span><br><span class="line"><span class="keyword">import</span> threading <span class="comment"># 多线程</span></span><br><span class="line"><span class="keyword">import</span> queue <span class="comment"># 生产者消费者队列</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 内置网络请求，推荐使用第三方requests库</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="comment"># 标记语言处理工具，推荐使用第三方库：xmltodict BeautifulSoup等第三方库</span></span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"><span class="keyword">import</span> xml</span><br></pre></td></tr></table></figure>

<h5 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">abs</span>(-<span class="number">45</span>) <span class="comment"># 获取数字的绝对值</span></span><br><span class="line"><span class="built_in">all</span>([<span class="number">0</span>,<span class="number">1</span>]) <span class="comment"># 判断给定的参数中的所有元素是否都为TRUE。元素除了是 0、空、None、False 外都算 True；空元组、空列表返回值为True</span></span><br><span class="line"><span class="built_in">any</span>([<span class="number">0</span>,<span class="number">1</span>]) <span class="comment"># 判断是否有元素为TRUE</span></span><br><span class="line"><span class="built_in">bin</span>(<span class="number">10</span>) <span class="comment"># 返回二进制数0b1010</span></span><br><span class="line"><span class="built_in">oct</span>() <span class="comment"># 将一个整数转换成八进制字符串。</span></span><br><span class="line"><span class="built_in">int</span>() <span class="comment"># 用于将一个字符串或数字转换为整型。</span></span><br><span class="line"><span class="built_in">hex</span>() <span class="comment"># 用于将一个整数转换为十六进制数</span></span><br><span class="line"><span class="built_in">round</span>() <span class="comment"># 返回浮点数x的四舍五入值（精度不能做保证）</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 返回x的y次方的值。</span></span><br><span class="line"><span class="built_in">bool</span>() <span class="comment"># 函数用于将给定参数转换为布尔类型</span></span><br><span class="line"><span class="built_in">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 对参数进行求和计算。</span></span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">&quot;abcd&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="comment"># 返回一个新字节数组</span></span><br><span class="line"><span class="built_in">callable</span>() <span class="comment"># 函数用于检查一个对象是否可调用的。对于函数、方法、lambda函式、类以及实现了 __call__ 方法的类实例, 它都返回 True</span></span><br><span class="line"><span class="built_in">chr</span>(<span class="number">98</span>) <span class="comment"># 函数用一个范围在range(256)内（即0～255）的整数作参数，返回一个对应的ASCII数值。</span></span><br><span class="line"><span class="built_in">dict</span>() <span class="comment"># 函数用来将元组/列表转换为字典格式。</span></span><br><span class="line"><span class="built_in">dir</span>() <span class="comment"># 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表</span></span><br><span class="line"><span class="built_in">enumerate</span>() <span class="comment"># 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;3 * 2&#x27;</span>) <span class="comment"># 函数用来执行一个字符串表达式，并返回表达式的值。</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;print(&#x27;Hello World&#x27;)&quot;</span>) <span class="comment"># 执行储存在字符串或文件中的Python语句，相比于eval，exec可以执行更复杂的Python代码。</span></span><br><span class="line"><span class="built_in">float</span>() <span class="comment"># 函数用于将整数和字符串转换成浮点数。</span></span><br><span class="line"><span class="built_in">frozenset</span>() <span class="comment"># 返回一个冻结的集合（一个无序的不重复元素序列），冻结后集合不能再添加或删除任何元素。</span></span><br><span class="line"><span class="built_in">hasattr</span>() <span class="comment"># 用于判断对象是否包含对应的属性。如果对象有该属性返回 True，否则返回 False。</span></span><br><span class="line"><span class="built_in">getattr</span>() <span class="comment"># 用于获取对象对应的属性</span></span><br><span class="line"><span class="built_in">hash</span>() <span class="comment"># 用于获取一个对象（数字或者字符串等）的哈希值</span></span><br><span class="line"><span class="built_in">id</span>()<span class="comment"># 用于获取对象的内存地址。</span></span><br><span class="line"><span class="built_in">input</span>() <span class="comment"># 接受一个标准输入数据，返回为 string 类型</span></span><br><span class="line"><span class="built_in">iter</span>() <span class="comment"># 函数用来生成迭代器</span></span><br><span class="line"><span class="built_in">next</span>() <span class="comment"># 返回迭代器的下一个项目。</span></span><br><span class="line"><span class="built_in">len</span>() <span class="comment"># 返回对象（字符、列表、元组等）长度或元素个数。</span></span><br><span class="line"><span class="built_in">list</span>() <span class="comment"># 方法用于将元组转换为列表。</span></span><br><span class="line"><span class="built_in">max</span>() <span class="comment"># 返回给定参数的最大值，参数可以为序列。</span></span><br><span class="line"><span class="built_in">min</span>() <span class="comment"># 函数返回给定参数的最小值，参数可以为序列。</span></span><br><span class="line"><span class="built_in">repr</span>() <span class="comment"># 函数将对象转化为供解释器读取的形式。返回一个对象的 string 格式。</span></span><br></pre></td></tr></table></figure>



<h5 id="自动关闭资源-上下文管理器"><a href="#自动关闭资源-上下文管理器" class="headerlink" title="自动关闭资源-上下文管理器"></a>自动关闭资源-上下文管理器</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">white <span class="built_in">open</span>(<span class="string">&quot;file name&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure>

<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><blockquote>
<p>内部函数调用外部函数变量</p>
<p>注意一：如果内部函数没有调用外部函数变量（包含外部函数局部变量），则无法构成闭包，没有__closure__属性</p>
<p>注意二：如果内部函数局部变量有相同的变量名被赋值，则认为是新建的局部变量，并没有调用外部变量，同样也无法构成闭包。可以通过nonlocal声明该变量为非局部变量解决这个问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out_method</span>(<span class="params">a</span>):</span></span><br><span class="line">    b = <span class="number">5</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner_method</span>(<span class="params">x</span>):</span></span><br><span class="line">		<span class="keyword">return</span> a*x + b</span><br><span class="line">	<span class="keyword">return</span> inner_method</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">a</span>):</span></span><br><span class="line">    b = <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:a*x+b</span><br><span class="line"></span><br><span class="line">m = out_method()</span><br><span class="line"><span class="built_in">print</span>(m(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># __closure__ 闭包对象属性，如果inner_method内没有使用a、b等外部变量，则该属性为None</span></span><br><span class="line"><span class="built_in">print</span>(m.__closure__)</span><br><span class="line"><span class="built_in">print</span>(m.__closure__[<span class="number">0</span>].cell_contents) <span class="comment"># 对应a值，如果inner_method没有引用a则没有该值</span></span><br><span class="line"><span class="built_in">print</span>(m.__closure__[<span class="number">1</span>].cell_contents) <span class="comment"># 对应b值，如果inner_method没有引用b则没有该值</span></span><br><span class="line"><span class="built_in">print</span>(m.__closure__[...].cell_contents)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部函数局部变量赋值举例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out_method</span>():</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner_method</span>():</span></span><br><span class="line">        <span class="comment"># a被python认为是局部变量，并没有引用外部变量a，所以也不构成闭包</span></span><br><span class="line">		<span class="comment"># nonlocal a 可通过该方式声明a变量为非局部变量，使其形成闭包</span></span><br><span class="line">        a = <span class="number">10</span></span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	<span class="keyword">return</span> inner_method</span><br></pre></td></tr></table></figure>

<h5 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h5><ol>
<li><p>切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">start: 开始位置，如果为负数则从末尾起算，空则从最左侧起算</span></span><br><span class="line"><span class="string">end:结束位置，如果为负数则从末尾起算，空则从最右侧结束</span></span><br><span class="line"><span class="string">step:间隔</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">list</span>[start:end:step]</span><br></pre></td></tr></table></figure></li>
<li><p>迭代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">所有的列表 map set都可以通过for...in...的格式迭代</span></span><br><span class="line"><span class="string">判断是否可迭代：</span></span><br><span class="line"><span class="string">from collections import Iterable</span></span><br><span class="line"><span class="string">print(isinstance(list, Iterable))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">列表:</span></span><br><span class="line"><span class="string">for i in list：</span></span><br><span class="line"><span class="string">如需获取索引可通过：for i,v in enumerate(list)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">map:</span></span><br><span class="line"><span class="string">默认map迭代的是key，需要同时迭代key和value：map kv: for k,v in map.items():</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set:</span></span><br><span class="line"><span class="string">for i in set:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多值遍历：</span></span><br><span class="line"><span class="string"> for x, y in [(1, 1), (2, 4), (3, 9)]:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>列表生成式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">格式：[表达式 生成器 条件]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 举例：</span></span><br><span class="line"><span class="built_in">list</span> = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 嵌套：</span></span><br><span class="line"><span class="built_in">list</span> = [m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line"><span class="comment"># dict：</span></span><br><span class="line"><span class="built_in">list</span> = [k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line"><span class="comment"># if else:</span></span><br><span class="line"><span class="built_in">list</span> = [x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"><span class="comment"># 生成 dict：</span></span><br><span class="line">dict1 = &#123;i * i: i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生成器</p>
<blockquote>
<p>生成器可以延迟生成数据，可有效防止一次性创建过多数据造成的内存压力</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">判断是否是生成器：</span></span><br><span class="line"><span class="string">from types import GeneratorType</span></span><br><span class="line"><span class="string">print(isinstance(gene, GeneratorType))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">方式一 生成器：</span></span><br><span class="line"><span class="string">将列表生成式的[]更改为(),如：[x for x in range(0, 10)] -&gt; (x for x in range(0, 10))</span></span><br><span class="line"><span class="string">g = (x for x in range(0, 10))</span></span><br><span class="line"><span class="string">即可next(g) 或 for i in g:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">方式二 生成器函数：</span></span><br><span class="line"><span class="string">def frange(start, end, step):</span></span><br><span class="line"><span class="string">    x = start</span></span><br><span class="line"><span class="string">    while x &lt; end:</span></span><br><span class="line"><span class="string">        yield x		# 会阻塞在此，直到外部消费了x值，才继续下一步</span></span><br><span class="line"><span class="string">        x += step</span></span><br><span class="line"><span class="string">f = frange(0, 10, 0.5)</span></span><br><span class="line"><span class="string">即可next(g) 或 for i in f:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">方式三 生成器类</span></span><br><span class="line"><span class="string">class GeneratorTest():</span></span><br><span class="line"><span class="string">    def __init__(self):</span></span><br><span class="line"><span class="string">        self.i = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __iter__(self):</span></span><br><span class="line"><span class="string">        return self # 因为自身就是生成器，所以返回self</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __next__(self):	# 允许next形成生成器</span></span><br><span class="line"><span class="string">        if self.i &gt;= 5:</span></span><br><span class="line"><span class="string">            raise StopIteration()</span></span><br><span class="line"><span class="string">        self.i += 1</span></span><br><span class="line"><span class="string">        return self.i</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">凡是可作用于for循环的对象都是Iterable类型；</span></span><br><span class="line"><span class="string">凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</span></span><br><span class="line"><span class="string">集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无参数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="comment"># 使用 @函数名 声明函数</span></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">相当于：</span></span><br><span class="line"><span class="string">start = log(start)</span></span><br><span class="line"><span class="string">start() 该start实际上为wrapper函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="comment">#带参数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">tag</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s call %s&quot;</span> % (tag, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"><span class="comment"># 使用 @函数名(args) 声明函数</span></span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&quot;描述&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">相当于：</span></span><br><span class="line"><span class="string">start = log(&quot;描述&quot;)(start)</span></span><br><span class="line"><span class="string">start() 该start实际上为wrapper函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">由于函数对象有一个__name__属性，可以拿到函数的名字:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>start.__name__</span></span><br><span class="line"><span class="string">&#x27;start&#x27;</span></span><br><span class="line"><span class="string">经过上面装饰器装饰后：</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>start.__name__</span></span><br><span class="line"><span class="string">&#x27;wrapper&#x27;</span></span><br><span class="line"><span class="string">这样会造成一些需要通过函数名判断信息的程序出错</span></span><br><span class="line"><span class="string">不过也不需要编写wrapper.__name__ = func.__name__这样的代码</span></span><br><span class="line"><span class="string">通过functools.wraps装饰wrapper函数即可</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<h5 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h5><blockquote>
<p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如有大量的字符串需要转换成8进制数值，每次都编写base=8过于繁琐</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 可通过偏函数使某个参数携带指定的默认值</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 相当于执行 int(&#x27;12345&#x27;, base=8)</span></span><br><span class="line">int2(<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">max2 = functools.partial(<span class="built_in">max</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 相当与执行max(10, 5, 6, 7)</span></span><br><span class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动实现协程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注意到consumer函数是一个generator，把一个consumer传入produce后：</span></span><br><span class="line"><span class="string">1. 首先调用c.send(None)启动生成器；</span></span><br><span class="line"><span class="string">2. 然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</span></span><br><span class="line"><span class="string">3. consumer通过yield拿到消息，处理，又通过yield把结果传回；</span></span><br><span class="line"><span class="string">4. produce拿到consumer处理的结果，继续生产下一条消息；</span></span><br><span class="line"><span class="string">5. produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3.4+ 使用标准库asyncio实现</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say hello!&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say hello again!&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># loop.run_until_complete(hello()) # 执行单个任务</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(&#123;hello(), hello()&#125;)) <span class="comment"># 执行多个任务</span></span><br><span class="line">loop.close() <span class="comment"># 任务执行完后直接结束</span></span><br><span class="line"><span class="comment"># loop.run_forever() # 任务执行完后保持运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3.5+ 新增简化版协程声明async和await</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">	r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hello again!&quot;</span>)</span><br><span class="line"><span class="comment"># 将@asyncio.coroutine换成async，将yield from换成await即可</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    r = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello again!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">class 类名(父类):</span></span><br><span class="line"><span class="string">	name = &#x27;&#x27; # 类变量，允许外部通过 类名.变量名 。相当于java的类静态变量</span></span><br><span class="line"><span class="string">	def __init__(self, arg): # 构造函数，首个参数必须为self</span></span><br><span class="line"><span class="string">		self.arg = arg # 赋值给实例变量arg，无需像name一样声明成员变量</span></span><br><span class="line"><span class="string">		pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	def 函数名(self): # 自定义函数，首个参数必须为self</span></span><br><span class="line"><span class="string">		print(self.name) # 使用类变量</span></span><br><span class="line"><span class="string">		print(类名.name) # 使用类变量</span></span><br><span class="line"><span class="string">		print(self.__class__.name) # 使用类变量</span></span><br><span class="line"><span class="string">		print(self.arg) # 使用实例变量</span></span><br><span class="line"><span class="string">		# 通过 self.变量名 的方式优先查找实例变量，如果实例变量空则查找类变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	@classmethod</span></span><br><span class="line"><span class="string">    def 函数名(cls): # 类函数</span></span><br><span class="line"><span class="string">   		print(cls.name)</span></span><br><span class="line"><span class="string">   		print(Student.name)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   	@staticmethod</span></span><br><span class="line"><span class="string">   	def 函数名(): # 静态函数</span></span><br><span class="line"><span class="string">   		print(Student.name)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(实例名.__dict__) # 打印实例所有的实例变量</span></span><br><span class="line"><span class="string">print(类名.__dict__) # 打印所有的类变量、内置函数和自定义函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注意一：在变量命名和函数命名在前面增加双下划线 __ ，则相当于声明为私有</span></span><br><span class="line"><span class="string">注意二：实例.__变量名 = xxx， 相对于给实例新声明一个公开变量，并没有为私有变量赋值</span></span><br><span class="line"><span class="string">stu = Student()# 内部含有私有变量__name</span></span><br><span class="line"><span class="string">stu2 = Student()</span></span><br><span class="line"><span class="string">stu.__name = &quot;xxx&quot;</span></span><br><span class="line"><span class="string">print(stu.__name) # 打印新声明的公开变量</span></span><br><span class="line"><span class="string">print(stu2.__name) # 报错没有该变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意三：私有变量和私有函数的私有原理为系统发现双下划线时重命名了变量名和函数名：_类名__变量名 _类名__函数名，外部通过重命名后的方式也是可以继续调用的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">限制类可声明得变量</span></span><br><span class="line"><span class="string">class 类名(父类):</span></span><br><span class="line"><span class="string">    __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;) # 用tuple定义允许绑定的属性名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意一：仅对当前类实例起作用，对继承的子类是不起作用</span></span><br><span class="line"><span class="string">注意二：除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">动态生成类</span></span><br><span class="line"><span class="string">def fn():</span></span><br><span class="line"><span class="string">	print(&quot;hello&quot;)</span></span><br><span class="line"><span class="string">参数一：class的名称</span></span><br><span class="line"><span class="string">参数二：继承的父类集合，tuple类型</span></span><br><span class="line"><span class="string">参数三：声明变量或函数</span></span><br><span class="line"><span class="string">Hello = type(&#x27;Hello&#x27;, (object,), dict(hello=fn))</span></span><br><span class="line"><span class="string">h = Hello()</span></span><br><span class="line"><span class="string">h.hello()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">与以下类声明效果一致，实际Python解释器也是扫面以下语法定义，然后通过type函数创建类</span></span><br><span class="line"><span class="string">class Hello(object):</span></span><br><span class="line"><span class="string">	def fn(self):</span></span><br><span class="line"><span class="string">		print(&quot;hello&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">元类（用于扩展类信息,在编写orm等框架相当有用）</span></span><br><span class="line"><span class="string">class MyMetaclass(type):</span></span><br><span class="line"><span class="string">	# args[0] = 类名</span></span><br><span class="line"><span class="string">	# args[1] = 父类tuple</span></span><br><span class="line"><span class="string">	# args[2] = 所含有的字段和函数dict</span></span><br><span class="line"><span class="string">    def __new__(cls, *args, **kwargs):</span></span><br><span class="line"><span class="string">        args[2][&#x27;add&#x27;] = lambda self, value: self.append(value) #动态添加函数</span></span><br><span class="line"><span class="string">        return type.__new__(cls, name, bases, attrs)</span></span><br><span class="line"><span class="string"># 使用</span></span><br><span class="line"><span class="string">class MyList(list, metaclass=ListMetaclass):</span></span><br><span class="line"><span class="string">	pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">上下文类</span></span><br><span class="line"><span class="string">class Test():</span></span><br><span class="line"><span class="string">    def __enter__(self):</span></span><br><span class="line"><span class="string">        # 初始化逻辑</span></span><br><span class="line"><span class="string">        return self</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __exit__(self, exc_type, exc_val, exc_tb):</span></span><br><span class="line"><span class="string">        # 退出结束逻辑</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def fun(self):</span></span><br><span class="line"><span class="string">        pass</span></span><br><span class="line"><span class="string"># 使用</span></span><br><span class="line"><span class="string">with Test() as t:</span></span><br><span class="line"><span class="string">    t.fun()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">高级变种上下文：</span></span><br><span class="line"><span class="string">from contextlib import contextmanager</span></span><br><span class="line"><span class="string">class Test():</span></span><br><span class="line"><span class="string">    def fun(self):</span></span><br><span class="line"><span class="string">        pass</span></span><br><span class="line"><span class="string">@contextmanager</span></span><br><span class="line"><span class="string">def my_Test():</span></span><br><span class="line"><span class="string">     # 初始化逻辑</span></span><br><span class="line"><span class="string">    yield Test()</span></span><br><span class="line"><span class="string">    # 退出结束逻辑</span></span><br><span class="line"><span class="string">with my_Test() as t:</span></span><br><span class="line"><span class="string">    t.fun()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">类函数属性化：函数可以像属性一样调用</span></span><br><span class="line"><span class="string">class Test():</span></span><br><span class="line"><span class="string">    @property</span></span><br><span class="line"><span class="string">    def go(self):</span></span><br><span class="line"><span class="string">        return self.name</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @go.setter</span></span><br><span class="line"><span class="string">    def go(self,name):</span></span><br><span class="line"><span class="string">        self.name = name</span></span><br><span class="line"><span class="string">t = Test()</span></span><br><span class="line"><span class="string">t.go = &quot;aa&quot;</span></span><br><span class="line"><span class="string">print(t.go)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">常用内置函数</span></span><br><span class="line"><span class="string">__str__ 调用打印时的内容</span></span><br><span class="line"><span class="string">__repr__ 程序打印时显示的内容</span></span><br><span class="line"><span class="string">__iter__ __next__ 使对象变成可迭代</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__getitem__</span></span><br><span class="line"><span class="string">使实例能够通过 实例[i]的方式获取值</span></span><br><span class="line"><span class="string">如果要实现切片功能需要做如下操作：</span></span><br><span class="line"><span class="string">def __getitem__(self, n):</span></span><br><span class="line"><span class="string">	 if isinstance(n, int): # n是索引</span></span><br><span class="line"><span class="string">	 	# todo</span></span><br><span class="line"><span class="string">	 	return data</span></span><br><span class="line"><span class="string">	 if isinstance(n, slice): # n是切片</span></span><br><span class="line"><span class="string">	  	start = n.start</span></span><br><span class="line"><span class="string">	  	stop = n.stop</span></span><br><span class="line"><span class="string">	  	step = n.step</span></span><br><span class="line"><span class="string">	  	# todo</span></span><br><span class="line"><span class="string">	  	return [...]</span></span><br><span class="line"><span class="string">还有与之对应的__setitem__和__delitem__的方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__getattr__ 当实例调用一个没有声明的变量或方法时，会尝试调用该方法</span></span><br><span class="line"><span class="string">__setattr__ 为实例赋值会调用该方法</span></span><br><span class="line"><span class="string">__call__ 使实例成为callable类型，实例() 的方式调用，通过callable()判断是否是callable类型</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum,IntEnum,unique</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自己的枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params">Enum</span>):</span></span><br><span class="line">    VALUE_1 = <span class="number">1</span></span><br><span class="line">    VALUE_ALIAS = <span class="number">1</span> <span class="comment">#枚举别名 VALUE_1 == VALUE_ALIAS</span></span><br><span class="line">    VALUE_2 = <span class="string">&#x27;A&#x27;</span> <span class="comment"># 字符串</span></span><br><span class="line">    VALUE_3 = <span class="number">1</span> <span class="comment"># 值可重复</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params">IntEnum</span>):</span> <span class="comment"># 继承自IntEnum只能使用int值</span></span><br><span class="line">    VALUE_1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@unique </span><span class="comment"># 声明值不可重复</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params">Enum</span>):</span></span><br><span class="line">    VALUE_1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用: 类名.VALUE_1</span></span><br><span class="line"><span class="string">枚举名: 类名.VALUE_1.name</span></span><br><span class="line"><span class="string">枚举值: 类名.VALUE_1.value</span></span><br><span class="line"><span class="string">遍历枚举: for i in 类名</span></span><br><span class="line"><span class="string">遍历枚举名: for i in 类名.__members__</span></span><br><span class="line"><span class="string">常规值转换成枚举值: 类名(1) -&gt; 类名.VALUE_1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
