<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/13/hello-world/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><blockquote>
<p>Welcome to my blog.</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>正则</title>
    <url>/2020/09/19/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除“\n”和”\r”之外的任何单个字符。要匹配包括“\n”和”\r”在内的任何字符，请使用像“[\s\S]”的模式。</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
<td></td>
</tr>
<tr>
<td>$</td>
<td>匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，也能匹配“zo”以及“zoo”。</em>等价于{0,}。</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。</td>
<td></td>
</tr>
<tr>
<td>{n} {n,}{n,m}</td>
<td>匹配确定的<em>n</em>次 / 至少匹配<em>n</em>次 / 最少匹配<em>n</em>次且最多匹配<em>m</em>次</td>
<td></td>
</tr>
<tr>
<td>[]</td>
<td>字符集合</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>将两个匹配条件进行逻辑“或”（or）运算</td>
<td></td>
</tr>
<tr>
<td>\d \D</td>
<td>匹配一个数字字符。等价于[0-9] / 匹配一个非数字字符。等价于[^0-9]</td>
<td></td>
</tr>
<tr>
<td>\s \S</td>
<td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。/ 匹配任何可见字符。等价于[^\f\n\r\t\v]。</td>
<td></td>
</tr>
<tr>
<td>\w \W</td>
<td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_] / 匹配任何非单词字符,等价于“[^A-Za-z0-9]”</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>组</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 中的线程模型</title>
    <url>/2020/11/10/Android/Android%20%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Android-中的线程模型"><a href="#Android-中的线程模型" class="headerlink" title="Android 中的线程模型"></a>Android 中的线程模型</h1><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h5 id="线程调度原理"><a href="#线程调度原理" class="headerlink" title="线程调度原理"></a>线程调度原理</h5><ul>
<li>任一时刻，一个 <code>CPU</code> 核心只有一个线程处于运行状态</li>
<li>多线程并发，轮流获取 <code>CPU</code> 使用权</li>
</ul>
<h5 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h5><ul>
<li>分时调度模型：轮流获取、均分 <code>CPU</code></li>
<li>抢占式调度模型：谁抢到谁使用，优先级高的线程抢到的概率更高</li>
</ul>
<h3 id="Android-线程调度"><a href="#Android-线程调度" class="headerlink" title="Android 线程调度"></a>Android 线程调度</h3><p>采用抢占式调度模型</p>
<ol>
<li><p><code>nice</code> 值，【注意】nice值不是优先级</p>
<p>Process 中定义，值越小优先级越高，默认时 <code>THREAD_PRIORITY_DEFAUT = 0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Process.setThreadPriority()</span><br></pre></td></tr></table></figure></li>
<li><p><code>priority</code>优先级</p>
<p>线程优先级，值越大优先级越高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Therad().setPriority()</span><br></pre></td></tr></table></figure></li>
<li><p><code>cgroup</code></p>
<p>更严格的群组调度策略，分前台 <code>group</code> 和后台 <code>group</code>，保证前台线程可以获取更多的 <code>CPU</code> 时间片</p>
</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>线程过多会导致 <code>CPU</code> 频繁切换，降低线程运行效率，还有可能出现线程饥饿（长时间没有得到执行）</li>
<li>优先级具有继承性</li>
<li>正确认识任务重要性决定优先级</li>
<li>线程必须命名，以定位归属</li>
<li>注意区分 <code>IO</code> 密集型和 <code>CPU</code> 密集型任务</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2020/11/14/Git/Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h5 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h5><p><strong>分支：</strong>一个指向特定提交记录的<strong>引用</strong></p>
<p><strong>指针：</strong>当前操作位置的<strong>引用</strong></p>
<p><strong>本地指针：</strong>我们能操作位置的引用</p>
<img src="/2020/11/14/Git/Git/仓库说明.png">



<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><ol>
<li><p>拉取分支</p>
<p><code>git clone [url] &lt;目录名&gt;</code></p>
</li>
<li><p>推送变更到远程仓库</p>
<p><code>git push</code></p>
<p><img src="/2020/11/14/Git/Git/push.png"></p>
<p>注意：如上图所示，将 4 推送到仓库需要 <code>remote</code> 仓库的 <code>HEAD</code> 指向非 <code>master</code> 分支或指向 <code>hash</code></p>
</li>
<li><p>将远端镜像更新到本地【注：本地head指向并没有发生改变】</p>
<p><code>git fetch</code></p>
<p><img src="/2020/11/14/Git/Git/fetch.png"></p>
<p>需要手动合并分支：<code>git merge origin/[分支名]</code></p>
</li>
<li><p>获取变更并合并【注：本地head会指向最新变更】</p>
<p><code>git pull</code></p>
<p>相当于：<code>git fetch</code>和<code>git merge origin/[分支名]</code></p>
</li>
<li><p>分支</p>
<p>创建分支：<code>git branch [分支名]</code></p>
<p>切换分支：<code>git checkout [分支名]</code></p>
<p><code>HEAD</code>指向提交记录：<code>git checkout [hash]/--detach</code>，该操作会直接让<code>HEAD</code>直接指向<code>hash</code></p>
<p>创建分支并切换：<code>git checkout &lt;远程分支名&gt; -b [分支名]</code></p>
<p>删除分支：<code>git branch -d [分支名]</code></p>
<p>切换远程分支：<code>git checkout [远程分支名]</code>，注意该切换会直接将<code>HEAD指针</code>指向<code>hash</code>，如下图</p>
<p><img src="/2020/11/14/Git/Git/checkout.png"></p>
</li>
<li><p>暂存区</p>
<p>添加到暂存区：<code>git add [文件路径]/[.]</code></p>
<p>交互式add，允许提交文件内容的一部分：<code>git add -i</code></p>
<p>移除暂存区：<code>git restore --staged [文件路径]/[.]</code></p>
<p>还原文件：<code>git restore [文件路径]</code> 或 <code>git checkout [文件路径]</code></p>
</li>
<li><p>提交变更</p>
<p><code>git commit -m &quot;描述&quot;</code></p>
<p>替换最新变更：<code>git commit --amend</code></p>
<p><img src="/2020/11/14/Git/Git/amend.png"></p>
<p>通过 <code>--amend</code> 命令将 <code>master</code> 引用指向新的提交，上图为 <code>4</code> 变更为 <code>4&#39;</code></p>
<p>当 <code>--amend</code> 命令触发 <code>COMMIT_EDITMSG</code> 编辑时，可通过 <code>ESC</code> 推出编辑模式，然后按两次大写 <code>Z</code>退出</p>
</li>
<li><p>合并分支</p>
<p><code>git merge [分支名]</code></p>
<p>当merge发生冲突并解决时：<code>git add .</code> 然后 <code>git merge --continue</code></p>
<p>非<code>Fast-forward</code>合并：<code>git merge [分支名] --no-ff</code></p>
<p><img src="/2020/11/14/Git/Git/merge.png"></p>
</li>
<li><p>reset 引用回退</p>
<p><code>git reset &lt;mode&gt; [hash]</code></p>
<p>mode 类型有：</p>
<ul>
<li>–soft：使分支和<code>HEAD</code>回退到指定<code>commit</code>并保留所有变更在<strong>非暂存区</strong></li>
<li>–mixed 默认模式：使分支和<code>HEAD</code>回退到指定<code>commit</code>并保留所有变更在<strong>暂存区</strong></li>
<li>–hard：使分支和<code>HEAD</code>回退到指定<code>commit</code>并移除所有变更</li>
</ul>
<p>注意：可以通过<code>reset</code>回退到<code>git reflog</code>里的任意记录</p>
</li>
<li><p>rebase 调整提交过程</p>
<p><code>git rebase [分支名]/[hash]</code></p>
<p><img src="/2020/11/14/Git/Git/rebase.png"></p>
<p>如果想将branch的提交记录变更为：<code>1 - 2 - 3 - a - 4 - 5</code> 的形式</p>
<p>通过 <code>git rebase master</code> 进行调整</p>
<p>当 <code>rebase</code> 发生冲突并解决时【注：再次冲突重复冲突操作即可】</p>
<p><code>git add .</code></p>
<p><code>git rebase --continue</code></p>
<p>修改提交历史，即代码有没有冲突，都要求一步一步编辑历史，如：<code>3 - 4 - 5</code></p>
<p><code>git rebase -i [分支名]/[hash]</code></p>
<p>会要求对每一步都进行类冲突处理</p>
</li>
<li><p>revert 反向操作，会全部还原成指定hash的前一个提交的状态</p>
<p><code>git revert [分支名]/[hash]</code></p>
</li>
<li><p>获取其它分支的提交内容</p>
<p><code>git cherry-pick [hash1、hash2、hash3]</code></p>
</li>
<li><p>查看差异</p>
<p><code>git diff</code>：查看未缓存的改动</p>
<p><code>git diff --staged</code>：查看缓存区与 <code>HEAD</code> 的改动</p>
<p><code>git dif [hash1] [hash2]</code>：对比两次提交的差异</p>
</li>
<li><p>查看日志</p>
<p><code>git log &lt;--oneline&gt; &lt;--pretty=oneline&gt; &lt;--graph&gt; &lt;--all&gt;</code></p>
</li>
<li><p>查看状态</p>
<p><code>git status</code></p>
</li>
<li><p>查看提交的内容</p>
<p><code>git show [hash]</code></p>
</li>
<li><p>创建 tag</p>
<p><code>git tag [tag名称] &lt;-a&gt;</code></p>
<p>-a 选项为增加描述</p>
</li>
<li><p>查看引用历史</p>
<p><code>git reflog</code></p>
</li>
</ol>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ol>
<li><p>查看配置</p>
<p><code>git config --list</code></p>
</li>
<li><p>查看用户名</p>
<p><code>git config user.name</code></p>
</li>
<li><p>查看邮箱</p>
<p><code>git config user.email</code></p>
</li>
<li><p>全局配置用户名</p>
<p><code>git config --global user.name &quot;name&quot;</code></p>
</li>
<li><p>全局配置邮箱</p>
<p><code>git config --global user.email &quot;eamil@gmail.com&quot;</code></p>
</li>
</ol>
<h5 id="扩展-得练习并验证"><a href="#扩展-得练习并验证" class="headerlink" title="扩展(得练习并验证)"></a>扩展(得练习并验证)</h5><ol>
<li><p>给本地仓库添加远程仓库【注：该远程仓库可以是其它本地仓库或其它电脑的仓库】</p>
<p><code>git remote add &lt;给个远端仓库名&gt; &lt;名称&gt;@&lt;ip&gt;:&lt;远端仓库目录&gt;</code></p>
<p><code>git push &lt;远端仓库名&gt; &lt;分支&gt;:&lt;分支&gt;</code>：得验证分支到底那个是创建，那个是本地</p>
</li>
</ol>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>提交完发现写错了？</p>
<ol>
<li>第一种：刚提交完，发现有错<ul>
<li><code>git commit --amend</code></li>
</ul>
</li>
<li>第二种：非最新提交，发现有错<ul>
<li><code>git rebase [hash]</code></li>
</ul>
</li>
<li>第三种：已经push到远程仓库，发现有错<ul>
<li><code>git revert [hash]</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术卷一基础知识-笔记</title>
    <url>/2020/09/13/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ol>
<li>已经清楚或能够估计出元素容量，可以在添加元素前调用【ensureCapacity(100)】函数，或在构造函数中传入【new ArrayList&lt;&gt;(100)】</li>
<li>添加完元素后明确不再添加任何元素时，可调用【trimToSize()】，以释放多余空间</li>
</ol>
<h5 id="带资源try语句"><a href="#带资源try语句" class="headerlink" title="带资源try语句"></a>带资源try语句</h5><p>普通try-catch方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//open a resource</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// catch error</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//close the resource</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缺点：</span></span><br><span class="line"><span class="comment">//     当try块发生非catch能处理的异常，如果此时finally块也发生异常，那么会丢失原始异常，转而抛出finally产生的异常</span></span><br><span class="line"><span class="comment">//     这样会有一个问题，如果需要将try块的异常向外抛出，需要对try块异常通过变量存起来，并在finally中判断是否需要向外抛出</span></span><br></pre></td></tr></table></figure>

<p>带资源try方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Recource res = ...) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     资源需要属于AutoCloseable的子接口的子类才能使用这种方式，其中Closeable接口为AutoCloseable的子接口</span></span><br><span class="line"><span class="comment">//     try块正常退出或者存在一个异常时，都会自动调用res.close()方法，同时还可以指定多个资源</span></span><br><span class="line"><span class="keyword">try</span>(InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     上面提到，原始try-catch方式当try抛出异常，finally块也抛出异常，会产生一个难题</span></span><br><span class="line"><span class="comment">//     带资源的try方式能很好的处理这种情况，原来的异常会重新抛出，close产生的异常会被try异常通过addSuppressed添加进去，该过程称为“抑制”</span></span><br><span class="line"><span class="comment">//     如果对close产生的异常感兴趣，可以调用getSuppressed获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>(Recource res = ...) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// catch error</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// do finally block</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">//     带资源的try语句同样也可以添加catch子句和finally子句</span></span><br><span class="line"><span class="comment">//     执行顺序为 try块 -&gt; close -&gt; catch块(如果有异常的话) -&gt; finally块</span></span><br></pre></td></tr></table></figure>



<h5 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以获取所有线程的堆栈轨迹</span></span><br><span class="line">Thread.getAllStackTraces();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印堆栈轨迹：内部实际是new Exception(&quot;Stack trace&quot;).printStackTrace();</span></span><br><span class="line">Thread.dumpStack();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常捕获处理顺序：线程 -&gt; 线程对象 -&gt; 未捕获异常Handler</span></span><br><span class="line"><span class="comment">// 设置未捕获异常处理器，用于捕获线程未捕获的异常</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个“抑制”异常，如在带资源try中会出现</span></span><br><span class="line">addSuppressed(Throwable t)</span><br><span class="line"><span class="comment">// 将该异常对象设置为“原因”</span></span><br><span class="line">initCause(Throwable t)</span><br><span class="line"><span class="comment">// 例：</span></span><br><span class="line"><span class="keyword">try</span>&#123;&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    Exception r = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    r.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Java日志"><a href="#Java日志" class="headerlink" title="Java日志"></a>Java日志</h5><p>全局日志记录器：<br><code>Logger.getGlobal().info(&quot;msg&quot;);</code></p>
<p>自定义日志记录器：<br><code>private static final Logger myLogger = Logger.getLogger(&quot;com.mycompany.myapp&quot;);</code></p>
<h5 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h5><blockquote>
<p>消除函数调用,采用类变量直接访问，可以减少函数栈的调用，提高效率</p>
<p>从【c.getName()】 变更为【c.name】的形式</p>
</blockquote>
<p>即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“ 内联”）。即时编译器知道那些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。</p>
<p>是否将某个方法设置为内联方法是Java 虚拟机的任务。即时编译器会监视调用那些<strong>简洁</strong>、<strong>经常被调用</strong>、<strong>没有被重载</strong>以及<strong>可优化</strong>的方法。</p>
<p>在早期的Java 中， 有些程序员为了避免动态绑定带来的系统开销而使用final 关键字。如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理， 这个过程为称为内联( inlining )。例如，内联调用e.getName( ) 将被替换为访问e.name 域。这是一项很有意义的改进， 这是由于CPU 在处理调用方法的指令时， 使用的分支转移会扰乱预取指令的策略， 所以，这被视为不受欢迎的。然而， 如果getName 在另外一个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作， 因此也就不能对它进行内联处理了。</p>
<p>幸运的是， 虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系， 并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正地被覆盖， 那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖， 那么将会发生什么情况呢？ 优化器将取消对覆盖方法的内联。这个过程很慢， 但却很少发生。</p>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TestEnum</span> </span>&#123;</span><br><span class="line">    Red(<span class="string">&quot;red&quot;</span>), Blue(<span class="string">&quot;blue&quot;</span>), Green(<span class="string">&quot;green&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    TestEnum(String color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnum</span> <span class="keyword">extends</span> <span class="title">Enum</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestEnum[] values()&#123;</span><br><span class="line">        <span class="keyword">return</span> (TestEnum[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestEnum <span class="title">valueOf</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (TestEnum)Enum.valueOf(com/benben/TestEnum, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestEnum</span><span class="params">(String s, <span class="keyword">int</span> i, String s1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        mColor = s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Red;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Blue;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum Green;</span><br><span class="line">    <span class="keyword">private</span> String mColor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestEnum $VALUES[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Red = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Red&quot;</span>, <span class="number">0</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        Blue = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Blue&quot;</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        Green = <span class="keyword">new</span> TestEnum(<span class="string">&quot;Green&quot;</span>, <span class="number">2</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> TestEnum[] &#123;</span><br><span class="line">            Red, Blue, Green</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意一：从上面可以看出，枚举会消耗更多的内存，类似于饿汉式的单例</strong></p>
<p><strong>注意二：Proguard以及Android的R8也会对简单的枚举（即不实现接口也没有额外成员的枚举）做优化</strong></p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><blockquote>
<p>对于final的基本变量类型，在编译字节码的时候会被认为不会再改变，会将值直接放入调用处，所以反射对它无效</p>
<p>如果是static final的基本变量类型，修改值会产生异常，必须要修改可以再反射修改它的<code>modifiers</code>值以达到能修改的目的，注意：目前jvm并没有对该字段有限制</p>
</blockquote>
<h5 id="反射效率低"><a href="#反射效率低" class="headerlink" title="反射效率低"></a>反射效率低</h5><p>java反射效率低的主要原因是：</p>
<ol>
<li>Method#invoke 方法会对参数做封装和解封操作</li>
<li>需要检查方法可见性。原因：反射时每次调用都必须检查方法的可见性（在Method.invoke里）</li>
<li>需要校验参数。反射时也必须检查每个实际参数与形式参数的类型匹配性（在NativeMethodAccessorImpl.invoke0 里或者生成的 Java 版 MethodAccessor.invoke 里）</li>
<li>反射方法难以内联。参考：<a href="https://www.iteye.com/blog/rednaxelafx-548536">https://www.iteye.com/blog/rednaxelafx-548536</a></li>
<li>JIT 无法优化。原因：因为涉及到动态解析的类型，所以无法优化</li>
</ol>
<p>提高反射性能的方式：</p>
<ol>
<li>将反射获取到的类，构造函数，函数，对象实例缓存起来，不用每次都全新查找</li>
<li>可通过调用method.setAccessible(true)的方式来关闭Method.invoke可见性检查</li>
<li>需要更极致的提高效率可以通过字节码生成的方式来实现反射机制。参考：<a href="https://github.com/EsotericSoftware/reflectasm">https://github.com/EsotericSoftware/reflectasm</a></li>
</ol>
<h5 id="Lambda高阶参考"><a href="#Lambda高阶参考" class="headerlink" title="Lambda高阶参考"></a>Lambda高阶参考</h5><p><a href="https://baijiahao.baidu.com/s?id=1606476168883238803&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1606476168883238803&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术卷二高级特性-笔记</title>
    <url>/2020/09/18/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%BA%8C%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h5 id="Java-SE-8-流库"><a href="#Java-SE-8-流库" class="headerlink" title="Java SE 8 流库"></a>Java SE 8 流库</h5><blockquote>
<p>参考：<a href="https://blog.csdn.net/Al_assad/article/details/82356845">https://blog.csdn.net/Al_assad/article/details/82356845</a></p>
</blockquote>
<h5 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h5><ul>
<li>重点关注内存映射：<code>FileChannel</code></li>
</ul>
<h5 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h5><ul>
<li><code>Date</code></li>
<li><code>SimpleDateFormat</code> 和 <code>Calendar</code></li>
<li><code>LocalDateTime</code> 和 <code>DateTimeFormatter</code></li>
</ul>
<h5 id="Shocket-通讯"><a href="#Shocket-通讯" class="headerlink" title="Shocket 通讯"></a>Shocket 通讯</h5><ul>
<li><code>Socket</code> 和 <code>ServerSocket</code></li>
<li><code>URL</code> 和 <code>HttpURLConnection</code></li>
<li>重点关注可中断套接字：<code>SocketChannel</code>、<code>Channels.newInputStream</code> 、 <code>Channels.newOutputStream</code>、<code>DatagramChannel</code>、<code>MulticastChannel</code></li>
<li>UDP通讯：<code>DatagramSocket</code>和<code>DatagramPacket</code>【只允许发送到指定目标地址】</li>
<li>UDP 多点通讯：<code>MulticastSocket</code>【组播】</li>
</ul>
<h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h5><p>每个Java程序至少拥有三个类加载器，除引导类加载器外，每个类加载器都有父类加载器【注：双亲委派机制】</p>
<ul>
<li><p>引导类加载器【通常由C语言实现】</p>
</li>
<li><p>扩展类加载器【用于加载<code>jre/lib/ext</code>类文件】</p>
</li>
<li><p>系统类加载器（又名应用类加载器）【用于加载应用类文件】</p>
</li>
<li><p>自定义类加载器</p>
<p>需要重写<code>findClass</code>函数，在超类的<code>loadClass</code>委托其父类加载器加载失败时会调用<code>findClass</code>方法</p>
<p>在<code>findClass</code>函数内加载到类数据时需要调用超类<code>defineClass</code>方法，向虚拟机提供字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = ...;<span class="comment">// 加载类字节码数据</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name,classData,off,len);<span class="comment">// 加载字节码并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="消息摘要"><a href="#消息摘要" class="headerlink" title="消息摘要"></a>消息摘要</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MD5 SHA-1 SHA-256 SHA-384 SHA-512....M</span></span><br><span class="line">MessageDigest digest = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    digest.update(<span class="keyword">byte</span>[]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] result = digest.digest();</span><br></pre></td></tr></table></figure>

<h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p><code>KeyGenerator</code>、<code>SecureRandom</code>、<code>Cipher</code>、<code>KeyPairGenerator</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>代理</title>
    <url>/2020/11/09/Java/%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>主要目的是扩展原有类的功能</p>
</blockquote>
<h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerImpl</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handle: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerProxy</span> <span class="keyword">implements</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="comment">// 传入需要代理的实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerProxy</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩展其用法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        mHandler.handle(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">new</span> HandlerProxy(<span class="keyword">new</span> HandlerImpl()).handle(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>就这样，知道缺点是被代理的类扩展了代理类也需一并扩展。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerImpl</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handle: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明实现InvocationHandler的处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入需要代理的实例对象</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        <span class="comment">// 利用反射机制将请求分派给委托类处理</span></span><br><span class="line">        Object invoke = method.invoke(mHandler, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Handler o = (Handler) Proxy.newProxyInstance(</span><br><span class="line">	    <span class="comment">// 类加载器</span></span><br><span class="line">        HandlerImpl.class.getClassLoader(),</span><br><span class="line">    	<span class="comment">// 需要代理的接口，也可：HandlerImpl.class.getInterfaces()</span></span><br><span class="line">    	<span class="keyword">new</span> Class[]&#123;Handler.class&#125;,</span><br><span class="line">    	<span class="comment">// 处理器</span></span><br><span class="line">        <span class="keyword">new</span> MyHandler(<span class="keyword">new</span> HandlerImpl()));</span><br><span class="line">o.handle(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，动态代理跟静态代理一样，在代理类内部保存了一个委托类的实例，实际上都是调用原来的委托实例来进行需要的操作。</p>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ol>
<li>动态代理跟静态代理最大的不同便是生成代理类的时期不同，静态代理是在编译期，而动态代理则是在运行时根据委托类信息动态生成</li>
<li>动态代理实现的是<code>InvocationHandler</code>接口，而静态代理则是直接实现公共接口</li>
<li>动态代理可以获得更多的运行时信息，使用起来也会更加灵活</li>
</ol>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>由于最终调用实际逻辑采用方法反射调用的方式，效率并不是很高</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>最终通过<code>ProxyGenerator.generateProxyClass()</code>函数动态生成代理字节码二进制数据，然后通过native方法<code>defineClass0</code>将字节码加载进方法区，并获取参数为<code>InvocationHandler</code>的构造器，然后通过该构造器生成实例并传入我们自定义的处理器</p>
<p><strong>注：android中直接通过<code>generateProxy</code>生成了代理类，并没有走<code>ProxyGenerator</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant Proxy</span><br><span class="line">participant Proxy#ProxyClassFactory</span><br><span class="line">participant WeakCache</span><br><span class="line">participant WeakCache#Factory</span><br><span class="line"></span><br><span class="line">Note left of WeakCache:Proxy类里有静态实例WeakCache成员变量\n生成该实例时传入ProxyClassFactory实例</span><br><span class="line">Proxy -&gt; WeakCache:Proxy.getProxyClass0()</span><br><span class="line">Note right of WeakCache:优先查找缓存</span><br><span class="line">WeakCache -&gt; WeakCache:proxyClassCache.get()</span><br><span class="line">WeakCache -&gt; Proxy:有缓存</span><br><span class="line">Note right of WeakCache:构建Factory工厂类</span><br><span class="line">WeakCache -&gt; WeakCache:new Factory()</span><br><span class="line">WeakCache -&gt; WeakCache#Factory:supplier.get()</span><br><span class="line">WeakCache#Factory -&gt; Proxy#ProxyClassFactory:valueFactory.apply()</span><br><span class="line">Note right of Proxy#ProxyClassFactory:1.类加载器是否解析出相同的class对象</span><br><span class="line">Note right of Proxy#ProxyClassFactory:2.class是否是一个接口</span><br><span class="line">Note right of Proxy#ProxyClassFactory:3.数组类是否重复等判断</span><br><span class="line">Note right of Proxy#ProxyClassFactory:调用defineClass0（native方法）动态生成字节码</span><br><span class="line">Proxy#ProxyClassFactory -&gt; Proxy:ProxyGenerator.generateProxyClass() \n defineClass0()</span><br><span class="line">Note right of Proxy:取参数为InvocationHandler构造器</span><br><span class="line">Note right of Proxy:通过构造器生成实例时传入处理器</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h3><blockquote>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充</p>
<p>通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择</p>
<p>git地址：<a href="https://github.com/cglib/cglib">https://github.com/cglib/cglib</a></p>
<p>cglib-nodep-xxx.jar:使用nodep包不需要关联asm的jar包,jar包内部包含asm的类.<br>cglib-xxx.jar:使用此jar包需要关联asm的jar包,否则运行时报错.</p>
</blockquote>
<h5 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_1</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_2</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_3</span><span class="params">(String data)</span> </span>&#123;System.out.println(data);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Handler handler = (Handler) Enhancer.create(Handler.class, <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        <span class="comment">// methodProxy 代理类方法代理引用，invokeSuper调用实际逻辑</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">handler.method_1(<span class="string">&quot;待处理数据&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h6><blockquote>
<p>作用：可以针对不同的方法调用不同的逻辑，</p>
<p>注意：虽然可以在<code>MethodInterceptor</code>的intercept方法进行区分，但使用过滤器可以有效的减少哈希查找，提高效率</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 什么操作都不做，直接调用实际方法</span></span><br><span class="line">NoOp instance = NoOp.INSTANCE;</span><br><span class="line"><span class="comment">// 锁定方法返回值，不会触发实际方法</span></span><br><span class="line">FixedValue fixedValue = <span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;锁定调用结果&quot;</span>);</span><br><span class="line">        Object result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 拦截操作</span></span><br><span class="line">MethodInterceptor methodInterceptor = <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start handle&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;end handle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Handler handler = (Handler) Enhancer.create(Handler.class, <span class="keyword">null</span>, <span class="keyword">new</span> CallbackFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_1&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_2&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Callback[]&#123;instance, fixedValue, methodInterceptor&#125;);</span><br><span class="line">handler.method_1(<span class="string">&quot;method_1&quot;</span>);</span><br><span class="line">handler.method_2(<span class="string">&quot;method_2&quot;</span>);</span><br><span class="line">handler.method_3(<span class="string">&quot;method_3&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="延迟加载："><a href="#延迟加载：" class="headerlink" title="延迟加载："></a>延迟加载：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延迟加载类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBeam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LazyLoader 只有在代理类调用任意方法时才会初始化数据，只会触发一次loadObject</span></span><br><span class="line">LazyBeam lazyBeam = (LazyBeam) Enhancer.create(LazyBeam.class, <span class="keyword">null</span>, <span class="keyword">new</span> LazyLoader() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载数据&quot;</span>);</span><br><span class="line">        LazyBeam lazyBeam = <span class="keyword">new</span> LazyBeam();</span><br><span class="line">        lazyBeam.setName(<span class="string">&quot;lazyBeam&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> lazyBeam;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(lazyBeam.getName());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatcher 只有在代理类调用任意方法时才会初始化数据,且每次都会触发loadObject</span></span><br><span class="line">LazyBeam lazyBeam = (LazyBeam) Enhancer.create(LazyBeam.class, <span class="keyword">null</span>, <span class="keyword">new</span> Dispatcher() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载数据&quot;</span>);</span><br><span class="line">        LazyBeam lazyBeam = <span class="keyword">new</span> LazyBeam();</span><br><span class="line">        lazyBeam.setName(<span class="string">&quot;lazyBeam&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> lazyBeam;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(lazyBeam.getName());</span><br></pre></td></tr></table></figure>

<h6 id="接口生成："><a href="#接口生成：" class="headerlink" title="接口生成："></a>接口生成：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterfaceMaker maker = <span class="keyword">new</span> InterfaceMaker();</span><br><span class="line">maker.add(Handler.class);</span><br><span class="line">Class&lt;?&gt; aClass = maker.create();</span><br><span class="line"><span class="keyword">for</span> (Method method : aClass.getMethods()) &#123;</span><br><span class="line">    System.out.println(method.getName());</span><br><span class="line">&#125;</span><br><span class="line">Object obj = Enhancer.create(Object.class, <span class="keyword">new</span> Class[]&#123;aClass&#125;, <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_1&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行方法1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;方法1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;method_2&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行方法2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;方法2&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Method method_1 = aClass.getMethod(<span class="string">&quot;method_1&quot;</span>, String.class);</span><br><span class="line">method_1.invoke(obj,<span class="string">&quot;方法1&quot;</span>);</span><br><span class="line">Method method_2 = aClass.getMethod(<span class="string">&quot;method_2&quot;</span>, String.class);</span><br><span class="line">method_2.invoke(obj,<span class="string">&quot;方法2&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h5><h6 id="表层原理："><a href="#表层原理：" class="headerlink" title="表层原理："></a>表层原理：</h6><p>动态生成代理类的子类，子类重写要代理的类的所有不是final/private的方法。在子类采用方法拦截的技术拦截所有父类方法的调用。</p>
<h6 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h6><p>使用字节码处理框架ASM，来转换字节码并生成新的类。<strong>注：不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</strong></p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>相较与JDK动态代理</p>
<ol>
<li>可以实现接口和类的代理，局限性更小【<strong>注：代理接口调用<code>invokeSuper</code>相当于直接调用未实现的接口方法，会直接报错</strong>】</li>
<li>由于与实际编写继承代码无异，采用的是动态用生成子类方式，方法执行效率要高</li>
<li>有丰富的操作策略以适应不同的业务</li>
</ol>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>由于采用继承的关系，对私有方法和final方法无法代理</p>
<h6 id="包说明："><a href="#包说明：" class="headerlink" title="包说明："></a>包说明：</h6><p><code>net.sf.cglib.core</code>:底层字节码处理类，他们大部分与ASM有关系。<br><code>net.sf.cglib.transform</code>:编译期或运行期类和类文件的转换<br><code>net.sf.cglib.proxy</code>:实现创建代理和方法拦截器的类<br><code>net.sf.cglib.reflect</code>:实现快速反射和C#风格代理的类<br><code>net.sf.cglib.util</code>:集合排序等工具类<br><code>net.sf.cglib.beans</code>:JavaBean相关的工具类</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类说明</title>
    <url>/2020/11/11/Java/%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="内部类说明"><a href="#内部类说明" class="headerlink" title="内部类说明"></a>内部类说明</h1><blockquote>
<p>jdk版本：</p>
<p>java version “1.8.0_261”<br>Java(TM) SE Runtime Environment (build 1.8.0_261-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</p>
</blockquote>
<p>编译文件说明</p>
<ol>
<li>内部类实际会被编译成【外部类名$内部类名.class】的字节码文件，并自动在内部类中生成一个持有外部类的【final 外部类名 this$0】的变量，由构造函数进行赋值</li>
<li>内部接口生成的字节码文件与第一点同理，并对接口函数进行【public abstract】声明</li>
<li>匿名内部类则会将类名赋予数字的形式处理，如【外部类名$1.class】，构造函数与第一点相同，如果有调用外部函数变量，则还会在构造函数增加该函数变量参数，并复制给【final 类型 val$别名】的变量上</li>
<li>如果内部类有调用外部类变量，则会在外部类生成一个静态函数【static 该外部类变量 access$000(外部类实例)】供内部类在调用外部类的地方使用</li>
</ol>
<p>注：以上提到的美元符号的名命【this$0 access$000 val$name】在不同的编译器和调用情况会有所不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler.java</span></span><br><span class="line"><span class="comment">// 源文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String name)</span> </span>&#123;<span class="comment">// 匿名内部类有调用该参数，编译时会被声明为final</span></span><br><span class="line">        mName = name;</span><br><span class="line">        <span class="keyword">new</span> RealHandler().handle();</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> IntHandler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(name); <span class="comment">// 匿名内部类调用外部函数变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(mName); <span class="comment">// 内部类调用外部变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntHandler</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler.class</span></span><br><span class="line"><span class="comment">// 反编译文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mName = var1;</span><br><span class="line">        (<span class="keyword">new</span> Handler.RealHandler()).handle();</span><br><span class="line">        Handler.IntHandler var10001 = <span class="keyword">new</span> Handler.IntHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealHandler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RealHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Handler.<span class="keyword">this</span>.mName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// javap 命令文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> java.lang.String access$<span class="number">000</span>(Handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler$1.class</span></span><br><span class="line"><span class="comment">// 反编译文件</span></span><br><span class="line"><span class="keyword">import</span> Handler.IntHandler;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>$1 <span class="keyword">implements</span> <span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">    Handler$<span class="number">1</span>(Handler var1, String var2) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.val$name = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.val$name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// javap 命令文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>$1 <span class="keyword">implements</span> <span class="title">Handler</span>$<span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> java.lang.String val$name;</span><br><span class="line">  <span class="keyword">final</span> Handler <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">  Handler$<span class="number">1</span>(Handler, java.lang.String);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内部接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler$IntHandler</span></span><br><span class="line"><span class="comment">// 反编译文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span>$<span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// javap 命令文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span>$<span class="title">IntHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file name:Handler$RealHandler.class</span></span><br><span class="line"><span class="comment">// 反编译文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span>$<span class="title">RealHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler$RealHandler(Handler var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Handler.access$<span class="number">000</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// javap 命令文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span>$<span class="title">RealHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Handler <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> Handler$RealHandler(Handler);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-语法</title>
    <url>/2020/09/20/Kotlin/%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ol>
<li><p>中缀表达式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B&gt;</span> A.<span class="title">to</span><span class="params">(that : <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt;</span><br><span class="line"><span class="comment">// 使用： A 中缀方法 B</span></span><br><span class="line"><span class="number">1</span> to <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>可变参数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// varargs，类似于java的 ... ，但是位置没有限制</span></span><br><span class="line"><span class="comment">// 可以使用 * 来传入外部的变量作为可变参数的变量</span></span><br><span class="line"><span class="keyword">val</span> letters = arrayof(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">printLetters(*letters)</span><br></pre></td></tr></table></figure></li>
<li><p>原生字符串</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    123</span></span><br><span class="line"><span class="string">    abc</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>判断</p>
<ul>
<li>结构相等：== ，判断内容是否相等</li>
<li>引用相等：=== ， 判断引用是否一样</li>
</ul>
</li>
<li><p>区间</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间[IntRange]</span></span><br><span class="line"><span class="number">1</span> .. <span class="number">10</span> <span class="comment">// [1,...,10]</span></span><br><span class="line"><span class="number">1</span> until <span class="number">10</span> <span class="comment">// [1,...,9)</span></span><br><span class="line"><span class="number">10</span> downTo <span class="number">1</span> <span class="comment">// [10,9...1]</span></span><br><span class="line"><span class="number">1</span> .. <span class="number">10</span> step <span class="number">2</span> <span class="comment">// [1,3,5...]</span></span><br></pre></td></tr></table></figure></li>
<li><p>遍历</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array) &#123;&#125;</span><br><span class="line"><span class="comment">// 获取索引</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>延迟初始化：<code>by lazy</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认线程安全</span></span><br><span class="line"><span class="keyword">val</span> str <span class="keyword">by</span> lazy &#123; <span class="string">&quot;str&quot;</span> &#125;</span><br><span class="line"><span class="comment">// 并行模式</span></span><br><span class="line"><span class="keyword">val</span> str <span class="keyword">by</span> lazy(LazyThreadSafetyMode.PUBLICATION) &#123; <span class="string">&quot;str&quot;</span> &#125;</span><br><span class="line"><span class="comment">// 不做任何线程安全保证，也不会有任何线程开销</span></span><br><span class="line"><span class="keyword">val</span> str <span class="keyword">by</span> lazy(LazyThreadSafetyMode.NONE) &#123; <span class="string">&quot;str&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>变量必须是不可以变的：<code>val</code></li>
<li>在首次调用时才会初始化</li>
<li><code>lazy</code>属性会默认加入同步锁，在同一时刻只允许一个线程堆lazy属性进行初始化</li>
</ul>
</li>
<li><p>函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambda 表达式</span></span><br><span class="line"><span class="keyword">val</span> foo = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y&#125; <span class="comment">// foo.invoke(1, 2) 或 foo(1, 2)</span></span><br><span class="line"><span class="comment">// lambda 表达式函数体</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span> = &#123;y: <span class="built_in">Int</span> -&gt; x + y&#125; <span class="comment">// foo(1).invoke(2) 或 foo(1)(2)</span></span><br></pre></td></tr></table></figure></li>
<li><p>匿名内部类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambda 表达式</span></span><br><span class="line"><span class="keyword">val</span> runnable = Runnable&#123;&#125;</span><br><span class="line"><span class="comment">// 匿名实现类</span></span><br><span class="line"><span class="keyword">val</span> runnable = <span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或匿名内部类</span></span><br><span class="line">executor.submit(<span class="keyword">object</span>:Runnable&#123;...&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="10">
<li><p>密封类：<code>sealed</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuccessStatus</span>:<span class="type">Status</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorStatus</span>:<span class="type">Status</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>要继承必须将子类定义在同一个文件中</li>
</ul>
</li>
<li><p>内联类</p>
<blockquote>
<p>类似于包装类型，在编译时会把实际值替换到调用处<br>由于 <code>Kotlin</code> 不能使用<code>IntDef</code>模拟枚举的调用，可以考虑内联类来模拟枚举</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">val</span> ordinal:<span class="built_in">Int</span>)</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">		<span class="comment">// 模拟枚举</span></span><br><span class="line">		<span class="keyword">val</span> Idle = State(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">val</span> Busy = State(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可见性修饰符</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">含义</th>
<th align="center">与Java比较</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center"><code>Kotlin</code>中默认修饰符，全局可见</td>
<td align="center">与Java中public效果相同</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">受保护修饰符，类及子类可见</td>
<td align="center">含义一致，作用域除了类和子类，包内也可见</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">私有修饰符，类内修饰只有本类可见，类外修饰文件内可见</td>
<td align="center">私有修饰符，只有类内可见</td>
</tr>
<tr>
<td align="center">internal</td>
<td align="center">模块内可见</td>
<td align="center">无</td>
</tr>
</tbody></table>
</li>
<li><p>内部类和静态内部类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">StaticClass</span></span>&#123;&#125; <span class="comment">// 静态内部类</span></span><br><span class="line">	<span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125; <span class="comment">// 内部类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>委托代替接口实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span> : <span class="type">CanFly &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(flyer: Flyer) : CanFly <span class="keyword">by</span> flyer</span><br></pre></td></tr></table></figure></li>
<li><p>解构</p>
<blockquote>
<p>普通类想要使用结构方式可以手动写component1 component2一一对应的结构函数</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据类最多支持五个参数的解构</span></span><br><span class="line"><span class="keyword">val</span> pair = Pair(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> triple = Triple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> (n1, n2) = pair</span><br><span class="line"><span class="keyword">val</span> (a, b, c) = triple</span><br></pre></td></tr></table></figure></li>
<li><p>伴生类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123;</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123; <span class="comment">//相对于饿汉式静态内部类，全局只有一个实例</span></span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">testFun</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>object</code> 单例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Child</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Child INSTANCE;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      INSTANCE = <span class="keyword">new</span> Child();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>操作符</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj:TestData? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> result = obj?.value ?: -<span class="number">1</span> <span class="comment">// 如果 obj 为空，则返回 1</span></span><br><span class="line"><span class="keyword">val</span> result = obj!!.value <span class="comment">// 明确知道obj不为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> stu: Student? = getStu() <span class="keyword">as</span> Student <span class="comment">// 强制转换，如果为空会报错</span></span><br><span class="line"><span class="keyword">val</span> stu: Student? = getStu() <span class="keyword">as</span>? Student <span class="comment">// 强制转换，如果 getStu 返回空，则转换为空</span></span><br></pre></td></tr></table></figure></li>
<li><p>泛型内联特化</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">method</span><span class="params">(t:<span class="type">T</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> ts = Array&lt;T&gt;(<span class="number">3</span>)&#123;&#125;</span><br><span class="line">	<span class="keyword">val</span> jclass = T::<span class="keyword">class</span>.java</span><br><span class="line">	<span class="keyword">val</span> list = ArrayList&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a1 = arrayOf(o1, o2, o3) <span class="comment">// 普通数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a2 = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 基本数据类型数组：longArrayOf、floatArrayOf、doubleArrayOf....</span></span><br></pre></td></tr></table></figure></li>
<li><p>泛型多继承</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ground</span></span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Water</span>: <span class="type">Fruit</span></span>(),Ground</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cut</span><span class="params">(t: <span class="type">T</span>)</span></span> <span class="keyword">where</span> T : Fruit, T : Ground &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>作用域操作符</p>
<ul>
<li>如果需要返回自身的：apply{this} 或 also{it}</li>
<li>不需要返回自身的：run{this}或let{it}</li>
<li>满足条件才执行：<code>data.takeIf &#123; it.age &gt;= 18 &#125;.let &#123;...&#125;</code></li>
<li>不满足条件才执行：<code>data.takeUnless &#123; it.age &gt;= 18 &#125;.let &#123;...&#125;</code></li>
</ul>
</li>
<li><p><code>with</code> 和 <code>apply</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T</span><br></pre></td></tr></table></figure></li>
<li><p>惰性求值：序列</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该操作会产生两个临时集合来记录元素，如果元素非常多时，就会有效率问题</span></span><br><span class="line">list.filter &#123;it &gt; <span class="number">2</span>&#125;.map &#123;it * <span class="number">2</span>&#125;                                                                                             </span><br><span class="line"><span class="comment">// 通过惰性求值减少临时集合的情况</span></span><br><span class="line">list.asSequence().filter &#123;it &gt; <span class="number">2</span>&#125;.map &#123;it * <span class="number">2</span>&#125;.toList()</span><br></pre></td></tr></table></figure></li>
<li><p>无限序列</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> naturalNumList = generateSequence(<span class="number">0</span>) &#123;it + <span class="number">1</span>&#125;</span><br><span class="line">naturalNumList.takeWhile &#123;it &lt;= <span class="number">9</span>&#125;.toList()</span><br></pre></td></tr></table></figure></li>
<li><p>内联函数</p>
<blockquote>
<p>内联函数能将函数内容编译到调用处，减少函数调用</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(block:() -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// crossinline 禁止传递的block函数调用 r eturn 方法</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(<span class="keyword">crossinline</span> block:() -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// noinline 该函数参数不做内联</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">cost</span><span class="params">(<span class="keyword">noinline</span> block:() -&gt; <span class="type">Unit</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>内联函数注意事项</p>
<ul>
<li>由于JVM对普通函数有内联优化，所以普通函数比一定要采用内联函数，这样只会增加复杂性</li>
<li>尽量避免有大量函数体的函数进行内联，这样会增加字节码数量</li>
<li>内联函数无法使用闭包成员【闭包：内部函数持有外部函数变量】</li>
</ul>
</li>
<li><p>运算符重载</p>
<p>参考：<a href="https://kotlinlang.org/docs/reference/operator-overloading.html">https://kotlinlang.org/docs/reference/operator-overloading.html</a><br>operator fun 类名.重载符号(一个参数):返回值 {}</p>
</li>
<li><p>扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 为Person类增加名为ext的扩展方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">ext</span><span class="params">(s:<span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩展属性</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> Data.extValue:boolean</span><br><span class="line">	<span class="keyword">get</span>() = <span class="keyword">this</span>.otherValue % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> age = <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Son.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;age = <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样就可以不创建类的情况下直接调用</span></span><br><span class="line">Son.foo()</span><br></pre></td></tr></table></figure></li>
<li><p>代理观察者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.observable(<span class="number">0</span>, &#123; property, oldValue, newValue -&gt;</span><br><span class="line">		<span class="comment">// 当price的值变更时触发该函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = Data()</span><br><span class="line"><span class="keyword">data</span>.price = <span class="number">100</span></span><br></pre></td></tr></table></figure></li>
<li><p>代理限制</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.vetoable(<span class="number">0</span>, &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        newValue &gt; <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = Data()</span><br><span class="line"><span class="keyword">data</span>.price = <span class="number">100</span></span><br><span class="line"><span class="keyword">data</span>.price = -<span class="number">100</span> <span class="comment">// 该值不会设置成功</span></span><br></pre></td></tr></table></figure></li>
<li><p>原始方式创建协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> &#123;</span><br><span class="line">    <span class="comment">// coroutine heandle!</span></span><br><span class="line">&#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = Dispatchers.Default</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Coroutine end!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).resume(<span class="built_in">Unit</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>顶层协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123;&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure></li>
<li><p>会阻塞当前线程直到协程作用域内的代码全部执行完</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runBlocking &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建子协程，必须在协程作用域内使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch&#123;&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure></li>
<li><p>挂起函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没法使用launch函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过coroutineScope生成带协程作用域的挂起函数</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span>=coroutineScope&#123;</span><br><span class="line">	launch&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：coroutineScope也会阻塞当前协程，必须得里面的子协程执行完了才行</span></span><br><span class="line">runBlocking &#123;</span><br><span class="line">	coroutineScope &#123;</span><br><span class="line">		launch &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得等coroutineScope执行完了才会走到这</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得等runBlocking执行完了才会走到这</span></span><br></pre></td></tr></table></figure></li>
<li><p>协程统一取消</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = Job()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(job)</span><br><span class="line">scope.launch&#123;</span><br><span class="line">	<span class="comment">// 协程域</span></span><br><span class="line">&#125;</span><br><span class="line">job.cancel()</span><br></pre></td></tr></table></figure></li>
<li><p>超时协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">withTimeout(<span class="number">100</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回结果的协程域</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> r1 = async&#123;</span><br><span class="line">	<span class="comment">// 返回deferred时协程就已经开始跑了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> r2 = async&#123;</span><br><span class="line">	<span class="comment">// 返回deferred时协程就已经开始跑了</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;r1.await()&#125;</span> - <span class="subst">$&#123;r2.await()&#125;</span>&quot;</span>)<span class="comment">// 阻塞返回结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// async简化版</span></span><br><span class="line"><span class="keyword">val</span> result = withContext(Dispatchers.Dafault) &#123;&#125; <span class="comment">// 阻塞返回结果，其中Dispatchers.Dafault为低并发策略</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>suspendCoroutine</code>结合回调函数，需要在协程域和挂起函数中使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(address:<span class="type">String</span>)</span></span>:String &#123;</span><br><span class="line">	<span class="keyword">return</span> suspendCoroutine &#123;continuation -&gt;    </span><br><span class="line">		new Thread(&#123;</span><br><span class="line">				continuation.resume(结果)<span class="comment">// 成功</span></span><br><span class="line">				continuation.resumeWithException(结果)<span class="comment">// 失败</span></span><br><span class="line">		&#125;).start()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步代码块和同步代码函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">method2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="function"><span class="keyword">fun</span> <span class="title">method1</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>volatile</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>ReentrantLock</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> lock = ReentrantLock()</span><br><span class="line">lock.withLock &#123; method() &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>反射</p>
<blockquote>
<p>首次使用会比java的慢</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Kotlin <span class="class"><span class="keyword">class</span>：<span class="title">String</span>:<span class="type">:class 	String::class.java.kotlin</span></span></span><br><span class="line">Java <span class="class"><span class="keyword">class</span>: <span class="type">String::class.java</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>注解变更java调用命名</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;name&quot;</span>)<span class="comment">//作用于文件名</span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;name&quot;</span>)<span class="comment">//作用于变量get函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带默认参数函数适配java调用</span></span><br><span class="line"><span class="meta">@JvmOverloads</span><span class="comment">//这样就会生成重载方法来适配默认参数</span></span><br><span class="line"></span><br><span class="line">inernal <span class="comment">// 声明的对象不想被java访问到，可以使用@JvmName(&quot;%abc&quot;)等特殊字符声明，这样java就被限制了</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu环境变量</title>
    <url>/2020/09/16/Linux/Ubuntu%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Ubuntu环境变量"><a href="#Ubuntu环境变量" class="headerlink" title="Ubuntu环境变量"></a>Ubuntu环境变量</h1><h5 id="在Ubuntu中有如下几个文件可以设置环境变量："><a href="#在Ubuntu中有如下几个文件可以设置环境变量：" class="headerlink" title="在Ubuntu中有如下几个文件可以设置环境变量："></a>在Ubuntu中有如下几个文件可以设置环境变量：</h5><ul>
<li><p><code>/etc/profile</code>：在登录时,操作系统定制用户环境时使用的第一个文件,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.</p>
</li>
<li><p><code>/etc/environment</code>：在登录时操作系统使用的第二个文件,系统在读取你自己的 <code>profile</code> 前,设置环境文件的环境变量</p>
</li>
<li><p><code>~/.profile</code>：在登录时用到的第三个文件是 <code>.profile</code> 文件,每个用户都可使用该文件输入专用于自己使用的 <code>shell</code> 信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的 <code>.bashrc</code> 文件.</p>
</li>
<li><p><code>/etc/bashrc</code>：为每一个运行 <code>bash shell</code> 的用户执行此文件。当 <code>bash shell</code> 被打开时,该文件被读取.</p>
</li>
<li><p><code>~/.bashrc</code>：该文件包含专用于你的 <code>bash shell</code> 的 <code>bash</code> 信息,当登录时以及每次打开新的 <code>shell</code> 时,该该文件被读取.</p>
</li>
</ul>
<h5 id="通常设置环境变量有三种方法："><a href="#通常设置环境变量有三种方法：" class="headerlink" title="通常设置环境变量有三种方法："></a>通常设置环境变量有三种方法：</h5><ol>
<li><p>临时设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/home/yan/share/usr/<span class="built_in">local</span>/arm/3.4.1/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li>
<li><p>当前用户的全局设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开 ~/.bashrc，添加行：</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/yan/share/usr/<span class="built_in">local</span>/arm/3.4.1/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 使生效</span></span><br><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>所有用户的全局设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 在里面加入：</span></span><br><span class="line"><span class="built_in">export</span> PATH=/home/yan/share/usr/<span class="built_in">local</span>/arm/3.4.1/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 使生效</span></span><br><span class="line"><span class="built_in">source</span> profile</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="JDK-配置"><a href="#JDK-配置" class="headerlink" title="JDK 配置"></a>JDK 配置</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8/</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>



<h5 id="NDK-配置"><a href="#NDK-配置" class="headerlink" title="NDK 配置"></a>NDK 配置</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NDK=/home/benben/AndroidSDK/ndk-bundle</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$NDK</span></span><br></pre></td></tr></table></figure>



<h5 id="shadowsocks-qt5-配置"><a href="#shadowsocks-qt5-配置" class="headerlink" title="shadowsocks-qt5 配置"></a><code>shadowsocks-qt5</code> 配置</h5><p><a href="https://github.com/shadowsocks/shadowsocks-qt5">https://github.com/shadowsocks/shadowsocks-qt5</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 学习笔记-解压缩命令详解</title>
    <url>/2020/09/17/Linux/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Linux-学习笔记-解压缩命令详解"><a href="#Linux-学习笔记-解压缩命令详解" class="headerlink" title="Linux 学习笔记-解压缩命令详解"></a>Linux 学习笔记-解压缩命令详解</h1><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><pre><code>独立命令：
    -c: 建立压缩档案
    -x：解压
    -t：查看内容
    -r：向压缩归档文件末尾追加文件
    -u：更新原压缩包中的文件
    注意：这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。

下面的参数是根据需要在压缩或解压档案时可选的。
    -z：有gzip属性的
    -j：有bz2属性的
    -Z：有compress属性的
    -v：显示所有过程
    -O：将文件解开到标准输出

下面的参数-f是必须的
    -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。

tar -cf all.tar *.jpg     // 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。
tar -rf all.tar *.gif     // 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。
tar -uf all.tar logo.gif  // 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。
tar -tf all.tar           // 这条命令是列出all.tar包中所有文件，-t是列出文件的意思
tar -xf all.tar           // 这条命令是解出all.tar包中所有文件，-x是解开的意思
</code></pre>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><pre><code>tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg
tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一  个gzip压缩过的包，命名为jpg.tar.gz
tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2
tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z
rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux
zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux
</code></pre>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><pre><code>tar –xvf file.tar //解压 tar包
tar -xzvf file.tar.gz //解压tar.gz
tar -xjvf file.tar.bz2   //解压 tar.bz2
tar –xZvf file.tar.Z   //解压tar.Z
unrar e file.rar //解压rar
unzip file.zip //解压zip
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>(1) *.tar 用 tar –xvf 解压
(2) *.gz 用 gzip -d或者gunzip 解压
(3) *.tar.gz和*.tgz 用 tar –xzf 解压
(4) *.bz2 用 bzip2 -d或者用bunzip2 解压
(5) *.tar.bz2用tar –xjf 解压
(6) *.Z 用 uncompress 解压
(7) *.tar.Z 用tar –xZf 解压
(8) *.rar 用 unrar e解压
(9) *.zip 用 unzip 解压
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>解压缩命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 程序后台运行的几种方法</title>
    <url>/2020/09/17/Linux/ubuntu%20%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Ubuntu-程序后台运行的几种方法"><a href="#Ubuntu-程序后台运行的几种方法" class="headerlink" title="Ubuntu 程序后台运行的几种方法"></a>Ubuntu 程序后台运行的几种方法</h1><blockquote>
<p>我们经常会碰到这样的问题，用 <code>telnet/ssh</code> 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。</p>
</blockquote>
<h2 id="nohup-setsid-amp"><a href="#nohup-setsid-amp" class="headerlink" title="nohup/setsid/&amp;"></a><code>nohup/setsid/&amp;</code></h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>我们知道，当用户注销 <code>(logout)</code> 或者网络断开时，终端会收到 <code>HUP(hangup)</code> 信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 <code>HUP</code> 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。</p>
<ol>
<li><p><code>nohup</code><br> <code>nohup</code> 无疑是我们首先想到的办法。顾名思义，<code>nohup</code> 的用途就是让提交的命令忽略 <code>hangup</code> 信号。让我们先来看一下 <code>nohup</code> 的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOHUP(1)                        User Commands                        NOHUP(1)</span><br><span class="line">NAME</span><br><span class="line">       nohup - run a command immune to hangups, with output to a non-tty</span><br><span class="line">SYNOPSIS</span><br><span class="line">       nohup COMMAND [ARG]...</span><br><span class="line">       nohup OPTION</span><br><span class="line">DESCRIPTION</span><br><span class="line">        Run COMMAND, ignoring hangup signals.</span><br><span class="line">       --help display this help and exit</span><br><span class="line">       --version</span><br><span class="line">              output version information and exit</span><br></pre></td></tr></table></figure>
<p> <code>nohup</code> 的使用是十分方便的，只需在要处理的命令前加上 <code>nohup</code> 即可，标准输出和标准错误缺省会被重定向到 <code>nohup.out</code> 文件中。一般我们可在结尾加上”&amp;”来将命令同时放入后台运行，也可用 <code>&gt;filename 2&gt;&amp;1</code> 来更改缺省的重定向文件名。<br> <code>nohup</code> 示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# nohup ping www.ibm.com &amp;</span><br><span class="line">[1] 3059</span><br><span class="line">nohup: appending output to &#39;nohup.out&#39;</span><br><span class="line">[root@pvcent107 ~]# ps -ef |grep 3059</span><br><span class="line">root      3059   984  0 21:06 pts&#x2F;3    00:00:00 ping www.ibm.com</span><br><span class="line">root      3067   984  0 21:06 pts&#x2F;3    00:00:00 grep 3059</span><br><span class="line">[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure></li>
<li><p><code>setsid</code><br> <code>nohup</code> 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 <code>HUP</code> 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。<code>setsid</code> 就能帮助我们做到这一点。让我们先来看一下 <code>setsid</code> 的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SETSID(8)                 Linux Programmer’s Manual                 SETSID(8)</span><br><span class="line">NAME</span><br><span class="line">       setsid - run a program in a new session</span><br><span class="line">SYNOPSIS</span><br><span class="line">       setsid program [ arg ... ]</span><br><span class="line">DESCRIPTION</span><br><span class="line">       setsid runs a program in a new session.</span><br></pre></td></tr></table></figure>
<p> 可见 <code>setsid</code> 的使用也是非常方便的，也只需在要处理的命令前加上 <code>setsid</code> 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# setsid ping www.ibm.com</span><br><span class="line">[root@pvcent107 ~]# ps -ef |grep www.ibm.com</span><br><span class="line">root     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com</span><br><span class="line">root     31102 29217  0 07:29 pts&#x2F;4    00:00:00 grep www.ibm.com</span><br><span class="line">[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure>
<p> 值得注意的是，上例中我们的进程 <code>ID(PID)</code> 为 31094，而它的父 <code>ID(PPID)</code> 为1（即为 <code>init</code> 进程 <code>ID</code>），并不是当前终端的进程 <code>ID</code>。请将此例与 <code>nohup</code> 例中的父 <code>ID</code> 做比较。</p>
</li>
<li><p>&amp;<br>这里还有一个关于 <code>subshell</code> 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 <code>shell</code> 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。<br><br><br>当我们将”&amp;”也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过 <code>jobs</code> 来查看的。让我们来看看为什么这样就能躲过 <code>HUP</code> 信号的影响吧。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# (ping www.ibm.com &amp;)</span><br><span class="line">[root@pvcent107 ~]# ps -ef |grep www.ibm.com</span><br><span class="line">root     16270     1  0 14:13 pts&#x2F;4    00:00:00 ping www.ibm.com</span><br><span class="line">root     16278 15362  0 14:13 pts&#x2F;4    00:00:00 grep www.ibm.com</span><br><span class="line">[root@pvcent107 ~]#</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>我们已经知道，如果事先在命令前加上 <code>nohup</code> 或者 <code>setsid</code> 就可以避免 <code>HUP</code> 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 <code>HUP</code> 信号的影响呢？</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>这时想加 <code>nohup</code> 或者 <code>setsid</code> 已经为时已晚，只能通过作业调度和 <code>disown</code> 来解决这个问题了。让我们来看一下 <code>disown</code> 的帮助信息：</p>
<pre><code>disown [-ar] [-h] [jobspec ...]
Without options, each jobspec is  removed  from  the  table  of
active  jobs.   If  the -h option is given, each jobspec is not
removed from the table, but is marked so  that  SIGHUP  is  not
sent  to the job if the shell receives a SIGHUP.  If no jobspec
is present, and neither the -a nor the -r option  is  supplied,
the  current  job  is  used.  If no jobspec is supplied, the -a
option means to remove or mark all jobs; the -r option  without
a  jobspec  argument  restricts operation to running jobs.  The
return value is 0 unless a jobspec does  not  specify  a  valid
job.
</code></pre>
<p>可以看出，我们可以用如下方式来达成我们的目的。</p>
<ul>
<li>用 <code>disown -h jobspec</code> 来使某个作业忽略 <code>HUP</code> 信号。</li>
<li>用 <code>disown -ah</code> 来使所有的作业都忽略 <code>HUP</code> 信号。</li>
<li>用 <code>disown -rh</code> 来使正在运行的作业忽略 <code>HUP</code> 信号。</li>
</ul>
<p>需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用 <code>ps -ef</code> 查找到它。<br><br><br>但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了”&amp;”来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过jobs命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 <code>CTRL-z</code>（按住Ctrl键的同时按住z键）了！<br><code> CTRL-z</code> 的用途就是将当前进程挂起 <code>(Suspend)</code>，然后我们就可以用jobs命令来查询它的作业号，再用 <code>bg jobspec</code> 来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。<br><br><code> disown</code> 示例1（如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用 <code>disown</code> ）</p>
<pre><code>[root@pvcent107 build]# cp -r testLargeFile largeFile &amp;
[1] 4825
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile
root      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile
root      4853   968  0 09:46 pts/4    00:00:00 grep largeFile
[root@pvcent107 build]# logout
</code></pre>
<p><code>disown</code> 示例2（如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 <code>CTRL-z</code> 和 <code>bg</code> 将其放入后台，再使用 <code>disown</code>）</p>
<pre><code>[root@pvcent107 build]# cp -r testLargeFile largeFile2

[1]+  Stopped                 cp -i -r testLargeFile largeFile2
[root@pvcent107 build]# bg %1
[1]+ cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile2
root      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2
root      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2
[root@pvcent107 build]#
</code></pre>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a><strong>场景</strong></h3><p>我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>此时最方便的方法就是 <code>screen</code> 了。简单的说，<code>screen</code> 提供了 <code>ANSI/VT100</code> 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。<code>screen</code> 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 <code>screen</code> 能够避免 <code>HUP</code> 信号的影响。我们先看一下 <code>screen</code> 的帮助信息：</p>
<pre><code>SCREEN(1)                                                           SCREEN(1)
NAME
       screen - screen manager with VT100/ANSI terminal emulation
SYNOPSIS
       screen [ -options ] [ cmd [ args ] ]
       screen -r [[pid.]tty[.host]]
       screen -r sessionowner/[[pid.]tty[.host]]
DESCRIPTION
       Screen  is  a  full-screen  window manager that multiplexes a physical
       terminal between several  processes  (typically  interactive  shells).
       Each  virtual  terminal provides the functions of a DEC VT100 terminal
       and, in addition, several control functions from the  ISO  6429  (ECMA
       48,  ANSI  X3.64)  and ISO 2022 standards (e.g. insert/delete line and
       support for multiple character sets).  There is a  scrollback  history
       buffer  for  each virtual terminal and a copy-and-paste mechanism that
       allows moving text regions between windows.
</code></pre>
<p>使用 <code>screen</code> 很方便，有以下几个常用选项：</p>
<ul>
<li><p>用 <code>screen -dmS session name</code> 来建立一个处于断开模式下的会话（并指定其会话名）。</p>
</li>
<li><p>用 <code>screen -ls</code> 来列出所有会话。</p>
</li>
<li><p>用 <code>screen -r session name</code> 来重新连接指定会话。</p>
</li>
<li><p>用快捷键 <code>CTRL-a d</code> 来暂时断开当前会话。<br><code>screen</code> 示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# screen -dmS Urumchi</span><br><span class="line">[root@pvcent107 ~]# screen -ls</span><br><span class="line">There is a screen on:</span><br><span class="line">        12842.Urumchi   (Detached)</span><br><span class="line">1 Socket in &#x2F;tmp&#x2F;screens&#x2F;S-root.</span><br><span class="line">[root@pvcent107 ~]# screen -r Urumchi</span><br></pre></td></tr></table></figure>
<p>当我们用“-r”连接到 <code>screen</code> 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 <code>HUP</code> 信号会对我们的进程造成影响，也不用给每个命令前都加上 <code>nohup</code> 或者 <code>setsid</code> 了。这是为什么呢？让我来看一下下面两个例子吧。</p>
</li>
</ul>
<ol>
<li>未使用 screen 时新进程的进程树 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# ping www.google.com &amp;</span><br><span class="line">[1] 9499</span><br><span class="line">[root@pvcent107 ~]# pstree -H 9499</span><br><span class="line">init─┬─Xvnc</span><br><span class="line">     ├─acpid</span><br><span class="line">     ├─atd</span><br><span class="line">     ├─2*[sendmail]</span><br><span class="line">     ├─sshd─┬─sshd───bash───pstree</span><br><span class="line">     │       └─sshd───bash───ping</span><br></pre></td></tr></table></figure>
<pre><code> 我们可以看出，未使用 screen 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 ping 进程）。
</code></pre>
</li>
<li>使用了 <code>screen</code> 后新进程的进程树 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@pvcent107 ~]# screen -r Urumchi</span><br><span class="line">[root@pvcent107 ~]# ping www.ibm.com &amp;</span><br><span class="line">[1] 9488</span><br><span class="line">[root@pvcent107 ~]# pstree -H 9488</span><br><span class="line">init─┬─Xvnc</span><br><span class="line">     ├─acpid</span><br><span class="line">     ├─atd</span><br><span class="line">     ├─screen───bash───ping</span><br><span class="line">     ├─2*[sendmail]</span><br></pre></td></tr></table></figure>
<pre><code> 而使用了 screen 后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。
</code></pre>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。<code>nohup/setsid</code> 无疑是临时需要时最方便的方法，<code>disown</code> 能帮助我们来事后补救当前已经在运行了的作业，而 <code>screen</code> 则是在大批量操作时不二的选择了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>后台运行</tag>
      </tags>
  </entry>
  <entry>
    <title>java技巧-获取当前系统的换行符</title>
    <url>/2020/09/14/Java/%E5%B0%8F%E6%8A%80%E5%B7%A7/java%E6%8A%80%E5%B7%A7-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="java技巧-获取当前系统的换行符"><a href="#java技巧-获取当前系统的换行符" class="headerlink" title="java技巧-获取当前系统的换行符"></a>java技巧-获取当前系统的换行符</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 换行符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String NEW_LINE = System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>java技巧-获取支持的算法和算法支持的模式</title>
    <url>/2020/09/14/Java/%E5%B0%8F%E6%8A%80%E5%B7%A7/java%E6%8A%80%E5%B7%A7-%E8%8E%B7%E5%8F%96%E6%94%AF%E6%8C%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E6%94%AF%E6%8C%81%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="java技巧-获取支持的算法和算法支持的模式"><a href="#java技巧-获取支持的算法和算法支持的模式" class="headerlink" title="java技巧-获取支持的算法和算法支持的模式"></a>java技巧-获取支持的算法和算法支持的模式</h1><ol>
<li><p>获得所有支持的算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Provider provider : Security.getProviders())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Provider: &quot;</span> + provider.getName());</span><br><span class="line">    <span class="keyword">for</span> (Provider.Service service : provider.getServices())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  Algorithm: &quot;</span> + service.getAlgorithm());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获得算法支持的模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Provider provider : Security.getProviders()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Provider: &quot;</span> + provider.getName());</span><br><span class="line">    <span class="keyword">for</span> (Provider.Service service : provider.getServices()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  Algorithm  Pattern: &quot;</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/2020/11/12/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><img src="/2020/11/12/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B/extend.png"></p>
<blockquote>
<p>继承关系如上，其中Container为泛型容器</p>
</blockquote>
<h3 id="泛型参数命名约定"><a href="#泛型参数命名约定" class="headerlink" title="泛型参数命名约定"></a>泛型参数命名约定</h3><p>类型参数一般使用一个大写的字母表示，经常使用的类型参数的名称有</p>
<ul>
<li>E: Element（广泛的用于Java Collection中）</li>
<li>K: Key</li>
<li>V: Value</li>
<li>N: Number</li>
<li>T: Type</li>
<li>S,U,V: 第2, 3, 4个类型参数</li>
</ul>
<h3 id="泛型擦除的具体事实"><a href="#泛型擦除的具体事实" class="headerlink" title="泛型擦除的具体事实"></a>泛型擦除的具体事实</h3><ul>
<li>虚拟机没有泛型，只有普通的类和方法</li>
<li>所有类型参数都用他们的限定类型替换</li>
<li>桥方法被合成来保持多态</li>
<li>为保证类型安全性，必要时插入强制类型转换</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>由于泛型擦除的原因，相较于真泛型的语言（C#、C++）来说，方法区只需要加载较少字节码，内存负担较少</li>
<li>由于java1.5才开始支持泛型，相对于其它语言对旧版本代码兼容性更好</li>
</ol>
<p>缺点：</p>
<ol>
<li>基本类型无法作为泛型实参，会有装箱拆箱的额外消耗</li>
<li>泛型无法当作真实存在的类型进行处理，如数组<code>new T[]</code>、新建泛型对象<code>new T()</code>、方法重载等【注：C#的List<String>和List<Int>是不同的类型】</Int></String></li>
<li>在实际使用中需要类型强转，有运行时的开销，字节码：CHECKCAST ….</li>
<li>泛型信息是通过字节码注释实现的，混淆时不做keep的话会被清除掉</li>
</ol>
<h3 id="字节码是如何记录泛型信息的"><a href="#字节码是如何记录泛型信息的" class="headerlink" title="字节码是如何记录泛型信息的"></a>字节码是如何记录泛型信息的</h3><p>在编译字节码时会在字节码上打上<code>signature</code>注释和<code>declaration</code>注释</p>
<p><img src="/2020/11/12/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E4%BF%9D%E7%95%99%E4%BF%A1%E6%81%AF.png"></p>
<p>可以通过相关的反射代码进行获取</p>
<p><strong>注意：混淆时会把这些注释给清除，代码上需要用到这些信息时需要在混淆文件中keep住：-keepattributes Signature</strong></p>
<blockquote>
<p>在Retrofit这个库中有使用到</p>
</blockquote>
<h3 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h3><h5 id="构建泛型数组"><a href="#构建泛型数组" class="headerlink" title="构建泛型数组"></a>构建泛型数组</h5><p>直接通过new数组的方式是不允许的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] ts = <span class="keyword">new</span> T[<span class="number">10</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>一种简单实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] minmax(T... t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">String[] minmax = minmax(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// 这是允许的</span></span><br></pre></td></tr></table></figure>

<p>java8起的一种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] minmax(IntFunction&lt;T[]&gt; constr, T... t) &#123;</span><br><span class="line">    T[] ts = constr.apply(t.length);</span><br><span class="line">    System.arraycopy(t, <span class="number">0</span>, ts, <span class="number">0</span>, t.length);</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line">String[] minmax = minmax(String[]::<span class="keyword">new</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// 这是允许的</span></span><br></pre></td></tr></table></figure>

<p>java8之前的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] minmax(T... t) &#123;</span><br><span class="line">    T[] ts = (T[]) Array.newInstance(t.getClass().getComponentType(), t.length);</span><br><span class="line">    System.arraycopy(t, <span class="number">0</span>, ts, <span class="number">0</span>, t.length);</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line">String[] minmax = minmax(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// 这是允许的</span></span><br></pre></td></tr></table></figure>

<p>这也是内置方法<code>Arrays.copyOf()</code>实现的一种方式</p>
<h5 id="消除对受查异常的检查"><a href="#消除对受查异常的检查" class="headerlink" title="消除对受查异常的检查"></a>消除对受查异常的检查</h5><p>如果一个方法抛出受查异常，外部调用这个方法需要try或者继续向外出，如下test方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过泛型中间方法， 这样外部调用test方法时不用检查该异常，即不用try</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中间方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span>(T) e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    throwAs(<span class="keyword">new</span> FileNotFoundException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java和Kotlin中泛型的协变、逆变和不变"><a href="#Java和Kotlin中泛型的协变、逆变和不变" class="headerlink" title="Java和Kotlin中泛型的协变、逆变和不变"></a>Java和Kotlin中泛型的协变、逆变和不变</h3><h5 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h5><ul>
<li>什么是泛型的型变（协变、逆变、不型变）</li>
<li>为什么需要泛型的型变</li>
<li>Java和Kotlin分别是如何处理泛型型变的</li>
</ul>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><blockquote>
<p>型变是指我们是否允许对参数类型进行子类型转换</p>
</blockquote>
<p>假设Apple类是Fruit类的子类，Container<T> 是一个泛型类，那么，Container<Apple> 是 Container<Fruit> 的子类型吗？答案是No。对于Java而言，两者没有关系。对于Kotlin而言，Container<Apple>可能是Container<Fruit>的子类型，或者其超类型，或者两者没有关系，这取决于Container<T>中的 T 在类Container中是如何使用的。简单来说，型变就是指 Container<Apple> 和 Container<Fruit> 是什么关系这个问题，对于不同的答案，有如下几个术语。</Fruit></Apple></T></Fruit></Apple></Fruit></Apple></T></p>
<ul>
<li><strong>invariance（不型变）：</strong>也就是说，Container<Apple> 和 Container<Fruit> 之间没有关系</Fruit></Apple></li>
<li><strong>covariance（协变）：</strong>也就是说，Container<Apple> 是 Container<Fruit> 的子类型</Fruit></Apple></li>
<li><strong>contravariance（逆变）：</strong>也就是说，Container<Fruit> 是 Container<Apple> 的子类型</Apple></Fruit></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>上面在解释协变、逆变概念时的说法只是为了帮助理解，这种说法对于Java而言并不准确。在Java中，Container<Apple> 和 Container<Fruit> 永远没有关系，对于协变应该这么说， Container<Apple> 是 Container&lt;? extends Fruit&gt; 的子类型，逆变则是，Container<Fruit> 是 Container&lt;? super Apple&gt; 的子类型。</Fruit></Apple></Fruit></Apple></li>
<li><strong>子类（subclass）</strong> 和 <strong>子类型（subtype）</strong>不是一个概念，子类一定是子类型，子类型不一定是子类，例如，Container<Apple> 是 Container&lt;? extends Fruit&gt; 的子类型，但是Container<Apple> 并不是 Container&lt;? extends Fruit&gt; 的子类。</Apple></Apple></li>
</ul>
<h5 id="Java的默认做法"><a href="#Java的默认做法" class="headerlink" title="Java的默认做法"></a>Java的默认做法</h5><p>Java中的泛型类在正常使用时是不型变的，要想型变必须在使用处通过通配符进行（称为使用处型变）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Container&lt;Apple&gt; apple = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">Container&lt;Fruit&gt; fruit = apple; <span class="comment">// java默认禁止此类操作</span></span><br></pre></td></tr></table></figure>

<p>禁止这么做主要目的是为了保证运行时的类型安全。</p>
<h5 id="Java的协变做法"><a href="#Java的协变做法" class="headerlink" title="Java的协变做法"></a>Java的协变做法</h5><p>采用<strong>上界</strong>通配符extends，允许Container<Apple>向上转型成为Container<Fruit>的子类型，允许正常使用生产者方法如getT，但消费者方法是不允许的如setT</Fruit></Apple></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Container&lt;Apple&gt; apple = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">Container&lt;? extends Fruit&gt; fruit = apple; <span class="comment">// 这是允许的</span></span><br><span class="line">Fruit t = fruit.getT(); <span class="comment">// 取也是允许的</span></span><br><span class="line">fruit.setT(<span class="keyword">new</span> Apple());<span class="comment">// 存是不允许的</span></span><br></pre></td></tr></table></figure>

<p>之所以允许调用生产者方法，是因为能够明确知道返回的是Fruit类型，但是消费者方法编译器并不知道它的具体类型是什么，有可能是Apple转型得到的，也有可能是Orange转型得到的，为了保证类型安全，编译器拒绝任何消费者方法。<strong>使得像&lt;? extends Fruit&gt;成为单纯的“生产者”</strong></p>
<p>但是这里产生了一个<strong>问题</strong>，类似于ListArray的contains方法，我们能明确知道内部的逻辑不会修改List中的对象，但是编译器还是拒绝了该方法的正常使用，所以只能写成<code>boolean contains(Object o)</code>的形式。<strong>不过没关系，Kotlin能很好的解决。</strong></p>
<h5 id="Java的逆变做法"><a href="#Java的逆变做法" class="headerlink" title="Java的逆变做法"></a>Java的逆变做法</h5><p>采用<strong>下界</strong>通配符super，允许Container<Food>向下转型成为Container<Fruit>的子类型，允许正常使用消费者方法，但是生产者方法只能返回Object类型</Fruit></Food></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Container&lt;Object&gt; obj = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">Container&lt;? <span class="keyword">super</span> Fruit&gt; fruit = obj; <span class="comment">// 这是允许的</span></span><br><span class="line">Container&lt;Plant&gt; plant = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">fruit = plant; <span class="comment">// 这是允许的</span></span><br><span class="line">Container&lt;Food&gt; food = <span class="keyword">new</span> Container&lt;&gt;();</span><br><span class="line">fruit = food; <span class="comment">// 这也是允许的</span></span><br><span class="line">fruit.setT(<span class="keyword">new</span> Apple());</span><br><span class="line">fruit.setT(<span class="keyword">new</span> Orange());</span><br><span class="line">fruit.setT(<span class="keyword">new</span> Fruit());</span><br><span class="line">Object t = fruit.getT();</span><br></pre></td></tr></table></figure>

<p>允许向消费者方法传入Fruit及其子类，是因为编译器知道，Fruit及其子类一定属于Fruit或者Fruit的父类，与协变相反的是，由于编译器不知道是Plant类型转型得到的，还是Food转型得到的，甚至是Object转型得到的，所以调用生产者方法只能返回Object类型。<strong>使得像&lt;? super Fruit&gt;成为单纯的“消费者”</strong></p>
<h5 id="Java型变总结"><a href="#Java型变总结" class="headerlink" title="Java型变总结"></a>Java型变总结</h5><blockquote>
<p>extends限定了通配符类型的上界，所以我们可以安全地从其中读取；而super限定了通配符类型的下界，所以我们可以安全地向其中写入。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collections copy方法的泛型使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Kotlin的做法"><a href="#Kotlin的做法" class="headerlink" title="Kotlin的做法"></a>Kotlin的做法</h5><p>Kotlin处理型变的做法概括起来是：Kotlin中的泛型类在定义时即可标明型变类型（协变或逆变，当然也可以不标明，那就是不型变的），在使用处可以直接型变（称为<strong>声明处型变</strong>）。因为Kotlin与Java是100%兼容的，你自己在Kotlin中定义的泛型类当然可以享受声明处型变的方便，但是，如果引入Java库呢？又或者你自己在Kotlin中定义的泛型类恰好是不型变的，然而你又想像Java那样在<strong>使用处型变</strong>，该这么办呢？Kotlin使用一种称为 <strong>类型投影（type projections</strong>） 的方式来处理这种型变。这种方式其实跟Java处理型变的方式类似，只是换了一种说法，还是使用处型变。</p>
<h5 id="Kotlin的协变"><a href="#Kotlin的协变" class="headerlink" title="Kotlin的协变"></a>Kotlin的协变</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(oranges: <span class="type">Source</span>&lt;<span class="type">Orange</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fruits: Source&lt;Fruit&gt; = oranges <span class="comment">// 没问题，因为 T 是一个 out-参数，Source&lt;T&gt;是协变的</span></span><br><span class="line">    <span class="keyword">val</span> oneFruit: Fruit = fruits.nextT() <span class="comment">//可以安全读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用out修饰符，表明类型参数 T 在泛型类中仅作为方法的返回值，不作为方法的参数，因此，这个泛型类是个协变的。回报是，使用时Source<Orange>可以作为Source<Fruit>的子类型。</Fruit></Orange></p>
<p>上面有提到，Java的协变中，向不会修改内容的方法<strong>contains</strong>声明参数为泛型T会无法使用。在Kotlin中能够通过<strong>注解</strong>声明的方式解决</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="type">out E</span>&gt; : <span class="type">Iterable</span>&lt;<span class="type">E</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(element: @<span class="type">UnsafeVariance</span> <span class="type">E</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用注解 <code>@UnsafeVariance</code> 可以让编译器放我们一马，它是在告诉编译器，我保证这个方法不会向泛型类写入数据，你放心。</p>
<h5 id="Kotlin中的逆变"><a href="#Kotlin中的逆变" class="headerlink" title="Kotlin中的逆变"></a>Kotlin中的逆变</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Comparable</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Comparable</span>&lt;<span class="type">Number</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> y: Comparable&lt;<span class="built_in">Double</span>&gt; = x <span class="comment">// OK！逆变，Comparable&lt;Number&gt;可以作为Comparable&lt;Double&gt;的子类型</span></span><br><span class="line">    y.compareTo(<span class="number">1.0</span>) <span class="comment">//1.0 拥有类型 Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用in修饰符，表明类型参数 T 在泛型类中仅作为方法的参数，不作为方法的返回值，因此，这个泛型类是个逆变的。回报是，使用时Comparable<Number>可以作为Comparable<Double>的子类型。</Double></Number></p>
<p><strong>注意：</strong>以上所说的in/out修饰符对于类型参数 T 的限制，仅适用于非private（public, protected, internal）函数，对于private函数，类型参数 T 可以存在于任意位置，毕竟private函数仅用于内部调用，不会对泛型类的协变、逆变性产生影响。还有一点例外就是，如果类型参数 T 标记为out，我们仍可以在构造函数的参数中使用它，因为构造函数仅用于实例化，之后不能被调用，所以也不会破坏泛型类的协变性。</p>
<h3 id="扩展-堆污染"><a href="#扩展-堆污染" class="headerlink" title="扩展-堆污染"></a>扩展-堆污染</h3><blockquote>
<p>Heap pollution(堆污染), 指的是当把一个不带泛型的对象赋值给一个带泛型的变量时, 就有可能发生堆污染。</p>
<p>由于定义带泛型变量时并不强制指定泛型类型, 因此如果借此发生狸猫换太子的操作的话, 那么就会导致堆污染. 堆污染在编译时并不会报错, 只会在编译时提示有可能导致堆污染的警告. 在运行时,如果发生了堆污染, 那么就会抛出类型转换异常。</p>
</blockquote>
<h5 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义时未指定泛型类型</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将无泛型对象复制给指定类型变量，此处已经发生堆污染</span></span><br><span class="line">List&lt;String&gt; strList = list;</span><br><span class="line">String s = strList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h5 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h5><blockquote>
<p>java语言不允许创建泛型数组，所以当可变参数为带泛型的可变数组时，方法内只能用不带泛型的数组接收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class="line">    Object[] array = stringLists;</span><br><span class="line">    List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 此处发生堆污染</span></span><br><span class="line">    array[<span class="number">0</span>] = tmpList;</span><br><span class="line">    String s = stringLists[<span class="number">0</span>].get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="忽略堆污染警告"><a href="#忽略堆污染警告" class="headerlink" title="忽略堆污染警告"></a>忽略堆污染警告</h5><p>在方法上进行注解声明，让编译器不提示警告</p>
<ul>
<li><code>@SuppressWarnings(&quot;unchecked&quot;)</code>：取消所有警告</li>
<li><code>@SafeVarargs</code>：Java7 专门用来抑制堆污染(Heap pollution)警告提供的注解</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2020/11/08/Java/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="java知识点-注解"><a href="#java知识点-注解" class="headerlink" title="java知识点-注解"></a>java知识点-注解</h1><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><pre><code>元注解
public @interface 注解名称&#123;
    属性列表;
&#125;
</code></pre>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote>
<p>注解本质上就是一个接口，该接口默认继承Annotation接口<br>public interface TestAnnotation extends java.lang.annotation.Annotation {}<br>可通过<br>编译：javac 类全路径<br>反编译：javap class文件<br>得到确认</p>
</blockquote>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>要求：
    1.属性返回值类型有一下要求
        * 基本数据类型
        * String
        * 枚举
        * 注解
        * 以上类型的数组
        例：
            import java.util.concurrent.TimeUnit;
            public @interface TestAnnotation &#123;
                int value();
                String value2();
                TimeUnit value3();
                Override value4();
                int[] value5();
                String[] value6();
                TimeUnit[] value7();
                Override[] value8();
            &#125;

    2.定义属性，在使用时需要给属性赋值(属性名 = 返回值)
        例：
            public @interface TestAnnotation&#123;
                int value();
            &#125;
            使用
            @TestAnnotation(value = 1)
            public class TestClass&#123;
            &#125;

        1.如果只有一个属性需要赋值，并且属性名称为value，则value可以省略，直接定义值即可
            @TestAnnotation(1)
            public class TestClass&#123;
            &#125;

        2.如果定义属性时，用default关键字给属性默认初始化值，在使用时可不赋值
        例：
            public @interface TestAnnotation&#123;
                int value() default 0;
            &#125;
            使用
            @TestAnnotation()
            public class TestClass&#123;
            &#125;
        3.数组赋值时，使用&#123;&#125;包裹，如果数组只有一个值，则可以省略
        例：
            public @interface TestAnnotation&#123;
                int[] value();
                String[] value2();
            &#125;
            使用
            @TestAnnotation(value = 1, value2=&#123;&quot;0&quot;, &quot;1&quot;&#125;)
            public class TestClass&#123;
            &#125;
        4.无属性可以直接使用
        例：
            public @interface TestAnnotation&#123;
            &#125;
            使用
            @TestAnnotation()
            public class TestClass&#123;
            &#125;
</code></pre>
<h3 id="元注解，有四种类型"><a href="#元注解，有四种类型" class="headerlink" title="元注解，有四种类型"></a>元注解，有四种类型</h3><pre><code>* @Target：描述注解能够作用的位置
    * ElementType取值：
        * TYPE：可以作用于类、接口、enum上
        * METHOD：可以作用于方法上
        * FIELD：可以作用于成员变量上
        * CONSTRUCTOR：构造器
        * LOCAL_VARIABLE：局部变量声明
        * PACKAGE：包声明
        * PARAMETER：参数声明

* @Repeatable：表示注解在同一位置可以出现多次   

* @Retention：描述注解被保留的阶段
    * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
    * @Retention(RetentionPolicy.CLASS)：当前被描述的注解，会保留到class字节码文件中，JVM无法读取到
    * @Retention(RetentionPolicy.SOURCE)：当前被描述的注解，仅存在源码中

* @Documented：描述注解是否被抽取到api文档中

* @Inherited：描述在父类描述注解子类能否被继承，仅针对类，接口上声明并不会生效
</code></pre>
<h3 id="提取注解"><a href="#提取注解" class="headerlink" title="提取注解"></a>提取注解</h3><pre><code>需要实现java.lang.reflect.AnnotatedElement接口才可提取

已知实现类
Class
Constructor
Field
Method
Package

获取方法
getAnnotation:返回指定类型的注解，不存在返回null
getAnnotations:返回存在的所有注解
isAnnotationPresent:判断是否包含指定类型的注解
getDeclaredAnnotations:返回直接存在于此元素上的所有注解
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2020/11/10/Java/%E7%BA%BF%E7%A8%8B/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><blockquote>
<p>每个线程单独存储自己的数据，具有线程隔离的效果</p>
</blockquote>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>每一个Thread维护一个<code>ThreadLocalMap</code>，通过<code>ThreadLocal</code>这个载体，在使用时变量为空则先创建<code>ThreadLocalMap</code>并赋值给线程再使用；<code>ThreadLocalMap</code>内部维护<code>table</code>数组，所有的数据都存在这里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<span class="comment">// 这里有内存泄漏的风险</span></span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以对应的关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程与ThreadLocal:一对多</span><br><span class="line">线程与ThreadLocalMap：一对一</span><br></pre></td></tr></table></figure>

<p>值得注意的是，每次<code>new ThreadLocal</code>时，都会对散列code自增一个固定值，来使算出的结果更为分布</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();<span class="comment">// 每new一个都会自增一个固定值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解决哈希冲突的方式"><a href="#解决哈希冲突的方式" class="headerlink" title="解决哈希冲突的方式"></a>解决哈希冲突的方式</h5><p>使用<strong>开放地址法</strong>解决哈希冲突</p>
<p><strong>哈希冲突解决方式：</strong></p>
<ol>
<li><strong>开放地址法：</strong>即假设索引15已经存在值且key不同，则会查看索引16为空则设置进去，否则继续下一个索引</li>
<li><strong>链表法：</strong>在冲突的地方以链表的形式存储：<code>HashMap</code></li>
<li><strong>再哈希法：</strong>使用不同的哈希函数再次哈希直到不再冲突为止，缺点是增加了计算哈希的时间</li>
<li><strong>建立公共溢出区：</strong>当发生冲突时，将冲突的数据统一放到溢出区</li>
</ol>
<h5 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h5><p>如果一个<code>ThreadLocal</code>不存在外部<strong>强引用</strong>，则key会被GC回收，这样会导致<code>ThreadLocalMap</code>中的<code>tables</code>数组里key为null，而value为强引用；除非线程退出或者调用<code>get()/set()/remove()</code>等方法触发清除，才会断开对value的强引用。</p>
<p>总结就是因为<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，没有手动删除数据造成的内存泄漏</p>
<p><strong>解决方式：</strong>每次用完<code>ThreadLocal</code>时都调用<code>remove()</code>方法清除数据集</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程通用</title>
    <url>/2020/11/10/Java/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%94%A8/</url>
    <content><![CDATA[<h1 id="线程通用"><a href="#线程通用" class="headerlink" title="线程通用"></a>线程通用</h1><h5 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h5><blockquote>
<p>早期版本中线程提供stop方法来终止线程，但该方法已经被弃用</p>
<p>取而代之的是外部通知该线程应该结束了，但是具体什么时候结束交由线程自己控制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束线程</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 外部通知线程中断</span></span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>

<p>注意一：如果在<code>Thread.sleep()</code>等会抛出<code>InterruptedException</code>受查异常等内置函数后面调用<code>Thread.currentThread().isInterrupted()</code>返回false</p>
<p>注意二：<code>Thread.interrupted()</code>线程静态函数会将中断状态清空，与<code>Thread.currentThread().isInterrupted(true)</code>效果一致</p>
<h5 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock mLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 可重入锁对象</span></span><br><span class="line">Condition mCondition = mLock.newCondition(); <span class="comment">// 锁对象创建条件对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLokc.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">//未达到条件) &#123;</span></span><br><span class="line">            mCondition.await(); <span class="comment">// 临时释放锁并进入阻塞状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do somethind</span></span><br><span class="line">        mCondition.signalAll(); <span class="comment">//通知释放阻塞状态的地方允许重新获得锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一：ReentrantLock 可多次调用lock()函数，但必须与unlock()函数成对出现</p>
<p>注意二：条件对象await必须是已经获得锁后调用，不然会爆出IllegalMonitorStateException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">//未达到条件) &#123;</span></span><br><span class="line">            wait(); <span class="comment">// 临时释放锁并进入阻塞状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do somethind</span></span><br><span class="line">        notifyAll(); <span class="comment">// 通知释放阻塞状态的地方允许重新获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方式与锁对象方式一模一样</p>
<p>值得注意的是，条件对象调用的是**await()<strong>方法，同步方法调用的是</strong>wait()**方法，别用错了</p>
<h5 id="volatile域"><a href="#volatile域" class="headerlink" title="volatile域"></a>volatile域</h5><p>作用：内存可见性、禁止指令重排序</p>
<p>JVM要求实现volatile必须要实现内存屏障，最终调用汇编指令为：<code>lock addl</code>，由于<code>lock</code>指令后面必须跟一条指令，但是Intel限制了<code>lock</code>指令不能跟<code>nop(空指令)</code>，所以后面添加了一个<code>addl(加0指令)</code></p>
<blockquote>
<p>LOCK 用于多处理器中执行指令时对共享内存的独占使用</p>
<p>他的作用时能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器缓存失效</p>
<p><strong>另外还提供了有序的指令无法越过内存屏障的作用，即lock指令前面的指令都无法越过这条指令</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (os::<span class="built_in">is_mp</span>()) &#123;<span class="comment">// 是否是多核cpu，可见volatile在单核cpu里并没有使用lock指令</span></span><br><span class="line">	<span class="comment">// 使用lock指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存屏障（JVM层面）</strong></p>
<p>写：<code>StoreStore</code> - <code>volatile写</code> - <code>StoreLoad</code></p>
<p>读：<code>volatile读</code> - <code>LoadStore</code> - <code>LoadLoad</code></p>
<h5 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h5><p>除了使用锁或<code>volatitle</code>修饰符，还有一种情况可以安全地访问一个共享域，即将该域声明为final：</p>
<p><code>final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</code></p>
<p>其它线程会在构造函数完成构造后才看到这个map变量</p>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>Unsafe内部最终调用汇编语句：多核：<code>lock cmpxchg</code> 单核：<code>cmpxchg</code></p>
<p><code>cmpxchg</code>：比较并交换操作数</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><blockquote>
<p><code>java.util.concurrent.atomic</code>包中有很多类使用高效的机器级指令来保证操作的原子性。</p>
<p>如：<code>AtomicInteger</code>的<code>getAndIncrement</code>和<code>incrementAndGet</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger integer = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">integer.set(Math.max(integer.get(), number));<span class="comment">//该操作不具有原子性，无法保证值的正常更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    oldValue = integer.get();</span><br><span class="line">    newValue = Math.max(oldValue, number)</span><br><span class="line">&#125; <span class="keyword">while</span>(!integer.compareAndSet(oldValue, newValue)); <span class="comment">// 需要通过比对再设值的方式保证原子性，CAS</span></span><br><span class="line"><span class="comment">// java8 可以通过内置函数免写以上循环操作，如updateAndGet、accumulateAndGet等函数</span></span><br></pre></td></tr></table></figure>

<p>注意一：如果大量线程要访问相同的类名开头为Atomic的原子值，性能会大幅下降，因为采用CAS乐观更新需要太多的循环重试操作。可通过类<code>LongAddr</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>和<code>DoubleAccumulator</code>来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原理：采用多个变量（加数），其总和为当前值。可以有多个线程同时更新不同的加数，线程增加会自动提供新的加数。</span></span><br><span class="line"><span class="comment">// 只有当所有工作都完成之后才需要总和的值，这个情况下该类操作会相当高效</span></span><br><span class="line">LongAdder adder</span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    adder.increment();<span class="comment">// 不会返回值，这样做回消除求和分解到多个加数所带来的性能提升</span></span><br><span class="line">	<span class="comment">// long total = adder.sum();// 不推荐这么操作，会失去性能的提升，如必须该操作，则使用Atomic会更好</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> total = adder.sum();</span><br></pre></td></tr></table></figure>

<p>注意二：上述提到CAS操作更新会存在ABA的异常，可通过<code>AtomicStampedReference</code>带版本号的原子类进行修复</p>
<p>让自己的类具有原子性：<code>AtomicReference</code>和<code>AtomicReferenceFieldUpdater</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicReference</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用AtomicReference对字符串进行封装</span></span><br><span class="line">    AtomicReference&lt;String&gt; atomicValue = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;HelloAtomic&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAtomicClass holder = <span class="keyword">new</span> MyAtomicClass();</span><br><span class="line">    holder.atomicValue.compareAndSet(<span class="string">&quot;HelloAtomic&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">	System.out.println(holder.atomicValue.get());</span><br><span class="line">	String value = holder.atomicValue.updateAndGet(<span class="keyword">new</span> UnaryOperator&lt;String&gt;() &#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;);</span><br><span class="line">  	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicReferenceFieldUpdater</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAtomicClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为value字段添加原子操作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;SimpleValueHolder, String&gt; valueUpdater</span><br><span class="line">        =  AtomicReferenceFieldUpdater.newUpdater(SimpleValueHolder.class, String.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用volatile声明</span></span><br><span class="line">	<span class="keyword">volatile</span> String value = <span class="string">&quot;HelloAtomic&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAtomicClass holder = <span class="keyword">new</span> MyAtomicClass();</span><br><span class="line">    holder.valueUpdater.compareAndSet(holder, <span class="string">&quot;HelloAtomic&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    System.out.println(holder.valueUpdater.get(holder));</span><br><span class="line">    String value = holder.valueUpdater.updateAndGet(holder, <span class="keyword">new</span> UnaryOperator&lt;String&gt;() &#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;);</span><br><span class="line">  	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AtomicReference</strong>与<strong>AtomicReferenceFieldUpdater</strong>的区别：</p>
<blockquote>
<p>两者的作用差不多，<code>AtomicReference</code>对字段进行包裹，<code>AtomicReferenceFieldUpdater</code>则为静态扩展字段功能</p>
<p><code>AtomicReference</code>和<code>AtomicReferenceFIeldUpdater</code>比起来，要多创建一个对象<br>对于 32 位的机器，这个对象的头占 12 个字节，它的成员占 4 个字节，也就是多出来 16 个字节<br>对于 64 位的机器，如果启动了指针压缩，那这个对象占用的也是 16 个字节<br>对于 64 位的机器，如果没启动指针压缩，那么这个对象就会占 24 个字节，其中对象头占 16 个字节，成员占 8 个字节</p>
<p>当要使用<code>AtomicReference</code>创建成千上万个对象时，这个开销就会变得很大</p>
<p>因为开销的原因，一般在实例较少的情况下如单例才会选择<code>AtomicReference</code>，不然推荐使用<code>AtomicReferenceFieldUpdater</code></p>
</blockquote>
<h5 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h5><p>线程间共享变量存在不同步异常问题，有些情况并不推荐使用共享变量，如：<code>SimpleDateFormat</code>类不是线程安全的。</p>
<p>假设有静态变量：</p>
<p><code>public static final SimpleDateFormat dateFormat = new SimpleDateForniat(&quot;yyyy-MM-dd&quot;)；</code></p>
<p>如果有两个线程同时执行以下操作</p>
<p><code>String dateStamp = dateFormat.format(new DateO);</code></p>
<p>结果可能会混乱，因为<code>dateFormat</code>内部数据可能会被并发的访问所破会。当然可以在该函数使用同步锁，但开销会很大，或者再使用时构造一个局部<code>SimpleDateForniat</code>对象，不过会有点浪费。</p>
<p>推荐为每个线程构造实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; initial = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>));<span class="comment">// 在使用时才会初始化SimpleDateFormat</span></span><br><span class="line">SimpleDateFormat simpleDateFormat = initial.get();</span><br></pre></td></tr></table></figure>

<p>在多个线程中生成随机数也存在类似的问题。Random类是线程安全的，但是如果多个线程需要等待一个共享的随机数生成器会很低效。</p>
<p>可以通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalRandom.current().nextInt()</span><br></pre></td></tr></table></figure>

<p>来解决此问题</p>
<h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><p>如果得不到锁可以执行其它逻辑，可以通过<strong>tryLock</strong>的方式获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mlock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可为<strong>tryLock</strong>添加超时逻辑,<code>mlock.tryLock(100,TimeUnit.MILLISECONDS)</code></p>
<p><code>lockInterruptibly</code>相当于无限时长的<code>tryLock</code></p>
<p>同样锁条件也可在等待时添加超时，<code>condition.await(100,TimeUnit.MILLISECONDS)</code></p>
<p><code>awaitUninterruptibly</code>相当于无限时长的<code>await</code>，但是不会抛出异常</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>在频繁读取少变更的情况下，可以使用读写锁来提高性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> data)</span> </span>&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><ol>
<li><p>通过<code>Executors</code>生成线程池</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程，空闲线程会被保留60 秒</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>该池包含固定数量的线程，空闲线程会一直被保留</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>只有一个线程的“ 池”， 该线程顺序执行每一个提交的任务</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>用于预定执行而构建的固定线程池</td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td>用于预定执行而构建的单线程“ 池”</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li><p>相关<code>Scheduled</code>线程池的用法:<br> <code>schedule</code>：预定在指定的时间之后执行任务<br> <code>scheduleAtFixedRate</code>：预定在初始的延迟结束后， 周期性地运行给定的任务， 周期长度是period<br> <code>scheduleWithFixedDelay</code>：预定在初始的延迟结束后周期性地运行给定的任务， 在一次调用完成和下一次调用开<br> 始之间有长度为delay 的延迟</p>
</li>
<li><p>控制任务组</p>
<p>  并行处理任务</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ....;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; futures = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span>(Future&lt;T&gt; result:results) &#123;</span><br><span class="line">	result.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以上方法有个缺点，必要要所有任务执行完毕了，<code>get</code>才会开始真正执行</p>
<p>  可通过<code>ExecutorCompletionService</code>类解决,使先完成的先返回</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorCompletionService&lt;T&gt; service = <span class="keyword">new</span> ExecutorCompletionService(executor);</span><br><span class="line"><span class="keyword">for</span> (Callable&lt;T&gt; task : tasks)</span><br><span class="line">    service,submit(task);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.sizeO；i ++)</span><br><span class="line">	processFurther(service.take().get())；</span><br></pre></td></tr></table></figure></li>
<li><p>Fork-Join框架</p>
<p>  在未满足最小计算单位时拆分成更多小的任务进行并行操作，以提高效率</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Task&lt;T&gt; extends RecursiveTask&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> to;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (from + to)/<span class="number">2</span>;</span><br><span class="line">            Task first = <span class="keyword">new</span> Task(from, mid);</span><br><span class="line">            Task second = <span class="keyword">new</span> Task(mid,to);</span><br><span class="line">            invokeAll(first, second);</span><br><span class="line">            <span class="keyword">return</span> first.join() + second.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task task = <span class="keyword">new</span> Task(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">pool.invoke(task)</span><br><span class="line">task.join();</span><br></pre></td></tr></table></figure></li>
<li><p>可完成Future【CompletableFuture】</p>
<p>  由于单纯使用Future会造成线程阻塞，java8引用了<code>CompletableFuture</code>来对<code>Future</code>进行改进，实现异步调用的逻辑</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">    CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">    <span class="comment">// 如果执行成功:</span></span><br><span class="line">    cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 如果执行异常:</span></span><br><span class="line">    cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;error: &quot;</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步器</p>
<table>
<thead>
<tr>
<th>类</th>
<th>能做什么</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CyclicBarrier</td>
<td>允许线程集等待直至其中预定数目的线程到达一个公共障栅（ barrier)，然后可以选择执行一个处理障栅的动作</td>
<td>当大量的线程需要在它们的结果可用之前完成时</td>
</tr>
<tr>
<td>Phaser</td>
<td>类似于循环障栅， 不过有一个可变的计数</td>
<td>Java SE 7 中引人</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>允许线程集等待直到计数器减为0</td>
<td>当一个或多个线程需要等待直到指定数目的事件发生</td>
</tr>
<tr>
<td>Exchanger</td>
<td>允许两个线程在要交换的对象准备好时交换对象</td>
<td>当两个线程工作在同一数据结构的两个实例上的时候， 一个向实例添加数据而另一个从实例清除数据</td>
</tr>
<tr>
<td>Samaphore</td>
<td>允许线程集等待直到被允许继续运行为止</td>
<td>限制访问资源的线程总数。如果许可数是1，常常阻塞线程直到另一个线程给出许可为止</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>允许一个线程把对象交给另一个线程</td>
<td>在没有显式同步的情况下， 当两个线程准备好将一个对象从一个线程传递到另一个时</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>BitSet</title>
    <url>/2020/09/14/Java/%E9%9B%86%E5%90%88/BitSet-md/</url>
    <content><![CDATA[<h1 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h1><blockquote>
<p>Java平台上存放位序列的集合。<br>如果需要高效的存储位序列（例如：标志）就可以使用位集。<br>由于位集将位包装在字节里，所以使用位集比使用Boolean对象的ArrayList更加高效。</p>
</blockquote>
<h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>	 		<span class="comment">// 返回最高位为1的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bit)</span>	<span class="comment">// 获得一个位，返回true则为开</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bit)</span>		<span class="comment">// 设置一个位为开</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> bit)</span>		<span class="comment">// 设置一个位为关</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>			<span class="comment">// 将所有设置为关</span></span></span><br></pre></td></tr></table></figure>

<h5 id="计算素数个数"><a href="#计算素数个数" class="headerlink" title="计算素数个数"></a>计算素数个数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算2~2000000之间的所有素数</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">200_0000</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">BitSet bit = <span class="keyword">new</span> BitSet(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    bit.set(i);</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">while</span> (i * i &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bit.get(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        k = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= n) &#123;</span><br><span class="line">            bit.clear(k);</span><br><span class="line">            k += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bit.get(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;count: &quot;</span> + count); <span class="comment">// count: 148933</span></span><br><span class="line">System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><blockquote>
<p> 参考：<a href="https://blog.csdn.net/wildwolf_001/article/details/107186226">https://blog.csdn.net/wildwolf_001/article/details/107186226</a></p>
</blockquote>
<h5 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h5><ol>
<li><p>数据结构？</p>
<p>答：数组加链表法</p>
</li>
<li><p>怎么插入数据？</p>
<p>答：链表头插法，即：链表中最新的数据插在链表头</p>
</li>
<li><p>哈希冲突怎么预防？</p>
<p>答：二次哈希 or 扰动函数</p>
</li>
<li><p>怎么解决哈希冲突？</p>
<p>答：链表法，其它方案：再哈希、开放寻址、公共溢出区</p>
</li>
<li><p>默认容量多少？</p>
<p>答：16</p>
</li>
<li><p>扩容后存储位置的计算方式？</p>
<p>答：重新计算哈希和索引</p>
</li>
<li><p>内部数组是什么时候创建的？</p>
<p>答：第一次put的时候创建</p>
</li>
</ol>
<h5 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h5><ol>
<li><p>1.7 和 1.8 数据结构有什么不同？</p>
<p>答：引入红黑树</p>
</li>
<li><p>1.7 和 1.8 往链表上插数据的方式有什么不同？<br>答：从头插法改为尾部插入</p>
</li>
<li><p>扩容后存储位置的计算方式？</p>
<p>答：对老数组进行与运算，判断值是否等于0，等于0在低位，否则在高位</p>
</li>
<li><p>HashMap 什么时候会把链表转化为红黑树？</p>
<p>答：在链表大于等于8时会转换为红黑树，如果数组大小小于64会优先扩容</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全的集合</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h1><h5 id="常用集合描述"><a href="#常用集合描述" class="headerlink" title="常用集合描述"></a>常用集合描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ConcurrentHashMap</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentSkipListMap</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentSkipListSet</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ConcurrentLinkedQueue</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CopyOnWriteArrayList</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CopyOnWriteArraySet</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>通用集合</title>
    <url>/2020/09/15/Java/%E9%9B%86%E5%90%88/%E9%80%9A%E7%94%A8%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="通用集合"><a href="#通用集合" class="headerlink" title="通用集合"></a>通用集合</h1><h5 id="常用集合描述"><a href="#常用集合描述" class="headerlink" title="常用集合描述"></a>常用集合描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ArrayList</td>
<td align="left">一种可以动态增长和缩减的索引序列</td>
</tr>
<tr>
<td align="left">LinkedList</td>
<td align="left">一种可以在任何位置进行高效地插人和删除操作的有序序列</td>
</tr>
<tr>
<td align="left">ArrayDeque</td>
<td align="left">一种用循环数组实现的双端队列</td>
</tr>
<tr>
<td align="left">HashSet</td>
<td align="left">一种没有重复元素的无序集合</td>
</tr>
<tr>
<td align="left">TreeSet</td>
<td align="left">一种有序集</td>
</tr>
<tr>
<td align="left">EnumSet</td>
<td align="left">一种包含枚举类型值的集</td>
</tr>
<tr>
<td align="left">LinkedHashSet</td>
<td align="left">一种可以记住元素插人次序的集</td>
</tr>
<tr>
<td align="left">PriorityQueue</td>
<td align="left">一种允许高效删除最小元素的集合</td>
</tr>
<tr>
<td align="left">HashMap</td>
<td align="left">一种存储键值关联的数据结构</td>
</tr>
<tr>
<td align="left">TreeMap</td>
<td align="left">一种键值有序排列的映射表</td>
</tr>
<tr>
<td align="left">EnumMap</td>
<td align="left">一种键值属于枚举类型的映射表</td>
</tr>
<tr>
<td align="left">LinkedHashMap</td>
<td align="left">一种存储键/ 值关联的数据结构—种键值有序排列的映射表</td>
</tr>
<tr>
<td align="left">WeakHashMap</td>
<td align="left">一种其值无用武之地后可以被垃圾回收器回收的映射表</td>
</tr>
<tr>
<td align="left">IdentityHashMap</td>
<td align="left">一种用==而不是用equals 比较键值的映射表</td>
</tr>
</tbody></table>
<h5 id="旧集合"><a href="#旧集合" class="headerlink" title="旧集合"></a>旧集合</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Vector</td>
<td align="left">与ArrayList相似，但所有方法都是同步的</td>
</tr>
<tr>
<td align="left">HashTable</td>
<td align="left">与HashMap相似，但所有方法都是同步的</td>
</tr>
<tr>
<td align="left">Properties</td>
<td align="left">属性映射</td>
</tr>
</tbody></table>
<h5 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collections.empty…</td>
<td align="left">生成一个不可添加数据的空集合实例</td>
</tr>
<tr>
<td align="left">Collections.singleton…</td>
<td align="left">生成一个不可修改的含单一数据的集合实例</td>
</tr>
<tr>
<td align="left">Collections.unmodifiable…</td>
<td align="left">生成一个包装集合的不可添加数据的包装集合实例</td>
</tr>
<tr>
<td align="left">Collections.synchronized…</td>
<td align="left">生成一个包装集合的同步操作包装集合实例</td>
</tr>
<tr>
<td align="left">Collections.checked…</td>
<td align="left">生成一个包装集合的受查操作的集合实例</td>
</tr>
</tbody></table>
<h5 id="LinkedHashMap实现LRU算法（最近最少使用算法）"><a href="#LinkedHashMap实现LRU算法（最近最少使用算法）" class="headerlink" title="LinkedHashMap实现LRU算法（最近最少使用算法）"></a>LinkedHashMap实现LRU算法（最近最少使用算法）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> capacity = <span class="number">4</span>;</span><br><span class="line">LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(capacity, <span class="number">0.75f</span>,<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;String, String&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; <span class="comment">// 当返回true则删除最少使用的的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="小知识："><a href="#小知识：" class="headerlink" title="小知识："></a>小知识：</h5><ol>
<li>“for each”循环可以与任何实现了<strong>Iterable接口</strong>的对象一起工作</li>
<li>集合<strong>迭代器Iterator</strong>的remove与next/previous具有依赖性，调用remove之前没有调用next是不合法的，必须先调用next越过将要删除的元素</li>
<li>Java 1.4针对集合引入了一个<strong>标记接口RandomAccess</strong>，用于标记该集合是否支持高效的随机访问，如：ArrayList(实现)和LinkedList(未实现)</li>
<li>Collection集合类内部维护了一个计数器modCount，负责跟踪列表的<strong>结构性修改</strong>，如添加元素、删除元素等。在新建迭代器的同时会缓存此时的计数器，在改写操作时判断缓存的计数器值与集合类的计数器值是否一致，不一致则抛出<strong>ConcurrentModificastionException</strong>异常。注意：集合的set方法不被<strong>视为结构性修改</strong>，这会造成多个迭代器遍历出的结果不一定一致</li>
<li>以<strong>链表</strong>为模型的集合，多次使用get获取某个位置的元素效率极低，可以使用<strong>列表迭代器ListIterator</strong>的nextIndex、next、previousIndex、previous等方法优化该操作，<strong>备注：</strong>ListIterator的add和set方法也是插入操作的一个优化点</li>
<li>原本**for(Map.Entry&lt;&gt; entry : map.entrySet())**的map遍历操作最高效，在Java 1.8后直接通过map.forEach方法直接操作node更加高效</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列</title>
    <url>/2020/11/08/Java/%E9%9B%86%E5%90%88/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h5 id="队列描述描述"><a href="#队列描述描述" class="headerlink" title="队列描述描述"></a>队列描述描述</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LinkedBlockingQueue</td>
<td align="left">一种容量没有上边界的阻塞队列，亦可指定最大容量</td>
</tr>
<tr>
<td align="left">LinkedBlockingDeque</td>
<td align="left">一种双端队列版本</td>
</tr>
<tr>
<td align="left">ArrayBlockingQueue</td>
<td align="left">一种在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性</td>
</tr>
<tr>
<td align="left">PriorityBlockingQueue</td>
<td align="left">一种带优先级的队列</td>
</tr>
<tr>
<td align="left">DelayQueue</td>
<td align="left">一种延迟阻塞队列【可实现如下单后三十分钟内没有付款就自动取消订单的操作】</td>
</tr>
<tr>
<td align="left">TransferQueue</td>
<td align="left">一种等待消费者准备就绪才可接收的阻塞队列，如果调用<code>transfer</code>那么会阻塞，直到另一个线程将其取出</td>
</tr>
</tbody></table>
<h5 id="阻塞队列通用方法"><a href="#阻塞队列通用方法" class="headerlink" title="阻塞队列通用方法"></a>阻塞队列通用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>动作</th>
<th>特殊情况</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>添加一个元素</td>
<td>如果队列满， 则抛出IllegalStateException 异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队列头元素</td>
<td>如果队列空，抛出NoSuchElementException 异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回true</td>
<td>如果队列满， 返回false</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列头元素</td>
<td>如果队列空， 则返回null</td>
</tr>
<tr>
<td>poll</td>
<td>移除并返回队列的头元素</td>
<td>如果队列空， 则返回null</td>
</tr>
<tr>
<td>put</td>
<td>添加一个元素</td>
<td>如果队列满， 则阻塞</td>
</tr>
<tr>
<td>remove</td>
<td>移出并返回头元素</td>
<td>如果队列空， 则抛出NoSuchElementException 异常</td>
</tr>
<tr>
<td>take</td>
<td>移出并返回头元素</td>
<td>如果队列空， 则阻塞</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2020/09/13/Docker/Docker%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><ol>
<li><p>官方文档</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker.com&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>Docker安装：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装前检查</span><br><span class="line">    1.内核版本</span><br><span class="line">        uname -a</span><br><span class="line">    2.检查Device Mapper</span><br><span class="line">        ls -l &#x2F;sys&#x2F;class&#x2F;misc&#x2F;device-mapper</span><br><span class="line">Ubuntu中安装Docker的方式</span><br><span class="line">    1.安装Ubuntu维护的版本(版本相对官方有可能会低点)</span><br><span class="line">            安装：		sudo apt-get install docker.io</span><br><span class="line">        更新配置：	source &#x2F;etc&#x2F;bash_completion.d&#x2F;docker.io</span><br><span class="line">    2.安装Docker维护的版本(推荐)</span><br><span class="line">        wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</span><br><span class="line">        输入当前用户的密码后，就会下载脚本并且安装Docker及依赖包。</span><br><span class="line">        安装完成后有个提示:</span><br><span class="line">        If you would like to use Docker as a non-root user, you should now consider</span><br><span class="line">        adding your user to the &quot;docker&quot; group with something like:</span><br><span class="line">        sudo usermod -aG docker runoob</span><br><span class="line">        Remember that you will have to log out and back in for this to take effect!</span><br><span class="line"></span><br><span class="line">        意思是:当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker [user] 命令，然后重新登陆，否则会有如下报错</span><br><span class="line"></span><br><span class="line">可以通过直接输入docker命令查看Docker客户端的所有命令选项</span><br><span class="line">可以通过命令 docker command --help 更深入的了解指定的 Docker 命令使用方法。</span><br><span class="line">例如我们要查看 docker stats 指令的具体使用方法：</span><br><span class="line">docker stats --help</span><br><span class="line">    3.测试</span><br><span class="line">        sudo docker run hello-world</span><br><span class="line">    4.非root用户运行docker</span><br><span class="line">        创建一个用户组：			sudo groupadd docker</span><br><span class="line">        将当前用户添加到用户组：	sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class="line">        注销并重新启动docker服务：	sudo service docker restart</span><br></pre></td></tr></table></figure></li>
<li><p>镜像的基本操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 查看版本</span><br><span class="line">    docker version</span><br><span class="line"></span><br><span class="line">2. 查看docker信息</span><br><span class="line">    docker info</span><br><span class="line"></span><br><span class="line">3. 列出镜像</span><br><span class="line">    docker images [OPTSIONS] [REPOSITORY]</span><br><span class="line">    -a --all&#x3D;false      显示所有镜像，包括中间层镜像</span><br><span class="line">    -f --filter&#x3D;[]      显示时的过滤条件</span><br><span class="line">    --no-trunc&#x3D;false    不截断镜像的唯一id</span><br><span class="line">    -q --quiet&#x3D;false    只显示镜像的唯一id</span><br><span class="line"></span><br><span class="line">4. 查看镜像</span><br><span class="line">    docker inspect [OPTSIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class="line"></span><br><span class="line">5. 删除镜像</span><br><span class="line">    docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">    -f --force&#x3D;false    强制删除镜像</span><br><span class="line">    --no-prune&#x3D;false    保留未打标签的父镜像</span><br><span class="line"></span><br><span class="line">6. 查找镜像</span><br><span class="line">    方式一:Docker Hub</span><br><span class="line">        https:&#x2F;&#x2F;registry.hub.docker.com</span><br><span class="line"></span><br><span class="line">    方式二:</span><br><span class="line">    docker search [OPTIONS]</span><br><span class="line">    --automated&#x3D;false   只显示自动化构建的镜像</span><br><span class="line">    --no-trunc&#x3D;false    不截断显示</span><br><span class="line">    -s --stars&#x3D;0        过滤分数需要高于设置的镜像</span><br><span class="line"></span><br><span class="line">7. 拉取镜像</span><br><span class="line">    docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line">    -a --all-tags&#x3D;false 匹配名字的镜像全部下载到本地</span><br><span class="line"></span><br><span class="line">    修改镜像获取地址</span><br><span class="line">        使用--registry-mirror选项</span><br><span class="line">        1.修改：&#x2F;etc&#x2F;default&#x2F;docker</span><br><span class="line">        2.添加：DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;http:&#x2F;&#x2F;MIRROR-ADDR&quot;</span><br><span class="line">    https:&#x2F;&#x2F;www.daocloud.io</span><br><span class="line"></span><br><span class="line">8. 推送镜像</span><br><span class="line">    docker push NAME[:TAG]</span><br><span class="line"></span><br><span class="line">9. 查看镜像构建过程</span><br><span class="line">    docker history IMAGE</span><br><span class="line"></span><br><span class="line">10. 构建镜像</span><br><span class="line">    使用commit构建镜像</span><br><span class="line">        docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">        -a --author&#x3D;&quot;&quot;      指定作者</span><br><span class="line">        -m --message&#x3D;&quot;&quot;     指定信息</span><br><span class="line">        -p --pause&#x3D;true     不暂停容器并提交</span><br><span class="line"></span><br><span class="line">    使用Dockerfile构建镜像</span><br><span class="line">        1. 创建Dockerfile文件</span><br><span class="line">              #First Dockerfile</span><br><span class="line">              FROM ubuntu:14.04             # 源仓库</span><br><span class="line">              MAINTAINER 维护人 &quot;维护人邮箱&quot;</span><br><span class="line">              RUN command1                  # 执行的命令</span><br><span class="line">              RUN command2                  # 执行的命令</span><br><span class="line">              RUN command3                  # 执行的命令</span><br><span class="line">              ...</span><br><span class="line">              EXPOSE 80                     # 暴露的端口</span><br><span class="line">              CMD command4</span><br><span class="line">        2. 使用docker build 命令</span><br><span class="line">            docker build [OPTIONS] PATH|URL|-</span><br><span class="line">            --force-rm&#x3D;false</span><br><span class="line">            --no-cache&#x3D;false    不启用构建缓存</span><br><span class="line">            --pull&#x3D;false</span><br><span class="line">            -q --quiet&#x3D;false    静默操作，不打印日志</span><br><span class="line">            --rm&#x3D;true</span><br><span class="line">            -t --tag&#x3D;&quot;&quot;         指定仓库名字</span><br><span class="line">        3. Dockerfile指令</span><br><span class="line">            1. 注释</span><br><span class="line">                以#开头，单行注释</span><br><span class="line"></span><br><span class="line">            2. 指令</span><br><span class="line">                以大写的指令名开始，后面接着指令参数</span><br><span class="line"></span><br><span class="line">            3. FROM指令：指定基础镜像</span><br><span class="line">                格式：</span><br><span class="line">                    FROM &lt;image&gt;</span><br><span class="line">                    FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">                要求：</span><br><span class="line">                    已经存在的镜像</span><br><span class="line">                    必须是第一条非注释指令</span><br><span class="line"></span><br><span class="line">            4. MAINTAINER指令：指定镜像作者信息，包含镜像所有者和联系信息，相当于commit命令的-a属性</span><br><span class="line">                格式：</span><br><span class="line">                    MAINTAINER &lt;name&gt;</span><br><span class="line"></span><br><span class="line">            5. RUN指令：指定当前镜像中运行的命令,每条RUN指令都会基于上一条RUN指令的新镜像上添加</span><br><span class="line">                格式：</span><br><span class="line">                    RUN &lt;command&gt; (shell模式)</span><br><span class="line">                        例：&#x2F;bin&#x2F;sh -c command 相对于执行了该命令</span><br><span class="line">                            RUN echo hello</span><br><span class="line">                    RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                        例：RUN [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</span><br><span class="line"></span><br><span class="line">            6. EXPOSE指令：指定运行该镜像的容器使用的端口</span><br><span class="line">                格式：</span><br><span class="line">                    EXPOSE &lt;port&gt; [&lt;port&gt;...]   可以指定一个或多个端口，也可使用多个EXPOSE命令</span><br><span class="line">                注意：</span><br><span class="line">                    虽然在构建镜像指定了端口，在容器运行时也需要通过run -p参数指定所使用的端口</span><br><span class="line"></span><br><span class="line">            7. CMD指令：提供容器运行时默认命令，于RUN指令相似，但是RUN指令是在镜像构建过程中执行的，CMD指令是在容器运行时运行的</span><br><span class="line">                格式：</span><br><span class="line">                    CMD &lt;command&gt; (shell模式)</span><br><span class="line">                    CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                    CMD [&quot;param1&quot;,&quot;param2&quot;] (作为ENTRYPOINT指令的默认参数)</span><br><span class="line">                注意：</span><br><span class="line">                    如果docker run指定了运行时的命令，那么CMD命令会被覆盖，也就是说CMD命令指定的时默认命令</span><br><span class="line"></span><br><span class="line">            8. ENTRYPOINT指令：与CMD指令相似，区别在于命令不会被覆盖，run指定的命令并不会执行</span><br><span class="line">                格式：</span><br><span class="line">                    ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec模式)</span><br><span class="line">                    ENTRYPOINT &lt;command&gt; (shell模式)</span><br><span class="line">                注意：</span><br><span class="line">                    如果需要覆盖，可以使用docker run --entrypoint覆盖</span><br><span class="line">                高级用法：</span><br><span class="line">                    用ENTRYPOINT来指定命令，用CMD来指定命令默认参数</span><br><span class="line">                    ENTRYPOINT [&quot;&#x2F;vsr&#x2F;bin&#x2F;nginx&quot;]</span><br><span class="line">                    CMD [&quot;-h&quot;]</span><br><span class="line"></span><br><span class="line">            9. ADD指令和COPY指令：将本地文件或目录复制到镜像中</span><br><span class="line">                格式：</span><br><span class="line">                    ADD &lt;src&gt;...&lt;dest&gt;</span><br><span class="line">                    ADD [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;](适用于文件路径中有空格的情况)</span><br><span class="line">                    COPY &lt;src&gt;...&lt;dest&gt;</span><br><span class="line">                    COPY [&quot;&lt;src&gt;&quot;...&quot;&lt;dest&gt;&quot;](适用于文件路径中有空格的情况)</span><br><span class="line">                    src：可以是本地地址(必须是构建目录中的相对地址)和远程URL(不推荐)</span><br><span class="line">                    dest:镜像中的绝对路径</span><br><span class="line">                区别：</span><br><span class="line">                    ADD vs COPY</span><br><span class="line">                        ADD 包含类似tar的解压功能</span><br><span class="line">                        如果单纯复制文件，Docker推荐使用COPY</span><br><span class="line"></span><br><span class="line">            10. VOLUME指令：向镜像容器添加卷，生成成数据卷容器</span><br><span class="line">                格式：</span><br><span class="line">                    VOLUME [&quot;&#x2F;data&quot;]</span><br><span class="line">                注意：</span><br><span class="line">                    该操作不能指定主机目录，由容器运行时动态生成主机挂载的目录</span><br><span class="line"></span><br><span class="line">            11. WORKDIR指令：在容器内部指定工作目录</span><br><span class="line">                格式：</span><br><span class="line">                    WORKDIR &#x2F;path&#x2F;to&#x2F;workdir    CMD和ENTRYPOINT都会在这个目录下执行</span><br><span class="line"></span><br><span class="line">            12. ENV指令：设置容器环境变量</span><br><span class="line">                格式：</span><br><span class="line">                    ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">                    ENV &lt;key&gt;&#x3D;&lt;value&gt;...</span><br><span class="line"></span><br><span class="line">            13. USER指令：指定镜像会以什么样的用户去运行</span><br><span class="line">                格式：</span><br><span class="line">                    USER daemon     可以使用uid：gid：group</span><br><span class="line">                    USER user       USER uid</span><br><span class="line">                    USER user:group USER uid:gid</span><br><span class="line">                    USER user:gid   USER uid:group</span><br><span class="line"></span><br><span class="line">            14. ONBUILD [INSTRUCTION]：为镜像添加触发器，当一个镜像被其他镜像作为基础镜像时执行，会在构建过程中插入指令</span><br><span class="line">                格式：</span><br><span class="line">                    ONBUILD [INSTRUCTION]</span><br><span class="line">                    例：</span><br><span class="line">                        ONBUILD COPY &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>镜像的导入导出</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 镜像导出</span><br><span class="line">    docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">    -o --output string 输出到文件</span><br><span class="line">    例:</span><br><span class="line">        docker save -o nginx.tar nginx:latest</span><br><span class="line">        或</span><br><span class="line">        docker save &gt; nginx.tar nginx:latest</span><br><span class="line">        其中-o和&gt;表示输出到文件，nginx.tar为目标文件，nginx:latest是源镜像名(name:tag)</span><br><span class="line"></span><br><span class="line">2. 镜像导入</span><br><span class="line">    docker load [OPTIONS]</span><br><span class="line">    -i --input 从文件输入</span><br><span class="line">    例：</span><br><span class="line">        docker load -i nginx.tar</span><br><span class="line">        或</span><br><span class="line">        docker load &lt; nginx.tar</span><br><span class="line">        其中-i和&lt;表示从文件输入。会成功导入镜像及相关元数据，包括tag信息</span><br><span class="line"></span><br><span class="line">3. 容器导出</span><br><span class="line">    docker export [options] container</span><br><span class="line">    -o --output string 输出到文件</span><br><span class="line">    例：</span><br><span class="line">        docker export -o nginx-test.tar nginx-test</span><br><span class="line">        其中-o表示输出到文件，nginx-test.tar为目标文件，nginx-test是源容器名(name)</span><br><span class="line"></span><br><span class="line">4. 容器导入</span><br><span class="line">    docker import [options] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line">    例：</span><br><span class="line">        docker import nginx-test.tar nginx:imp</span><br><span class="line">        或</span><br><span class="line">        cat nginx-test.tar | docker import - nginx:imp</span><br><span class="line"></span><br><span class="line">5. 说明与需要注意的地方</span><br><span class="line">    1. export命令导出的tar文件略小于save命令导出的</span><br><span class="line">    2. export命令是从容器（container）中导出tar文件，而save命令则是从镜像（images）中导出</span><br><span class="line">    3. 基于第二点，export导出的文件再import回去时，无法保留镜像所有历史（即每一层layer信息，不熟悉的可以去看Dockerfil），不能进行回滚操作；而save是依据镜像来的，所以导入时可以完整保留下每一层layer信息。如下图所示，nginx:latest是save导出load导入的，nginx:imp是export导出import导入的</span><br><span class="line"></span><br><span class="line">6. 建议</span><br><span class="line">    若是只想备份images，使用save、load即可</span><br><span class="line">    若是在启动容器后，容器内容有变化，需要备份，则使用export、import</span><br></pre></td></tr></table></figure></li>
<li><p>容器的基本操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 启动容器</span><br><span class="line">    docker run IMAGE [COMMAND] [ARG...]</span><br><span class="line">    run 在新容器中执行命令</span><br><span class="line"></span><br><span class="line">2. 启动交互式容器</span><br><span class="line">    docker run [--name 自定义名字] -i -t IMAGE &#x2F;bin&#x2F;bash</span><br><span class="line">    -i --interactive&#x3D;true | false 默认是false   告诉docker父进程始终打开标准输入</span><br><span class="line">    -t --tty&#x3D;true | false 默认是false           告诉docker父容器提供一个tty终端</span><br><span class="line"></span><br><span class="line">    将交互式容器派遣为守护石形式运行的容器</span><br><span class="line">    Ctrl+P Ctrl+Q</span><br><span class="line"></span><br><span class="line">3. 附加到运行中的容器</span><br><span class="line">    docker attach [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">4. 直接启动守护式容器</span><br><span class="line">    docker run -d IMAGE [COMMAND] [ARG...]</span><br><span class="line">    -d --detach     派遣为守护式容器启动</span><br><span class="line"></span><br><span class="line">5. 查看容器日志</span><br><span class="line">    docker logs [-f] [-t] [--tail SIZE] [CONTAINER ID或NAME]</span><br><span class="line">    -f --follows&#x3D;true | false 默认式false       一直跟踪日志变化并打印出来</span><br><span class="line">    -t --timestamps&#x3D;true | false 默认式false    在日志列加上时间戳</span><br><span class="line">    --tail&#x3D;数量                                返回结尾处多少数量的日志，0则默认最新</span><br><span class="line"></span><br><span class="line">6. 查看容器内进程</span><br><span class="line">    docker top [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">7. 在运行中的容器内启动新进程</span><br><span class="line">    docker exec [-d] [-i] [-t] [CONTAINER ID或NAME] [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">8. 查看创建了那些容器</span><br><span class="line">    docker ps [-a] [-l]</span><br><span class="line">    -a 显示所有容器，包括已经停止的</span><br><span class="line">    -l 显示 最新的容器</span><br><span class="line">    -q 只显示容器id</span><br><span class="line"></span><br><span class="line">    查看容器信息</span><br><span class="line">    docker inspect [CONTAINER ID或NAME]</span><br><span class="line"></span><br><span class="line">    高级用法：</span><br><span class="line">        停止所有容器：docker stop $(docker ps -a -q)</span><br><span class="line">        移除所有容器：docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line">9. 重新启动已经停止的容器</span><br><span class="line">    docker start -i [CONTAINER ID或  NAME]</span><br><span class="line"></span><br><span class="line">10. 停止正在运行的容器</span><br><span class="line">    docker stop [CONTAINER ID或NAMES]</span><br><span class="line">    docker kill [CONTAINER ID或NAMES]   强制停止容器</span><br><span class="line"></span><br><span class="line">11. 删除不需要的容器,删除容器时，容器必须是停止状态,否则会报异常</span><br><span class="line">    docker rm [-v] [CONTAINER ID或NAME]</span><br><span class="line">    -v 删除挂载的数据卷</span><br><span class="line">12. 查看端口映射</span><br><span class="line">    docker port [CONTAINER ID或NAMES]</span><br><span class="line"></span><br><span class="line">13. 设置容器端口映射</span><br><span class="line">    run [-P] [-p]</span><br><span class="line">    -P --publish-all&#x3D;true | false 默认式false</span><br><span class="line">        docker run -P -i -t ubuntu &#x2F;bin&#x2F;bash    将容器内部使用的端口映射到主机上</span><br><span class="line">    -p --publish&#x3D;[]</span><br><span class="line">        containerPort</span><br><span class="line">            docker run -p 80 -i -t ubuntu &#x2F;bin&#x2F;bash                 将容器80端口随机映射到主机上</span><br><span class="line">        hostPort:containerPort</span><br><span class="line">            docker run -p 8080:80 -i -t ubuntu &#x2F;bin&#x2F;bash            将容器80端口映射到主机8080端口上</span><br><span class="line">        ip::containerPort</span><br><span class="line">            docker run -p 0.0.0.0:80 -i -t ubuntu &#x2F;bin&#x2F;bash         将容器80端口映射到主机0.0.0.0上</span><br><span class="line">        ip:hostPort:containerPort</span><br><span class="line">            docker run -p 0.0.0.0:8080:80 -i -t ubuntu &#x2F;bin&#x2F;bash    将容器80端口映射到主机0.0.0.0:8080上</span><br><span class="line"></span><br><span class="line">14. 设置容器的数据卷</span><br><span class="line">    run [-v]</span><br><span class="line">    -v --volume 设置容器数据卷[主机目录:容器目录(绝对路径)]，如果主机目录不存在会自动新建</span><br><span class="line">    设置卷只读权限</span><br><span class="line">        docker run -v 主机目录:容器目录:ro IMAGE [COMMAND] [ARG...]</span><br><span class="line">    设置读写权限</span><br><span class="line">        docker run -v 主机目录:容器目录:rw IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的C/S模式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Remote API调用</span><br><span class="line">    https:&#x2F;&#x2F;docs.docker.com&#x2F;develop&#x2F;sdk&#x2F;examples&#x2F;</span><br><span class="line"></span><br><span class="line">2. 连接模式</span><br><span class="line">    模式一: unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">        例：</span><br><span class="line">            本地sock地址 &#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">            curl --unix-socket &#x2F;var&#x2F;run&#x2F;docker.sock http:&#x2F;v1.24&#x2F;images&#x2F;json</span><br><span class="line">    模式二: tcp:&#x2F;&#x2F;host:port 端口port通常为2375</span><br><span class="line">    模式三: fd:&#x2F;&#x2F;socketfd</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的远程访问</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 要求Docker server和Dokcer client版本一致</span><br><span class="line"></span><br><span class="line">2. 修改Docker守护进程启动选项</span><br><span class="line">    -H  tcp:&#x2F;&#x2F;host:port</span><br><span class="line">        unix:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;socket</span><br><span class="line">        fd:&#x2F;&#x2F;* or fd:&#x2F;&#x2F;socketfd</span><br><span class="line">    -H指定Docker的通讯方式</span><br><span class="line">    守护进程默认配置</span><br><span class="line">    -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line"></span><br><span class="line">3. 远程连接</span><br><span class="line">    假设服务器A地址为：10.211.55.5</span><br><span class="line">    服务器A Docker启动配置：-H tcp:&#x2F;&#x2F;0.0.0.0:2375</span><br><span class="line"></span><br><span class="line">    服务器B请求远程api：curl 10.211.55.5:2375 http:&#x2F;v1.24&#x2F;images&#x2F;json</span><br><span class="line"></span><br><span class="line">4. 使用本地Docker client操作远程Docker server</span><br><span class="line">    服务器B</span><br><span class="line">    方式一：</span><br><span class="line">        本地Docker启动选项：-H tcp:&#x2F;&#x2F;10.211.55.5:2375   ip地址为远程服务器地址</span><br><span class="line">    方式二：</span><br><span class="line">        使用Docker环境变量配置调用远程Docker server： export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;10.211.55.5:2375&quot;</span><br><span class="line">    配置完成后就可以像使用本机Docker一样使用远程服务</span><br><span class="line"></span><br><span class="line">5. docker配置远程服务后本地服务不能正常调用</span><br><span class="line">    即服务器A设置为远程服务后，相关的docker命令无法调用，如：docker info 会返回异常</span><br><span class="line">    如果想要开发远程服务同时运行本地服务，可同时调用多次-H配置</span><br><span class="line">    服务器A Docker启动配置：-H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>数据卷容器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建数据卷容器</span><br><span class="line">    方式一：docker run -v path IMAGE [COMMAND] [ARG...]</span><br><span class="line">    方式二：构建容器包含VOLUME指令，即容器本身自带数据卷</span><br><span class="line">    例：</span><br><span class="line">       docker run -it -v &#x2F;dbdata --name dbdata ubuntu</span><br><span class="line"></span><br><span class="line">2. 其它容器通过使用--volumes-from来挂载dbdata容器中的数据卷</span><br><span class="line">    docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">    docker run -it --volumes-from dbdata --name db2 ubuntu</span><br><span class="line">    说明：</span><br><span class="line">        此时，容器db1和db2都挂载同一个数据卷到相同的&#x2F;dbdata目录。三个容器任何一方在该目录下的写入，其他容器都可以看到。</span><br><span class="line">        可以多次使用--volumes-from参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷，即多重挂载。</span><br><span class="line">        使用--volumes-from参数所挂载数据卷的容器自身并不需要保持在运行状态。</span><br><span class="line">    注意：        </span><br><span class="line">        如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器。</span><br><span class="line"></span><br><span class="line">3. 数据卷的备份和还原</span><br><span class="line">    备份：</span><br><span class="line">        docker run --volumes-from [container name需要备份的数据卷容器名称] -v $(pwd):&#x2F;backup --name backup ubuntu tar cvf &#x2F;backup&#x2F;backup.tar [container data valume数据卷容器需要备份的数据卷目录]</span><br><span class="line">    说明：</span><br><span class="line">        首先利用ubuntu镜像创建了一个容器backup。使用--volumes-from参数来让backup容器挂载需要备份的数据卷，使用-v  $(pwd):&#x2F;backup参数来挂载本地的当前目录到backup容器的&#x2F;backup目录。backup容器启动后，使用了tar命令压缩需要备份的数据，并存放在&#x2F;backup&#x2F;backup.tar上(实际就是主机的$(pwd)目录);</span><br><span class="line"></span><br><span class="line">    还原：</span><br><span class="line">        docker run --volumes-from [container name] -v $(pwd):&#x2F;backup --name restore ubuntu tar xvf &#x2F;backup&#x2F;backup.tar [container data volume]</span><br><span class="line">    说明：</span><br><span class="line">        跟备份原理相同</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的启动配置选项</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 启动选项</span><br><span class="line">    参考文档：https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;cli&#x2F;</span><br><span class="line">    docker -d [OPTOINS]</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="10">
<li><p>容器的网络连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>容器跨主机的网络连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3 基础</title>
    <url>/2020/09/12/Python3/Python3%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Python3-基础"><a href="#Python3-基础" class="headerlink" title="Python3 基础"></a>Python3 基础</h1><h5 id="已学习的包"><a href="#已学习的包" class="headerlink" title="已学习的包"></a>已学习的包</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable <span class="comment"># 可迭代</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator <span class="comment"># 迭代器</span></span><br><span class="line"><span class="keyword">from</span> types <span class="comment"># 封装了内置类型判断变量</span></span><br><span class="line"><span class="keyword">import</span> functools <span class="comment"># reduce wraps等</span></span><br><span class="line"><span class="keyword">import</span> re <span class="comment"># 文字处理：正则 findall sub search match</span></span><br><span class="line"><span class="keyword">import</span> time <span class="comment"># 日期包</span></span><br><span class="line"><span class="keyword">import</span> datetime <span class="comment"># 日期包</span></span><br><span class="line"><span class="keyword">import</span> math <span class="comment"># 数字工具</span></span><br><span class="line"><span class="keyword">import</span> random <span class="comment"># 随机数工具</span></span><br><span class="line"><span class="keyword">import</span> pathlib <span class="comment"># 文件操作</span></span><br><span class="line"><span class="keyword">import</span> os.path <span class="comment"># 目录访问</span></span><br><span class="line"><span class="keyword">import</span> tarfile <span class="comment"># 数据压缩和归档</span></span><br><span class="line"><span class="keyword">import</span> threading <span class="comment"># 多线程</span></span><br><span class="line"><span class="keyword">import</span> queue <span class="comment"># 生产者消费者队列</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 内置网络请求，推荐使用第三方requests库</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="comment"># 标记语言处理工具，推荐使用第三方库：xmltodict BeautifulSoup等第三方库</span></span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"><span class="keyword">import</span> xml</span><br></pre></td></tr></table></figure>

<h5 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">abs</span>(-<span class="number">45</span>) <span class="comment"># 获取数字的绝对值</span></span><br><span class="line"><span class="built_in">all</span>([<span class="number">0</span>,<span class="number">1</span>]) <span class="comment"># 判断给定的参数中的所有元素是否都为TRUE。元素除了是 0、空、None、False 外都算 True；空元组、空列表返回值为True</span></span><br><span class="line"><span class="built_in">any</span>([<span class="number">0</span>,<span class="number">1</span>]) <span class="comment"># 判断是否有元素为TRUE</span></span><br><span class="line"><span class="built_in">bin</span>(<span class="number">10</span>) <span class="comment"># 返回二进制数0b1010</span></span><br><span class="line"><span class="built_in">oct</span>() <span class="comment"># 将一个整数转换成八进制字符串。</span></span><br><span class="line"><span class="built_in">int</span>() <span class="comment"># 用于将一个字符串或数字转换为整型。</span></span><br><span class="line"><span class="built_in">hex</span>() <span class="comment"># 用于将一个整数转换为十六进制数</span></span><br><span class="line"><span class="built_in">round</span>() <span class="comment"># 返回浮点数x的四舍五入值（精度不能做保证）</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 返回x的y次方的值。</span></span><br><span class="line"><span class="built_in">bool</span>() <span class="comment"># 函数用于将给定参数转换为布尔类型</span></span><br><span class="line"><span class="built_in">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 对参数进行求和计算。</span></span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">&quot;abcd&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="comment"># 返回一个新字节数组</span></span><br><span class="line"><span class="built_in">callable</span>() <span class="comment"># 函数用于检查一个对象是否可调用的。对于函数、方法、lambda函式、类以及实现了 __call__ 方法的类实例, 它都返回 True</span></span><br><span class="line"><span class="built_in">chr</span>(<span class="number">98</span>) <span class="comment"># 函数用一个范围在range(256)内（即0～255）的整数作参数，返回一个对应的ASCII数值。</span></span><br><span class="line"><span class="built_in">dict</span>() <span class="comment"># 函数用来将元组/列表转换为字典格式。</span></span><br><span class="line"><span class="built_in">dir</span>() <span class="comment"># 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表</span></span><br><span class="line"><span class="built_in">enumerate</span>() <span class="comment"># 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;3 * 2&#x27;</span>) <span class="comment"># 函数用来执行一个字符串表达式，并返回表达式的值。</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;print(&#x27;Hello World&#x27;)&quot;</span>) <span class="comment"># 执行储存在字符串或文件中的Python语句，相比于eval，exec可以执行更复杂的Python代码。</span></span><br><span class="line"><span class="built_in">float</span>() <span class="comment"># 函数用于将整数和字符串转换成浮点数。</span></span><br><span class="line"><span class="built_in">frozenset</span>() <span class="comment"># 返回一个冻结的集合（一个无序的不重复元素序列），冻结后集合不能再添加或删除任何元素。</span></span><br><span class="line"><span class="built_in">hasattr</span>() <span class="comment"># 用于判断对象是否包含对应的属性。如果对象有该属性返回 True，否则返回 False。</span></span><br><span class="line"><span class="built_in">getattr</span>() <span class="comment"># 用于获取对象对应的属性</span></span><br><span class="line"><span class="built_in">hash</span>() <span class="comment"># 用于获取一个对象（数字或者字符串等）的哈希值</span></span><br><span class="line"><span class="built_in">id</span>()<span class="comment"># 用于获取对象的内存地址。</span></span><br><span class="line"><span class="built_in">input</span>() <span class="comment"># 接受一个标准输入数据，返回为 string 类型</span></span><br><span class="line"><span class="built_in">iter</span>() <span class="comment"># 函数用来生成迭代器</span></span><br><span class="line"><span class="built_in">next</span>() <span class="comment"># 返回迭代器的下一个项目。</span></span><br><span class="line"><span class="built_in">len</span>() <span class="comment"># 返回对象（字符、列表、元组等）长度或元素个数。</span></span><br><span class="line"><span class="built_in">list</span>() <span class="comment"># 方法用于将元组转换为列表。</span></span><br><span class="line"><span class="built_in">max</span>() <span class="comment"># 返回给定参数的最大值，参数可以为序列。</span></span><br><span class="line"><span class="built_in">min</span>() <span class="comment"># 函数返回给定参数的最小值，参数可以为序列。</span></span><br><span class="line"><span class="built_in">repr</span>() <span class="comment"># 函数将对象转化为供解释器读取的形式。返回一个对象的 string 格式。</span></span><br></pre></td></tr></table></figure>



<h5 id="自动关闭资源-上下文管理器"><a href="#自动关闭资源-上下文管理器" class="headerlink" title="自动关闭资源-上下文管理器"></a>自动关闭资源-上下文管理器</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">white <span class="built_in">open</span>(<span class="string">&quot;file name&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure>

<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><blockquote>
<p>内部函数调用外部函数变量</p>
<p>注意一：如果内部函数没有调用外部函数变量（包含外部函数局部变量），则无法构成闭包，没有__closure__属性</p>
<p>注意二：如果内部函数局部变量有相同的变量名被赋值，则认为是新建的局部变量，并没有调用外部变量，同样也无法构成闭包。可以通过nonlocal声明该变量为非局部变量解决这个问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out_method</span>(<span class="params">a</span>):</span></span><br><span class="line">    b = <span class="number">5</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner_method</span>(<span class="params">x</span>):</span></span><br><span class="line">		<span class="keyword">return</span> a*x + b</span><br><span class="line">	<span class="keyword">return</span> inner_method</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">a</span>):</span></span><br><span class="line">    b = <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:a*x+b</span><br><span class="line"></span><br><span class="line">m = out_method()</span><br><span class="line"><span class="built_in">print</span>(m(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># __closure__ 闭包对象属性，如果inner_method内没有使用a、b等外部变量，则该属性为None</span></span><br><span class="line"><span class="built_in">print</span>(m.__closure__)</span><br><span class="line"><span class="built_in">print</span>(m.__closure__[<span class="number">0</span>].cell_contents) <span class="comment"># 对应a值，如果inner_method没有引用a则没有该值</span></span><br><span class="line"><span class="built_in">print</span>(m.__closure__[<span class="number">1</span>].cell_contents) <span class="comment"># 对应b值，如果inner_method没有引用b则没有该值</span></span><br><span class="line"><span class="built_in">print</span>(m.__closure__[...].cell_contents)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部函数局部变量赋值举例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out_method</span>():</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner_method</span>():</span></span><br><span class="line">        <span class="comment"># a被python认为是局部变量，并没有引用外部变量a，所以也不构成闭包</span></span><br><span class="line">		<span class="comment"># nonlocal a 可通过该方式声明a变量为非局部变量，使其形成闭包</span></span><br><span class="line">        a = <span class="number">10</span></span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	<span class="keyword">return</span> inner_method</span><br></pre></td></tr></table></figure>

<h5 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h5><ol>
<li><p>切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">start: 开始位置，如果为负数则从末尾起算，空则从最左侧起算</span></span><br><span class="line"><span class="string">end:结束位置，如果为负数则从末尾起算，空则从最右侧结束</span></span><br><span class="line"><span class="string">step:间隔</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">list</span>[start:end:step]</span><br></pre></td></tr></table></figure></li>
<li><p>迭代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">所有的列表 map set都可以通过for...in...的格式迭代</span></span><br><span class="line"><span class="string">判断是否可迭代：</span></span><br><span class="line"><span class="string">from collections import Iterable</span></span><br><span class="line"><span class="string">print(isinstance(list, Iterable))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">列表:</span></span><br><span class="line"><span class="string">for i in list：</span></span><br><span class="line"><span class="string">如需获取索引可通过：for i,v in enumerate(list)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">map:</span></span><br><span class="line"><span class="string">默认map迭代的是key，需要同时迭代key和value：map kv: for k,v in map.items():</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set:</span></span><br><span class="line"><span class="string">for i in set:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多值遍历：</span></span><br><span class="line"><span class="string"> for x, y in [(1, 1), (2, 4), (3, 9)]:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>列表生成式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">格式：[表达式 生成器 条件]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 举例：</span></span><br><span class="line"><span class="built_in">list</span> = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 嵌套：</span></span><br><span class="line"><span class="built_in">list</span> = [m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line"><span class="comment"># dict：</span></span><br><span class="line"><span class="built_in">list</span> = [k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line"><span class="comment"># if else:</span></span><br><span class="line"><span class="built_in">list</span> = [x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"><span class="comment"># 生成 dict：</span></span><br><span class="line">dict1 = &#123;i * i: i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生成器</p>
<blockquote>
<p>生成器可以延迟生成数据，可有效防止一次性创建过多数据造成的内存压力</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">判断是否是生成器：</span></span><br><span class="line"><span class="string">from types import GeneratorType</span></span><br><span class="line"><span class="string">print(isinstance(gene, GeneratorType))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">方式一 生成器：</span></span><br><span class="line"><span class="string">将列表生成式的[]更改为(),如：[x for x in range(0, 10)] -&gt; (x for x in range(0, 10))</span></span><br><span class="line"><span class="string">g = (x for x in range(0, 10))</span></span><br><span class="line"><span class="string">即可next(g) 或 for i in g:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">方式二 生成器函数：</span></span><br><span class="line"><span class="string">def frange(start, end, step):</span></span><br><span class="line"><span class="string">    x = start</span></span><br><span class="line"><span class="string">    while x &lt; end:</span></span><br><span class="line"><span class="string">        yield x		# 会阻塞在此，直到外部消费了x值，才继续下一步</span></span><br><span class="line"><span class="string">        x += step</span></span><br><span class="line"><span class="string">f = frange(0, 10, 0.5)</span></span><br><span class="line"><span class="string">即可next(g) 或 for i in f:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">方式三 生成器类</span></span><br><span class="line"><span class="string">class GeneratorTest():</span></span><br><span class="line"><span class="string">    def __init__(self):</span></span><br><span class="line"><span class="string">        self.i = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __iter__(self):</span></span><br><span class="line"><span class="string">        return self # 因为自身就是生成器，所以返回self</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __next__(self):	# 允许next形成生成器</span></span><br><span class="line"><span class="string">        if self.i &gt;= 5:</span></span><br><span class="line"><span class="string">            raise StopIteration()</span></span><br><span class="line"><span class="string">        self.i += 1</span></span><br><span class="line"><span class="string">        return self.i</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">凡是可作用于for循环的对象都是Iterable类型；</span></span><br><span class="line"><span class="string">凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</span></span><br><span class="line"><span class="string">集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无参数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="comment"># 使用 @函数名 声明函数</span></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">相当于：</span></span><br><span class="line"><span class="string">start = log(start)</span></span><br><span class="line"><span class="string">start() 该start实际上为wrapper函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="comment">#带参数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">tag</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s call %s&quot;</span> % (tag, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"><span class="comment"># 使用 @函数名(args) 声明函数</span></span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&quot;描述&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">相当于：</span></span><br><span class="line"><span class="string">start = log(&quot;描述&quot;)(start)</span></span><br><span class="line"><span class="string">start() 该start实际上为wrapper函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">start()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">由于函数对象有一个__name__属性，可以拿到函数的名字:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>start.__name__</span></span><br><span class="line"><span class="string">&#x27;start&#x27;</span></span><br><span class="line"><span class="string">经过上面装饰器装饰后：</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>start.__name__</span></span><br><span class="line"><span class="string">&#x27;wrapper&#x27;</span></span><br><span class="line"><span class="string">这样会造成一些需要通过函数名判断信息的程序出错</span></span><br><span class="line"><span class="string">不过也不需要编写wrapper.__name__ = func.__name__这样的代码</span></span><br><span class="line"><span class="string">通过functools.wraps装饰wrapper函数即可</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<h5 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h5><blockquote>
<p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如有大量的字符串需要转换成8进制数值，每次都编写base=8过于繁琐</span></span><br><span class="line"><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 可通过偏函数使某个参数携带指定的默认值</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 相当于执行 int(&#x27;12345&#x27;, base=8)</span></span><br><span class="line">int2(<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">max2 = functools.partial(<span class="built_in">max</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 相当与执行max(10, 5, 6, 7)</span></span><br><span class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动实现协程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注意到consumer函数是一个generator，把一个consumer传入produce后：</span></span><br><span class="line"><span class="string">1. 首先调用c.send(None)启动生成器；</span></span><br><span class="line"><span class="string">2. 然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</span></span><br><span class="line"><span class="string">3. consumer通过yield拿到消息，处理，又通过yield把结果传回；</span></span><br><span class="line"><span class="string">4. produce拿到consumer处理的结果，继续生产下一条消息；</span></span><br><span class="line"><span class="string">5. produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3.4+ 使用标准库asyncio实现</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say hello!&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say hello again!&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># loop.run_until_complete(hello()) # 执行单个任务</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(&#123;hello(), hello()&#125;)) <span class="comment"># 执行多个任务</span></span><br><span class="line">loop.close() <span class="comment"># 任务执行完后直接结束</span></span><br><span class="line"><span class="comment"># loop.run_forever() # 任务执行完后保持运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3.5+ 新增简化版协程声明async和await</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">	r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hello again!&quot;</span>)</span><br><span class="line"><span class="comment"># 将@asyncio.coroutine换成async，将yield from换成await即可</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    r = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello again!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">class 类名(父类):</span></span><br><span class="line"><span class="string">	name = &#x27;&#x27; # 类变量，允许外部通过 类名.变量名 。相当于java的类静态变量</span></span><br><span class="line"><span class="string">	def __init__(self, arg): # 构造函数，首个参数必须为self</span></span><br><span class="line"><span class="string">		self.arg = arg # 赋值给实例变量arg，无需像name一样声明成员变量</span></span><br><span class="line"><span class="string">		pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	def 函数名(self): # 自定义函数，首个参数必须为self</span></span><br><span class="line"><span class="string">		print(self.name) # 使用类变量</span></span><br><span class="line"><span class="string">		print(类名.name) # 使用类变量</span></span><br><span class="line"><span class="string">		print(self.__class__.name) # 使用类变量</span></span><br><span class="line"><span class="string">		print(self.arg) # 使用实例变量</span></span><br><span class="line"><span class="string">		# 通过 self.变量名 的方式优先查找实例变量，如果实例变量空则查找类变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	@classmethod</span></span><br><span class="line"><span class="string">    def 函数名(cls): # 类函数</span></span><br><span class="line"><span class="string">   		print(cls.name)</span></span><br><span class="line"><span class="string">   		print(Student.name)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   	@staticmethod</span></span><br><span class="line"><span class="string">   	def 函数名(): # 静态函数</span></span><br><span class="line"><span class="string">   		print(Student.name)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(实例名.__dict__) # 打印实例所有的实例变量</span></span><br><span class="line"><span class="string">print(类名.__dict__) # 打印所有的类变量、内置函数和自定义函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注意一：在变量命名和函数命名在前面增加双下划线 __ ，则相当于声明为私有</span></span><br><span class="line"><span class="string">注意二：实例.__变量名 = xxx， 相对于给实例新声明一个公开变量，并没有为私有变量赋值</span></span><br><span class="line"><span class="string">stu = Student()# 内部含有私有变量__name</span></span><br><span class="line"><span class="string">stu2 = Student()</span></span><br><span class="line"><span class="string">stu.__name = &quot;xxx&quot;</span></span><br><span class="line"><span class="string">print(stu.__name) # 打印新声明的公开变量</span></span><br><span class="line"><span class="string">print(stu2.__name) # 报错没有该变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意三：私有变量和私有函数的私有原理为系统发现双下划线时重命名了变量名和函数名：_类名__变量名 _类名__函数名，外部通过重命名后的方式也是可以继续调用的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">限制类可声明得变量</span></span><br><span class="line"><span class="string">class 类名(父类):</span></span><br><span class="line"><span class="string">    __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;) # 用tuple定义允许绑定的属性名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意一：仅对当前类实例起作用，对继承的子类是不起作用</span></span><br><span class="line"><span class="string">注意二：除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">动态生成类</span></span><br><span class="line"><span class="string">def fn():</span></span><br><span class="line"><span class="string">	print(&quot;hello&quot;)</span></span><br><span class="line"><span class="string">参数一：class的名称</span></span><br><span class="line"><span class="string">参数二：继承的父类集合，tuple类型</span></span><br><span class="line"><span class="string">参数三：声明变量或函数</span></span><br><span class="line"><span class="string">Hello = type(&#x27;Hello&#x27;, (object,), dict(hello=fn))</span></span><br><span class="line"><span class="string">h = Hello()</span></span><br><span class="line"><span class="string">h.hello()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">与以下类声明效果一致，实际Python解释器也是扫面以下语法定义，然后通过type函数创建类</span></span><br><span class="line"><span class="string">class Hello(object):</span></span><br><span class="line"><span class="string">	def fn(self):</span></span><br><span class="line"><span class="string">		print(&quot;hello&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">元类（用于扩展类信息,在编写orm等框架相当有用）</span></span><br><span class="line"><span class="string">class MyMetaclass(type):</span></span><br><span class="line"><span class="string">	# args[0] = 类名</span></span><br><span class="line"><span class="string">	# args[1] = 父类tuple</span></span><br><span class="line"><span class="string">	# args[2] = 所含有的字段和函数dict</span></span><br><span class="line"><span class="string">    def __new__(cls, *args, **kwargs):</span></span><br><span class="line"><span class="string">        args[2][&#x27;add&#x27;] = lambda self, value: self.append(value) #动态添加函数</span></span><br><span class="line"><span class="string">        return type.__new__(cls, name, bases, attrs)</span></span><br><span class="line"><span class="string"># 使用</span></span><br><span class="line"><span class="string">class MyList(list, metaclass=ListMetaclass):</span></span><br><span class="line"><span class="string">	pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">上下文类</span></span><br><span class="line"><span class="string">class Test():</span></span><br><span class="line"><span class="string">    def __enter__(self):</span></span><br><span class="line"><span class="string">        # 初始化逻辑</span></span><br><span class="line"><span class="string">        return self</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __exit__(self, exc_type, exc_val, exc_tb):</span></span><br><span class="line"><span class="string">        # 退出结束逻辑</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def fun(self):</span></span><br><span class="line"><span class="string">        pass</span></span><br><span class="line"><span class="string"># 使用</span></span><br><span class="line"><span class="string">with Test() as t:</span></span><br><span class="line"><span class="string">    t.fun()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">高级变种上下文：</span></span><br><span class="line"><span class="string">from contextlib import contextmanager</span></span><br><span class="line"><span class="string">class Test():</span></span><br><span class="line"><span class="string">    def fun(self):</span></span><br><span class="line"><span class="string">        pass</span></span><br><span class="line"><span class="string">@contextmanager</span></span><br><span class="line"><span class="string">def my_Test():</span></span><br><span class="line"><span class="string">     # 初始化逻辑</span></span><br><span class="line"><span class="string">    yield Test()</span></span><br><span class="line"><span class="string">    # 退出结束逻辑</span></span><br><span class="line"><span class="string">with my_Test() as t:</span></span><br><span class="line"><span class="string">    t.fun()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">类函数属性化：函数可以像属性一样调用</span></span><br><span class="line"><span class="string">class Test():</span></span><br><span class="line"><span class="string">    @property</span></span><br><span class="line"><span class="string">    def go(self):</span></span><br><span class="line"><span class="string">        return self.name</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @go.setter</span></span><br><span class="line"><span class="string">    def go(self,name):</span></span><br><span class="line"><span class="string">        self.name = name</span></span><br><span class="line"><span class="string">t = Test()</span></span><br><span class="line"><span class="string">t.go = &quot;aa&quot;</span></span><br><span class="line"><span class="string">print(t.go)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">常用内置函数</span></span><br><span class="line"><span class="string">__str__ 调用打印时的内容</span></span><br><span class="line"><span class="string">__repr__ 程序打印时显示的内容</span></span><br><span class="line"><span class="string">__iter__ __next__ 使对象变成可迭代</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__getitem__</span></span><br><span class="line"><span class="string">使实例能够通过 实例[i]的方式获取值</span></span><br><span class="line"><span class="string">如果要实现切片功能需要做如下操作：</span></span><br><span class="line"><span class="string">def __getitem__(self, n):</span></span><br><span class="line"><span class="string">	 if isinstance(n, int): # n是索引</span></span><br><span class="line"><span class="string">	 	# todo</span></span><br><span class="line"><span class="string">	 	return data</span></span><br><span class="line"><span class="string">	 if isinstance(n, slice): # n是切片</span></span><br><span class="line"><span class="string">	  	start = n.start</span></span><br><span class="line"><span class="string">	  	stop = n.stop</span></span><br><span class="line"><span class="string">	  	step = n.step</span></span><br><span class="line"><span class="string">	  	# todo</span></span><br><span class="line"><span class="string">	  	return [...]</span></span><br><span class="line"><span class="string">还有与之对应的__setitem__和__delitem__的方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__getattr__ 当实例调用一个没有声明的变量或方法时，会尝试调用该方法</span></span><br><span class="line"><span class="string">__setattr__ 为实例赋值会调用该方法</span></span><br><span class="line"><span class="string">__call__ 使实例成为callable类型，实例() 的方式调用，通过callable()判断是否是callable类型</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum,IntEnum,unique</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自己的枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params">Enum</span>):</span></span><br><span class="line">    VALUE_1 = <span class="number">1</span></span><br><span class="line">    VALUE_ALIAS = <span class="number">1</span> <span class="comment">#枚举别名 VALUE_1 == VALUE_ALIAS</span></span><br><span class="line">    VALUE_2 = <span class="string">&#x27;A&#x27;</span> <span class="comment"># 字符串</span></span><br><span class="line">    VALUE_3 = <span class="number">1</span> <span class="comment"># 值可重复</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params">IntEnum</span>):</span> <span class="comment"># 继承自IntEnum只能使用int值</span></span><br><span class="line">    VALUE_1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@unique </span><span class="comment"># 声明值不可重复</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params">Enum</span>):</span></span><br><span class="line">    VALUE_1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用: 类名.VALUE_1</span></span><br><span class="line"><span class="string">枚举名: 类名.VALUE_1.name</span></span><br><span class="line"><span class="string">枚举值: 类名.VALUE_1.value</span></span><br><span class="line"><span class="string">遍历枚举: for i in 类名</span></span><br><span class="line"><span class="string">遍历枚举名: for i in 类名.__members__</span></span><br><span class="line"><span class="string">常规值转换成枚举值: 类名(1) -&gt; 类名.VALUE_1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
